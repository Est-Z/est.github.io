{"meta":{"title":"Est","subtitle":null,"description":"专注划水的技术博客","author":"Est","url":"https://Est-C.coding.me/Est-C.coding.me"},"pages":[],"posts":[{"title":"List","slug":"List","date":"2018-10-15T14:16:42.000Z","updated":"2018-10-15T16:09:51.600Z","comments":true,"path":"2018/10/15/List/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/15/List/","excerpt":"","text":"This is a page to show SqList Linkist and StaticList. ListList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;conio.h&gt;#include &lt;malloc.h&gt;#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0typedef int ElemType ;typedef int Status ;typedef struct LNode&#123; //单链表节点的定义 ElemType date; struct LNode *next;&#125;LNode, *LinkList;typedef struct LNode* LinkList; int iCount = 0; //记录链表长度 /*//初始化一个空的线性链表L Status InitList_L(LinkList &amp;L)&#123; L = (LinkList)malloc(sizeof(struct LNode)); if(!L)&#123; printf(\"分配空间失败\"); return ERROR; &#125; L-&gt;next = NULL; return OK;&#125;*///创建指定长度单链表Status CreateList_L(LinkList &amp;L,int n)&#123; iCount += n; L = (LinkList)malloc(sizeof(struct LNode)); L-&gt; next = NULL; //建立一个带头节点的单链表 LinkList q = L ; //p指向头节点 printf(\"&gt;&gt;输入链表的值：\"); while(n--)&#123; LinkList p = (LinkList)malloc(sizeof(struct LNode)); //申请一个新结点 scanf(\"%d\",&amp;p-&gt;date); //输入数据 p-&gt;next = q-&gt;next; //插入到表尾 q-&gt;next = p; q = p; &#125; if(L) printf(\"&gt;&gt;初始化成功！\\n\"); return OK; &#125; //第i个元素存在时，将第i个元素赋值个e并返回OK 否则返回ERROR Status GetELem_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(i&lt;1) &#123; //输入值有误 printf(\"输入值有误\"); return ERROR; &#125; LinkList p = L-&gt;next; int j; while( j &lt; i &amp;&amp; p)&#123; //j&lt;i且p不为空 p = p -&gt; next; j++; &#125; if( !p || j&gt;i )&#123; printf(\"第%d个元素不存在\",i); return ERROR; &#125; e = p -&gt; date; return OK; &#125; //在第i个元素之前插入元素eStatus ListInsert_L(LinkList &amp;L,int i,ElemType e) &#123; LinkList s; LinkList p = L; int j = 0; while( p &amp;&amp; j &lt; i-1)&#123; p = p-&gt; next; j++; &#125; if( !p &amp;&amp; j &gt; i-1 ) &#123; //输入值有误 printf(\"&gt;&gt;输入插入点有误\"); return ERROR; &#125; s = (LinkList)malloc(sizeof(LNode)); //插入 s -&gt; date = e; s -&gt; next = p -&gt; next; p -&gt; next = s; printf(\"&gt;&gt;插入成功！\\n\"); iCount++; return OK; &#125;//向线性表末尾添加一个元素Status InsertRear_L(LinkList &amp;L, ElemType e)&#123; LinkList p = L; while((p-&gt;next)!=NULL) //找到表尾 p = p-&gt;next; LinkList q = (LinkList)malloc(sizeof(struct LNode)); //新建结点插入 q -&gt; date = e; q -&gt; next = p -&gt; next; p -&gt; next = q; printf(\"&gt;&gt;插入成功！\\n\"); iCount++; //长度+1 return OK;&#125; //向有序链表插入一个元素 使之依然有序Status InsertOrder_L(LinkList &amp;L,ElemType e)&#123; LinkList p = L-&gt;next; //p指向第一个结点 LinkList q = L; //q指向p的上一个结点 if( (p-&gt;date) &gt; (p-&gt;next-&gt;date) )&#123; //判断有序还是逆序 while(p &amp;&amp; p-&gt;date &gt; e)&#123; q = p; p = p-&gt;next; &#125; &#125;else&#123; while( p &amp;&amp; p-&gt;date &lt; e)&#123; q = p; p = p-&gt;next; &#125; &#125; //此时p指向插入点 q指向插入点的上一个结点 LinkList z = (LinkList)malloc(sizeof(struct LNode)); //新建结点 z -&gt; date = e; z -&gt; next = q -&gt; next; q -&gt; next = z; printf(\"&gt;&gt;插入成功！\\n\"); iCount++; //长度+1 return OK;&#125; //删除第i个元素 并用e返回其值Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; int j = 0; LinkList q; LinkList p = L; while( p &amp;&amp; j &lt; i-1 )&#123; //寻找第i个节点 并使p指向其前驱 p = p -&gt; next; j++; &#125; if( !(p -&gt; next) &amp;&amp; j &gt; i-1)&#123; printf(\"&gt;&gt;删除位置有误!\"); return ERROR; &#125; q = p -&gt; next; //删除 p -&gt; next = q -&gt;next; e = q -&gt;date; free(q); printf(\"&gt;&gt;删除成功！\\n\"); iCount--; return OK; &#125; //删除表尾元素Status DeleteRear_L(LinkList &amp;L,ElemType &amp;e)&#123; LinkList p = L -&gt; next; LinkList q = L; while( (p-&gt;next) != NULL)&#123; q = p; p = p -&gt; next; &#125; //p指向表尾 q指向p的前驱 e = p -&gt; date; q -&gt;next = p -&gt; next; free(p); printf(\"&gt;&gt;删除成功！\\n\"); iCount--; return OK;&#125; //删除给定值的第一个元素Status Delete_L(LinkList &amp;L,ElemType e)&#123; LinkList p = L -&gt; next; LinkList q = L; while(p)&#123; if(p-&gt;date == e) break; q = p; p = p -&gt; next; &#125; if(!p)&#123; printf(\"&gt;&gt;输入元素在线性表L中不存在！\\n\"); return ERROR; &#125; q -&gt; next = p -&gt; next; free(p); printf(\"&gt;&gt;删除成功！\\n\"); iCount--; return OK;&#125; //遍历单链表Status ListTraverse_L(LinkList &amp;L)&#123; LinkList p = L-&gt;next ; int i = iCount; printf(\"&gt;&gt;当前单链表L = (\"); while(p)&#123; printf(\" %d\",p-&gt;date); p = p-&gt;next; &#125; printf(\" )\\n\"); return OK; &#125; int main() &#123; LinkList L; ElemType e; int pos; return 0;&#125; LinkList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;conio.h&gt;#include &lt;malloc.h&gt;#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0typedef int ElemType ;typedef int Status ;/* 自定义结点类型指针 结点包括数据项date和指向（struct LNode）的指针 Link Position为指向结点的指针类型 */typedef struct LNode&#123; ElemType date; struct LNode *next;&#125;*Link , *Position; /* 自定义指针结构指针 head tail是Link类型指针 用来指向结点 len存储链表长度 */ typedef struct List&#123; Link head,tail; //分别指向头尾 int len = 0; //长度 &#125;LinkList; /* 本程序中常用临时指针 p q r 来完成操作 均为Link类型 ----Written Est */ /*//初始化一个空的线性链表L Status InitList_L(LinkList &amp;L)&#123; L.head = (Link)malloc(sizeof(struct LNode)); if(!L.head)&#123; printf(\"分配空间失败\"); return ERROR; &#125; L.head-&gt;next = NULL; return OK;&#125;*///分配p指向e的结点Status MakeNode_L(Link p,ElemType e)&#123; p = (Link)malloc(sizeof(struct LNode)); if(p != NULL)&#123; p -&gt; date = e; p -&gt; next = NULL; return OK; &#125; return ERROR;&#125; //释放p指向的结点Status FreeNode_L(Link *p)&#123;&#125; //创建指定长度单链表Status CreateList_L(LinkList &amp;L,int n)&#123; L.head = L.tail = (Link)malloc(sizeof(struct LNode)); L.head -&gt; next = NULL; //建立一个带头节点的单链表 if(!L.head)&#123; printf(\"&gt;&gt;初始化失败！\"); return ERROR; &#125; Link q = L.head ; //p指向头节点 printf(\"&gt;&gt;输入链表的值：\"); while(n--)&#123; Link p = (Link)malloc(sizeof(struct LNode)); //申请一个新结点 scanf(\"%d\",&amp;p-&gt;date); //输入数据 q -&gt; next = p; //插入到表尾 q = p; L.len++ ; //长度+1 &#125; L.tail = q; L.tail-&gt;next = NULL; printf(\"&gt;&gt;初始化成功！\\n\"); return OK; &#125; //销毁线性表LStatus DestroyList_L(LinkList &amp;L)&#123; Link p; while(L.head != L.tail)&#123; //头结点开始 依次释放结点 p = L.head; L.head = L.head -&gt; next; free(p); &#125; if(L.head == L.tail)&#123; printf(\"&gt;&gt;销毁成功!\\n\"); L.head = L.tail = NULL; //头尾结点指向NULL L.len = 0; //长度更新 return OK; &#125; else&#123; printf(\"&gt;&gt;销毁失败!\\n\"); return ERROR; &#125; &#125;//清空线性表Status ClearList_L(LinkList &amp;L)&#123; Link p,q; p = L.head -&gt; next; while(p)&#123; q = p -&gt; next; free(p); p = q; &#125; L.tail = L.head; L.head -&gt; next = NULL; printf(\"&gt;&gt;清空成功!\\n\"); L.len = 0; return OK;&#125;//在链表的第一个位置插入节点，h指向头结点Status InsFirst_L(Link h,Link s)&#123; s-&gt;next = h-&gt;next; h-&gt;next = s; return OK;&#125;//在删除链表中第一个节点并以p返回，h为头结点指针Status DelFirst_L(Link h,Link p)&#123; p = h-&gt;next; h-&gt;next = h-&gt;next-&gt;next; return OK;&#125;//将s所指的一串结点连接在线性表L的最后一个结点Status Append_L(LinkList &amp;L,Link s)&#123; if(L.head)&#123; L.tail -&gt; next = s; Link temp = L.head; while(temp -&gt; next) temp = temp -&gt; next; L.tail = temp; return OK; &#125; return ERROR;&#125; //第i个元素存在时，将第i个元素赋值个e并返回OK 否则返回ERROR Status GetELem_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(i&lt;1) &#123; //输入值有误 printf(\"&gt;&gt;输入值有误!\"); return ERROR; &#125; int j; Link p = L.head -&gt; next; while( j &lt; i &amp;&amp; p)&#123; //j&lt;i且p不为空 找到第i个元素 p = p -&gt; next; j++; &#125; if( !p || j&gt;i )&#123; printf(\"第%d个元素不存在\",i); return ERROR; &#125; e = p -&gt; date; //e返回第i个元素的值 return OK; &#125; //在第i个元素之前插入元素eStatus InsBefore_L(LinkList &amp;L,int i,ElemType e) &#123; Link s; Link p = L.head; int j = 0; while( p &amp;&amp; j &lt; i-1)&#123; //找到第i-1个元素 并将p指向 p = p-&gt; next; j++; &#125; if( !p || j &gt; i-1 ) &#123; //输入值有误 printf(\"&gt;&gt;输入插入点有误！\"); return ERROR; &#125; s = (Link)malloc(sizeof(struct LNode)); //插入 s -&gt; date = e; s -&gt; next = p -&gt; next; p -&gt; next = s; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //更新长度 return OK; &#125;//向线性表末尾添加一个元素Status InsertRear_L(LinkList &amp;L, ElemType e)&#123; Link p = L.tail; //p指向表尾 Link q = (Link)malloc(sizeof(struct LNode)); //新建结点 q -&gt; date = e; q -&gt; next = p -&gt; next; //插入 p -&gt; next = q; p = p -&gt; next; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //长度+1 return OK;&#125; //向有序链表插入一个元素 使之依然有序Status InsertOrder_L(LinkList &amp;L,ElemType e)&#123; Link p = L.head -&gt; next; //p指向第一个结点 Link q = L.head; //q指向p的上一个结点 if( (p-&gt;date) &gt; (p-&gt;next-&gt;date) )&#123; //判断有序还是逆序 while(p &amp;&amp; p-&gt;date &gt; e)&#123; q = p; p = p-&gt;next; &#125; &#125;else&#123; while( p &amp;&amp; p-&gt;date &lt; e)&#123; q = p; p = p-&gt;next; &#125; &#125; //此时p指向插入点 q指向插入点的上一个结点 Link z = (Link)malloc(sizeof(struct LNode)); //新建结点 z -&gt; date = e; z -&gt; next = q -&gt; next; q -&gt; next = z; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //长度+1 return OK;&#125; //删除第i个元素 并用e返回其值Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(i &gt; L.len)&#123; printf(\"&gt;&gt;删除位置有误!\\n\"); return ERROR; &#125; int j = 0; Link q; Link p = L.head; while( p &amp;&amp; j &lt; i-1 )&#123; //寻找第i个节点 并使p指向其前驱 p = p -&gt; next; j++; &#125; if( !(p -&gt; next) &amp;&amp; j &gt; i-1)&#123; printf(\"&gt;&gt;删除位置有误!\"); return ERROR; &#125; q = p -&gt; next; //删除 p -&gt; next = q -&gt;next; e = q -&gt;date; free(q); printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK; &#125; //删除表尾元素Status DeleteRear_L(LinkList &amp;L,ElemType &amp;e)&#123; Link p = L.head ; while( (p-&gt;next) != L.tail) //p指向尾元素的前驱 p = p -&gt; next; e = L.tail -&gt; date; p -&gt; next = NULL; free(L.tail); L.tail = p; printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK;&#125; //删除给定值的第一个元素Status Delete_L(LinkList &amp;L,ElemType e)&#123; Link p = L.head -&gt; next; Link q = L.head; while(p)&#123; if(p-&gt;date == e) break; q = p; p = p -&gt; next; &#125; if(!p)&#123; printf(\"&gt;&gt;输入元素在线性表L中不存在！\\n\"); return ERROR; &#125; q -&gt; next = p -&gt; next; free(p); printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK;&#125; //设置p所指向节点的值Status SetCurElem(Link &amp;p,ElemType e)&#123; p-&gt;date = e; return OK;&#125;//计算链表的长度int ListLength(LinkList L)&#123; return L.len;&#125;//p指向L的一个结点，返回p指向结点的前驱的位置 无前驱返回NULLPosition PriorPos_L(LinkList &amp;L,Link p)&#123; Link temp = L.head; while( temp -&gt; next != p) temp = temp -&gt; next; return temp;&#125; //p指向L的一个结点，返回p指向结点的后继的位置 无后继返回NULLPosition NextPos_L(LinkList &amp;L,Link p)&#123; return p -&gt; next;&#125; //查找链表中第i个元素并以p返回Status LocatePos_L(LinkList &amp;L,int i,Link &amp;p)&#123; // p = NULL; ?? int iCount = 0; if( i &gt; 0 &amp;&amp; i &lt;= L.len)&#123; p = L.head; while(iCount++ != i) p = p -&gt; next; return OK; &#125; return ERROR;&#125; //返回头结点位置Position GetHead_L(LinkList L)&#123; return L.head;&#125; //返回尾结点位置Position GetLast_L(LinkList L)&#123; return L.tail;&#125; //查找与e相等的节点并返回该节点Position LocateElem_L(LinkList &amp;L,ElemType e)&#123; Link temp = L.head -&gt; next; while( temp -&gt; date != e ) //元素不在线性表中的情况未考虑 temp = temp -&gt; next; return temp;&#125;//合并两个有序表Status MergeList_L(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)&#123; //已知La，Lb为非逆序 Link pa = La.head -&gt; next; Link pb = Lb.head -&gt; next; Link pc; Lc = La; //La做Lc的头结点 pc = pa; while(pa &amp;&amp; pb)&#123; if(pa -&gt; date &lt;= pb -&gt; date)&#123; pc -&gt; next = pa; pc = pa; pa = pa -&gt; next; &#125;else&#123; pc -&gt; next = pb; pc = pb; pb = pb -&gt; next; &#125; &#125; pc -&gt;next = pa ? pa :pb; //插入剩余段 free(Lb.head); printf(\"&gt;&gt;合并成功!\\n\"); return OK;&#125;//遍历单链表Status ListTraverse_L(LinkList &amp;L)&#123; Link p = L.head -&gt; next; int i = L.len; printf(\"&gt;&gt;当前单链表L = (\"); while(p)&#123; printf(\" %d\",p-&gt;date); p = p-&gt;next; &#125; printf(\" )\\n\"); return OK; &#125; int main() &#123; Link p,h,s; LinkList L; LinkList La,Lb,Lc; ElemType e; int pos; return 0;&#125; StatcList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242#include&lt;stdio.h&gt;#define MAXSIZE 100#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef int ElemType;typedef struct&#123; ElemType data; int cur;&#125;component,SLinkList[MAXSIZE];//求链表长度int Length_SL(SLinkList S)&#123; int j = 0; int i = S[MAXSIZE-1].cur; while(i)&#123; j++; i = S[i].cur; &#125; return j; &#125; //动态分配函数int malloc_SL(SLinkList S)&#123; int i = S[0].cur; if(i == 0)&#123; printf(\"备用链表为空，无法分配！\"); return ERROR; &#125; S[0].cur = S[i].cur; return i; &#125;//freeStatus Free(SLinkList S, int k)&#123; //将位置为k的空闲结点释放 //即插入到备用链表第一个结点前 S[k].cur = S[0].cur; S[0].cur = k; return OK;&#125;//初始化Status InitList_SL(SLinkList S)&#123; int i; S[MAXSIZE-1].cur = 0; //链表头结点为空 for(i = 0 ;i &lt; MAXSIZE - 2 ; i++) S[i].cur = i+1; //备用链表 S[MAXSIZE-2].cur = 0; //链表最后一个元素为空 return OK;&#125; //销毁Status DestoryList_SL(SLinkList S)&#123; int i = S[MAXSIZE-1].cur; S[MAXSIZE-1].cur=0; //头结点指向空 int k = S[0].cur; //k记录备用链表第一个结点 S[0].cur = i; //S[0].cur 指向链表第一个元素 int j; while(i)&#123; //找到S最后一个结点 赋值给j j = i; i = S[i].cur; &#125; S[j].cur = k; //链接两个链表 return OK; &#125; //判空Status ListEmpty_SL(SLinkList S)&#123; if(S[MAXSIZE-1].cur == 0) return TRUE; else return FALSE; &#125; //取元素Status GetElem_SL(SLinkList S,int i,ElemType &amp;e)&#123; int j=1, k = S[MAXSIZE-1].cur; if (i&lt;1 || i &gt; Length_SL(S))&#123; //判断位置是否合理 printf(\"查找位置不合理！\"); return ERROR; &#125; while (k &amp;&amp; j&lt;i)&#123; //找到第i个位置 ++j; k = S[k].cur; &#125; e = S[k].data; return OK;&#125; //查找元素int LocateElem_SL(SLinkList S,ElemType e)&#123; int i = S[MAXSIZE-1].cur; int j = 0; while(i)&#123; j++; if(S[i].data == e) return j; else i = S[i].cur; &#125; if(!i)&#123; printf(\"查无此元素！\"); return ERROR; &#125; &#125; //找前驱 Status PriorElem_SL(SLinkList S, ElemType e, ElemType &amp;cur_e) &#123; int i = S[MAXSIZE-1].cur; int j ; while (j)&#123; j = S[i].cur; if (j &amp;&amp; S[j].data == e)&#123; cur_e = S[i].data; return OK; &#125; i = j; &#125; return ERROR; &#125; //找后继 Status NextElem_SL(SLinkList S, ElemType e, ElemType &amp;nex_e) &#123; int i = S[MAXSIZE-1].cur; int j; while (i)&#123; j = S[i].cur; if (j &amp;&amp; S[i].data == e)&#123; nex_e = S[j].data; return OK; &#125; i = j; &#125; return ERROR; &#125;//前插入Status Ins_SL(SLinkList S,int i,ElemType e)&#123; int s; int j = 1; int k = S[MAXSIZE-1].cur; if(i &lt; 1 || i &gt; Length_SL(S)+1)&#123; printf(\"插入位置不合理\"); return ERROR; &#125; while( k &amp;&amp; j &lt;i-1 )&#123; j++; k = S[k].cur; &#125; s = malloc_SL(S); S[s].data = e; S[s].cur = S[k].cur; S[k].cur = s; return OK; &#125; //删除 Status ListDelete(SLinkList S, int i, ElemType &amp;e) &#123; int k = S[MAXSIZE-1].cur; int j = 1, m; if (i&lt;1 || i&gt;Length_SL(S))&#123; //判断位置是否合理 printf(\"删除位置不合理！\"); return ERROR; &#125; while (k &amp;&amp; j&lt;i-1)&#123; //找到第i-1个位置 ++j; k = S[k].cur; &#125; m = S[k].cur; //m指向第i个位置 e = S[m].data; S[k].cur = S[m].cur; Free(S, m); //将空闲结点m释放到备用链表中 return OK; &#125;void TravelList(SLinkList S)&#123; int j = 0; int i = S[MAXSIZE-1].cur; while (i)&#123; j++; printf(\"第%d个结点为：%d\\n\", j, S[i].data); i = S[i].cur; &#125;&#125;int main()&#123; SLinkList S; ElemType e,cur_e,nex_e; int pos; return 0;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-10-13T15:21:23.447Z","updated":"2018-10-13T15:21:23.447Z","comments":true,"path":"2018/10/13/hello-world/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}