{"meta":{"title":"Est","subtitle":null,"description":"一个专注划水的博客","author":"Est","url":"https://Est-C.coding.me/Est-C.coding.me"},"pages":[],"posts":[{"title":"String","slug":"String","date":"2018-10-21T14:30:41.000Z","updated":"2018-10-22T15:34:11.504Z","comments":true,"path":"2018/10/21/String/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/21/String/","excerpt":"This is a blog to show SString.","text":"This is a blog to show SString. StringSString12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define ERROR 0#define OK 1#define TRUE 1#define FALSE 0#define MAXSTRLEN 255 //用户可在255以内定义最大串长 typedef unsigned char SString[MAXSTRLEN + 1]; //0号单元存放串的长度 typedef int Status;void StrPrint(SString T) ; // 输出字符串TStatus StrAssign(SString &amp;T,char chars[]); //生成一个其值等于chars的串T Status StrCopy(SString &amp;T,SString S); //由串S赋值得串TStatus ClearString(SString &amp;S); //将串置空Status StrDestory(SString &amp;T); //销毁Status StrEmpty(SString S); //判空int StrCompare(SString S,SString T); //S&gt;T 返回&gt;0 S=T 返回0 S&lt;T 返回&lt;0int StrLength(SString S); //返回串长度Status Concat(SString &amp;T,SString S1,SString S2); //连接串 S1S2 未截断返回 1 截断返回 0 Status SubString(SString &amp;Sub,SString S,int pos,int len); //用Sub返回串S的自第pos个字符起长度为len的子串int Index(SString S,SString T,int pos); //返回子串T在主串S中第pos个字符之后的位置 若不存在，则函数值为0Status StrInsert(SString &amp;S,int pos,SString T); //在串S的第pos个字符前插入串T 完全插入返回1 部分插入返回0Status StrDelete(SString S,int pos,int len) ; // 从串S中删除自第pos个字符起长度为len的子串Status Replace(SString &amp;S,SString T,SString V); //用V替换主串S中出现的所有与T相等的不重叠的子串 StrPrint12345678// 输出字符串Tvoid StrPrint(SString T) &#123; int i; for(i=1;i&lt;=T[0];i++) printf(\"%c\",T[i]); printf(\"\\n\"); &#125; StrAssign 12345678910111213141516//生成一个其值等于chars的串T Status StrAssign(SString &amp;T,char chars[])&#123; int i; if(strlen(chars) &gt; MAXSTRLEN)&#123; printf(\"&gt;串长超过最大串长\"); return ERROR; &#125;else&#123; T[0] = strlen(chars); //T[0]存放串长度 for(i=1 ; i&lt;=T[0] ; i ++) T[i] = *(chars+i-1); //逐个赋值 return OK; &#125; &#125; StrCopy 123456789//由串S赋值得串TStatus StrCopy(SString &amp;T,SString S)&#123; int i; for(i=0 ; i&lt;=S[0] ; i++) //赋值(带0一起复制) T[i] = S[i]; return OK; &#125; ClearString123456//将串置空Status ClearString(SString &amp;S)&#123; S[1] = '\\0'; S[0] = 0;&#125; StrDestory123456//销毁Status StrDestory(SString &amp;T)&#123; ClearString(T); return OK;&#125; StrEmpty123456789//判空Status StrEmpty(SString S)&#123; if(S[0] == 0) //0号存储字符串长度 return TRUE; else return FALSE; &#125; StrCompare1234567891011//S&gt;T 返回&gt;0 S=T 返回0 S&lt;T 返回&lt;0int StrCompare(SString S,SString T)&#123; int i; for( i=1 ; i&lt;=S[0]&amp;&amp;i&lt;=T[0] ; i++ ) if(S[i] != T[i]) //不相等 返回ascll码差值 return S[i] - T[i]; return S[0] - T[0]; //包含关系 返回长度差值 &#125; StrLength12345//返回串长度int StrLength(SString S)&#123; return S[0];&#125; Concat 1234567891011121314151617181920212223242526//连接串 S1S2 未截断返回 1 截断返回 0 Status Concat(SString &amp;T,SString S1,SString S2)&#123; int i,j; if( S1[0] + S2[0] &lt;= MAXSTRLEN)&#123; //未截断 T[0] = S1[0] + S2[0]; for( i=1 ; i &lt;= S1[0] ; i++ ) //连接S1 T[i] = S1[i]; for( j=1 ; j &lt;= S2[0] ; j++ ) //连接S2 T[i++] = S2[j]; return OK; &#125;else&#123; //截断 for( i=1 ; i &lt;= S1[0] ; i++ ) //连接S1 T[i] = S1[i]; for( j=1 ; i &lt;= MAXSTRLEN ; j++ ) //连接S2 T[i++] = S2[j]; T[0] = MAXSTRLEN; return FALSE; &#125;&#125; SubString 12345678910111213//用Sub返回串S的自第pos个字符起长度为len的子串Status SubString(SString &amp;Sub,SString S,int pos,int len)&#123; int i; if( pos&lt;1 || pos&gt;S[0] || len&lt;0 || len&gt;S[0]-pos+1) //条件错误 return ERROR; for( i=1 ; i&lt;=len ; i++) //赋值 Sub[i] = S[pos+i-1]; Sub[0] = len; return OK;&#125; Index1234567891011121314151617181920//返回子串T在主串S中第pos个字符之后的位置 若不存在，则函数值为0。 int Index(SString S,SString T,int pos)&#123; //算法改进 --查找字符串 (KMP) int i,n,m; SString sub; if( 1&lt;=pos &amp;&amp; pos&lt;=S[0])&#123; //位置合理 n = S[0]; m = T[0]; i = pos; while( i &lt;= n-m+1 )&#123; SubString(sub,S,i,m); if(StrCompare(sub,T) != 0) i++; else return i; &#125; &#125; return 0;&#125; StrInsert 1234567891011121314151617181920212223//在串S的第pos个字符前插入串T 完全插入返回1 部分插入返回0 Status StrInsert(SString &amp;S,int pos,SString T)&#123; int i; if( pos&lt;1 || pos&gt;S[0]+1 ) //插入位置(1-S[0]+1) return ERROR; if(S[0]+T[0]&lt;=MAXSTRLEN)&#123; //完全插入 for( i=S[0]; i&gt;=pos ;i-- ) S[i+T[0]] = S[i]; //插入点后面的字符串向后位移Strlen(T) for( i=pos; i&lt;pos+T[0] ; i++) S[i] = T[i-pos+1]; S[0] += T[0]; return OK; &#125;else&#123; //部分插入 for( i=MAXSTRLEN;i&gt;=pos+T[0];i--) S[i] = S[i-T[0]]; for( i=pos;i&lt;pos+T[0] &amp;&amp; i&lt;=MAXSTRLEN;i++ ) S[i] = T[i-pos+1]; S[0] = MAXSTRLEN; return FALSE; &#125;&#125; StrDelete 1234567891011// 从串S中删除自第pos个字符起长度为len的子串Status StrDelete(SString S,int pos,int len)&#123; int i; if( pos&lt;1 || pos&gt;S[0]-len+1 || len&lt;0) return ERROR; for( i=pos+len ; i&lt;=S[0];i++) S[i-len] = S[i]; S[0] -= len; return OK;&#125; Replace123456789101112131415161718192021222324//用V替换主串S中出现的所有与T相等的不重叠的子串 Status Replace(SString &amp;S,SString T,SString V)&#123; int i =1; //第一个位置开始查找 Status k; if(StrEmpty(T)) //T为空串 return ERROR; while(i)&#123; i = Index(S,T,i); if(i)&#123; StrDelete(S,i,StrLength(T)); k = StrInsert(S,i,V); if(!k) return ERROR; i += StrLength(V); &#125; &#125; return OK; &#125; Test12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void text()&#123; int i,j; Status k; char s,c[MAXSTRLEN]; SString t,s1,s2,s3,s4,s5,s6,s7; printf(\"请输入串s1: \"); gets(c); k=StrAssign(s1,c); printf(\"串长为%d 串空否？%d(1:是0:否)\\n\",StrLength(s1),StrEmpty(s1)); StrCopy(s3,s1); printf(\"拷贝s1生成的串为\"); StrPrint(s3); printf(\"请输入串s2: \"); gets(c); k=StrAssign(s2,c); StrPrint(s2); Concat(t,s1,s2); printf(\"连接s1s2为t：\"); StrPrint(t); SubString(s4,t,2,4); printf(\"t的字串 2-4 为：\"); StrPrint(s4); StrDelete(t,3,3); printf(\"删除t的字串 3-3后：\"); StrPrint(t); printf(\"请输入插入串: \"); gets(c); k=StrAssign(s5,c); StrInsert(t,3,s5); printf(\"在第三个位置插入后t为：\"); StrPrint(t); printf(\"请输入替换串: \"); gets(c); k=StrAssign(s6,c); printf(\"请输入要替换串: \"); gets(c); k=StrAssign(s7,c); Replace(t,s7,s6); printf(\"替换后t为：\"); StrPrint(t);&#125;int main()&#123; SString T,S; char chars[] = \"this is\"; text(); return 0;&#125; HString1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define ERROR 0#define OK 1#define TRUE 1#define FALSE 0typedef int Status;typedef struct&#123; char * ch; int length;&#125;HString;Status StrAssign(HString &amp;T,char *chars); //生成一个其值等于串常量chars的串Tint StrLength(HString S); //返回S元素个数 即串S的长度int StrCompare(HString S,HString T); //S&gt;T 返回大于0 S&lt;T 返回小于0Status ClearString(HString &amp;S); //将S变为空串 并释放S所占空间Status Concat(HString &amp;T,HString S1,HString S2); //T返回S1与S2连接而成的串Status SubString(HString &amp;Sub,HString S,int pos,int len); //返回串S第pos个元素起长度为len的字串 StrAssign123456789101112131415161718192021//生成一个其值等于串常量chars的串TStatus StrAssign(HString &amp;T,char *chars)&#123; int i,j; char *c; if(T.ch) //释放T原有空间 free(T.ch); for(i=0,c=chars;*c;i++,c++) ; //求chars长度 if(!i)&#123; T.ch = NULL; T.length = 0; &#125; else&#123; if(!(T.ch = (char*)malloc(i*sizeof(char)))) //申请失败 return ERROR; for(j=0 ; j&lt;i ; j++) //复制 T.ch[j] = chars[j]; &#125; return OK;&#125; StrLength1234//返回S元素个数 即串S的长度int StrLength(HString S)&#123; return S.length; &#125; StrCompare123456789//S&gt;T 返回大于0 S&lt;T 返回小于0int StrCompare(HString S,HString T)&#123; int i; for(i=0 ; i&lt;S.length &amp;&amp; i&lt;T.length ; i++) if(S.ch[i] != T.ch[i]) return S.ch[i] - T.ch[i]; return S.length - T.length;&#125; ClearString123456789//将S变为空串 并释放S所占空间Status ClearString(HString &amp;S)&#123; if(S.ch)&#123; free(S.ch); S.ch = NULL; &#125; S.length = 0; return OK;&#125; Concat123456789101112131415161718//T返回S1与S2连接而成的串Status Concat(HString &amp;T,HString S1,HString S2)&#123; int i,j; if(T.ch) free(T.ch); if(!(T.ch = (char*)malloc((S1.length+S2.length)*sizeof(char)))) return ERROR; for( i=0 ; i&lt;S1.length ; i++) T.ch[i] = S1.ch[i]; for( j=0 ; j&lt;S2.length ; j++) T.ch[i++] = S2.ch[j]; T.length = S1.length + S2.length; return OK;&#125; SubString12345678910111213141516171819202122//返回串S第pos个元素起长度为len的字串 Status SubString(HString &amp;Sub,HString S,int pos,int len)&#123; int i; if( pos&lt;1 || pos&gt;S.length || len&lt;0 || len&gt;S.length-pos+1 ) //条件错误 return ERROR; if(Sub.ch) //释放Sub原有空间 free(Sub.ch); if(!len)&#123; //字串长度为0 Sub.ch = NULL; Sub.length = 0; &#125;else&#123; Sub.ch = (char*)malloc(len*sizeof(char)); for( i=0 ; i&lt;len ; i++ ) //复制 Sub.ch[i] = Sub.ch[i+pos-1]; Sub.length = len; &#125;&#125; text1234int main()&#123; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"Queue","slug":"Queue","date":"2018-10-19T14:48:58.000Z","updated":"2018-10-21T15:53:22.828Z","comments":true,"path":"2018/10/19/Queue/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/19/Queue/","excerpt":"This is a blog to show SqQueue and LinkQueue.","text":"This is a blog to show SqQueue and LinkQueue. QueueSqQueue顺序队列有八个操作：初始化、判空、销毁、置空、求长、获取队头、入队、出队 代码头123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #define ERROR 0#define OK 1#define TRUE 1#define FALSE 0typedef int QElemType;typedef int Status; #define QUEUE_INIT_SIZE 100 //栈的大小#define STACKINCREMENT 10 //栈的增量typedef struct&#123; //栈的结构体 QElemType * base; QElemType front; QElemType rear; int queuesize;&#125;SqQueue;/* 队列的顺序存储结构*/ 初始化12345678910111213141516//初始化Status InitQueue(SqQueue &amp;Q)&#123; Q.base = (QElemType *)malloc(QUEUE_INIT_SIZE * sizeof(QElemType)); //分配空间 if(!Q.base)&#123; //判断是否申请成功 Q.queuesize = 0; return ERROR; &#125; Q.rear = 0; Q.front = 0; Q.queuesize = QUEUE_INIT_SIZE; return OK;&#125; 判空12345678//判断是否为空队列 Status QueueEmpty(SqQueue &amp;Q)&#123; if(Q.front == Q.rear) return TRUE; else return FALSE;&#125; 销毁123456//销毁Status DestroyQueue(SqQueue &amp;Q)&#123; free(Q.base); return OK; &#125; 置空123456//置为空队列 Status ClearEmpty(SqQueue &amp;Q)&#123; Q.front = Q.rear ; return OK;&#125; 求长12345//求队列的长度int QueueLength(SqQueue &amp;Q)&#123; return (Q.rear-Q.front+Q.queuesize) % Q.queuesize;&#125; 返回队头12345678910//返回队列头元素Status GetTop(SqQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) return ERROR; e = Q.base[Q.front]; return OK;&#125; 入队123456789//对尾插入Status EnQueue(SqQueue &amp;Q,QElemType e)&#123; Q.base[Q.rear] = e; //压栈 Q.rear = (Q.rear + 1) % Q.queuesize; return OK;&#125; 出队123456789101112//队头删除Status DeQueue(SqQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) //判空 return ERROR; e = Q.base[Q.front]; //出栈 Q.front = (Q.front + 1) % Q.queuesize; return OK;&#125; 输出123456789101112//遍历Status QueueTraverse(SqQueue Q)&#123; if(QueueEmpty(Q)) //判空 return ERROR; while(Q.front != Q.rear) printf(\"%d \",Q.base[Q.front++]); //输出 printf(\"\\n\"); return OK;&#125; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//textvoid text()&#123; SqQueue Q; QElemType e; InitQueue(Q); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLength(Q)); //队列插入为1 2 3 4 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); //删除对头 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); if(QueueEmpty(Q)) printf(\"栈空\\n\"); else printf(\"栈不空\\n\"); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLength(Q)); ClearEmpty(Q); //置空 QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLength(Q));&#125;int main()&#123; text(); return 0;&#125; LinkQueue代码头1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #define ERROR 0#define OK 1#define TRUE 1#define FALSE 0typedef int QElemType;typedef int Status; typedef struct QNode&#123; //队列结点 QElemType data; //数据域 struct QNode *next; //指针 &#125;QNode, *QueuePtr;typedef struct&#123; //队列指针 QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 &#125;LinkQueue; 初始化123456789101112//初始化Status InitQueue(LinkQueue &amp;Q)&#123; Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); //申请结点 if(!Q.front) //是否申请成功 return ERROR; Q.front -&gt; next = NULL; return OK;&#125; 销毁12345678910//销毁队列Status DestoryQueue(LinkQueue &amp;Q)&#123; while(Q.front)&#123; Q.rear = Q.front -&gt; next; free(Q.front); Q.front = Q.rear; &#125; &#125; 清空123456//请空队列Status ClearQueue(LinkQueue &amp;Q)&#123; Q.rear = Q.front; Q.front -&gt; next =NULL; return OK;&#125; 判空1234567//判空Status QueueEmpty(LinkQueue &amp;Q)&#123; if(Q.front == Q.rear) return TRUE; else return FALSE;&#125; 求长12345678910111213//求队列元素个数int QueueLenght(LinkQueue &amp;Q)&#123; QueuePtr p = Q.front -&gt; next; int iCount=0; while(p)&#123; iCount++; p = p -&gt; next; &#125; return iCount;&#125; 返回队头12345678910//返回队头Status GetHead(LinkQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) return ERROR; e = Q.front -&gt; next -&gt; data; return OK;&#125; 入队12345678910111213141516//插入元素Status EnQueue(LinkQueue &amp;Q,QElemType e)&#123; QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); if(!p) return ERROR; p -&gt; next = NULL; p -&gt; data = e; Q.rear -&gt; next = p; Q.rear = p; return OK;&#125; 出队1234567891011121314151617//删除元素Status DeQueue(LinkQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) return ERROR; QueuePtr p = Q.front -&gt; next; e = p -&gt; data; Q.front -&gt; next = p -&gt; next; if(Q.rear == p) Q.rear = Q.front; free(p); return OK;&#125; 输出123456789101112//遍历Status QueueTraverse(LinkQueue Q)&#123; Q.front = Q.front -&gt; next; while(Q.front)&#123; printf(\"%d \",Q.front-&gt;data); Q.front = Q.front -&gt; next; &#125; printf(\"\\n\"); return OK;&#125; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//textvoid text()&#123; LinkQueue Q; QElemType e; InitQueue(Q); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLenght(Q)); //队列插入为1 2 3 4 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); //删除对头 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); if(QueueEmpty(Q)) printf(\"栈空\\n\"); else printf(\"栈不空\\n\"); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLenght(Q)); ClearQueue(Q); //置空 QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLenght(Q)); &#125; int main()&#123; text(); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"Stack","slug":"Stack","date":"2018-10-18T16:19:10.000Z","updated":"2018-10-21T15:53:28.503Z","comments":true,"path":"2018/10/19/Stack/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/19/Stack/","excerpt":"This is a blog to show SqStack and LinkStack.","text":"This is a blog to show SqStack and LinkStack. StackSqStack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;conio.h&gt;#define STACK_INIT_SIZE 100 //栈的大小#define STACKINCREMENT 10 //栈的增量#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status; //Status表示返回状态typedef char SElemType; //SElmType为int类型typedef struct&#123; //栈的结构体 SElemType * base; //栈底指针 SElemType * top; //栈顶指针 int stacksize; //栈大小 &#125;SqStack;/* 栈的顺序存储结构*///初始化Status InitStack(SqStack &amp;S)&#123; S.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType)); //分配空间 if(!S.base)&#123; //判断是否申请成功 S.stacksize = 0; return ERROR; &#125; S.top = S.base; S.stacksize = STACK_INIT_SIZE; //更新栈 return OK;&#125;//判断是否为空栈Status StackEmpty(SqStack S)&#123; if(S.base == S.top) return TRUE; else return FALSE;&#125;//销毁Status DestroyStack(SqStack &amp;S)&#123; free(S.base); free(S.top); S.base = NULL; S.top = NULL; return OK; &#125;//置为空栈Status ClearEmpyt(SqStack &amp;S)&#123; S.base = S.top; return OK;&#125;//求栈的长度int StackLength(SqStack &amp;S)&#123; return S.top-S.base;&#125;//返回栈顶元素Status GetTop(SqStack S,SElemType &amp;e)&#123; if(S.base==S.top) return ERROR; e = *(S.top-1); return OK;&#125;//栈顶插入Status Push(SqStack &amp;S,SElemType e)&#123; if(S.top - S.base &gt;= S.stacksize)&#123; //栈满 S.base = (SElemType *)realloc(S.base,(S.stacksize+STACKINCREMENT)*sizeof(SElemType)); //申请新空间 if(!S.base)&#123; printf(\"空间申请失败！\"); return ERROR; &#125; S.top = S.base + S.stacksize; //更新栈顶指针 S.stacksize += STACKINCREMENT; //更新长度 &#125; *S.top++ = e; //压栈 return OK;&#125;//栈顶删除Status Pop(SqStack &amp;S,SElemType &amp;e)&#123; if(S.base == S.top) //判空 return ERROR; e = *--S.top; //出栈 return OK;&#125;//遍历Status StackTraverse(SqStack S)&#123; if(StackEmpty) //判空 return ERROR; while(S.base &lt; S.top) printf(\"%c \",*(S.base++)); //输出 printf(\"\\n\"); return OK;&#125;int main()&#123; return 0;&#125; LinkStack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int SElemType;typedef int Status; typedef struct StackNode&#123; SElemType data; //数据域 struct StackNode *next; //结构体指针 &#125;StackNode , *LinkStackPtr;typedef struct LinkStack&#123; //栈指针 LinkStackPtr top; //top指针 int count; //栈元素个数 &#125;LinkStack;//初始化Status InitStack(LinkStack &amp;S)&#123; S.top = (LinkStackPtr)malloc(sizeof(StackNode)); //申请空间 S.count = 0; if(!S.top) //是否申请成功 return ERROR; S.top-&gt;next = NULL; //头结点指向NULL (栈底) return OK;&#125;//判空Status StackEmpty(LinkStack &amp;S)&#123; return S.count == 0 ? TRUE : FALSE;&#125; //入栈Status Push(LinkStack &amp;S , SElemType e)&#123; LinkStackPtr p = (LinkStackPtr)malloc(sizeof(StackNode)); //申请新节点 p -&gt; data = e; p -&gt; next = S.top; //结点赋值 S.top = p; S.count++; //更改链表关系 return OK;&#125;//出栈Status Pop(LinkStack &amp;S,SElemType &amp;e)&#123; if(StackEmpty(S))&#123; //是否栈空 printf(\"栈空！！！\"); return ERROR; &#125; LinkStackPtr p = S.top; //p指向栈顶 e = p-&gt;data; S.top = S.top -&gt; next; S.count--; //更新链表关系 free(p); return OK;&#125; //返回栈顶Status GetStack(LinkStack &amp;S,SElemType &amp;e)&#123; if(StackEmpty(S))&#123; printf(\"栈空！！！\"); return ERROR; &#125; e = S.top -&gt; data; return OK;&#125; //获取长度int GetLengthLinkStack(LinkStack &amp;S)&#123; return S.count; &#125; //输出Status Stacktraverse(LinkStack &amp;S)&#123; if(!S.top &amp;&amp; S.count) return ERROR; LinkStackPtr p = S.top; while(p-&gt;next)&#123; printf(\"%d\",p-&gt;data); p = p -&gt; next; &#125; return OK; &#125; //textvoid text()&#123; LinkStack S; SElemType e; LinkStack stack; InitStack(S);//初始化 e=1; Push(S, e); e=2; Push(S, e); e=3; Push(S, e); e=4; Push(S, e); printf(\"链栈元素：\"); Stacktraverse(S); printf(\"链栈元素个数：%d\\n\", GetLengthLinkStack(S)); SElemType e1,e2,e3; Pop(S,e1); printf(\"弹出第一个元素：%d\\n\", e1); Pop(S,e2); printf(\"弹出第二个元素：%d\\n\", e2); Pop(S,e3); printf(\"弹出第二个元素：%d\\n\", e3); printf(\"链栈元素：\"); Stacktraverse(S); printf(\"链栈元素个数：%d\", GetLengthLinkStack(S)); printf(\"\\n\"); GetStack(S,e3); printf(\"$%d\",e3);&#125; int main()&#123; text(); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"List","slug":"List","date":"2018-10-15T14:16:42.000Z","updated":"2018-10-21T15:53:15.648Z","comments":true,"path":"2018/10/15/List/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/15/List/","excerpt":"This is a blog to show SqList LinkStack and StaticStack.","text":"This is a blog to show SqList LinkStack and StaticStack. ListSqList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#include&lt;conio.h&gt;#define ERROR 0#define OK 1#define FALSE 0#define TRUE 1typedef int ElemType;typedef int Status; //返回状态 #define LIST_INIT_SIZE 100 //线性表大小 #define INIT_INCREMENT 10 //线性表增量typedef struct&#123; ElemType *elem; int length; int listSize;&#125;SqList;//判断元素是否存在 存在返回i的值Status compare(ElemType e1 , ElemType e2)&#123; if( e1 == e2 ) return TRUE; else return FALSE;&#125;//访问每一个元素 Status visit(ElemType e)&#123; printf(\"%d \",e); return OK;&#125;//初始化线性表 Status InitList_Sq(SqList &amp;L)&#123; L.elem = (ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType)); //动态分配空间 L.length = 0; //先令线性表长度为0 即使初始化失败L.length也有明确的值 if(!L.elem)&#123; printf(\"初始化失败\"); return ERROR; //分配失败 返回ERROR &#125; L.listSize = LIST_INIT_SIZE; //线性表d大小 return OK; &#125;//销毁线性表 Status DestoryList_Sq(SqList &amp;L)&#123; free(L.elem); //释放申请来的空间 return OK; &#125; //清空线性表 Status ClearList_Sq(SqList &amp;L)&#123; L.length = 0; //长度变为0 return OK;&#125;//判空表 空返回TRUE 否则FALSE Status ListEmpty_Sq(SqList &amp;L)&#123; return L.length ? TRUE : FALSE ; //长度为0则为空表 &#125; //求线性表长度Status ListLength_Sq(SqList &amp;L)&#123; if(L.length == 0)&#123; printf(\"线性表为空！\"); return ERROR; &#125; return L.length; //返回长度 &#125; //用e返回第i个元素值Status GetElem_Sq(SqList &amp;L,int i,ElemType &amp;e)&#123; if( L.length == 0 || i&lt;1 || i&gt;L.length)&#123; printf(\"输入元素的位置有误\"); return ERROR; &#125; e = L.elem[i-1]; return OK;&#125;//操作结果：返回L中第1个与e满足compare()的数据元素的位序，若这样的数据元素不存在，则返回值为0。Status LocateElem_Sq(SqList &amp;L,ElemType &amp;e)&#123; int i=0; while( i&lt;L.length &amp;&amp; !compare(L.elem[i],e) ) i++; if(compare(L.elem[i],e)) return i; else return 0;&#125;//操作：cur_e是L的元素且不会是第一个 则用pre_e返回他的前驱Status PriorElem_Sq(SqList &amp;L,ElemType cur_e,ElemType &amp;pre_e)&#123; int i = LocateElem_Sq(L,cur_e); //获取cur_e的位置 if(i == 0) printf(\"cur_e不在L中或为首元素\"); else pre_e = L.elem[i-1]; return OK;&#125;//cur_e是L的元素且不会是最后一个 则用next_e返回他的后继Status NextElem_Sq(SqList &amp;L,ElemType cur_e,ElemType &amp;next_e)&#123; int i = LocateElem_Sq(L,cur_e); //获取cur_e的位置 if(i == 0)&#123; printf(\"该元素不在线性表中\"); return ERROR; &#125;else if(i == L.length)&#123; printf(\"该元素为末元素\"); return ERROR; &#125;else next_e = L.elem[i+1]; return OK;&#125;//在L的第i个位置之前插入新元素Status ListInsert_Sq(SqList &amp;L, int i ,ElemType e)&#123; //i的合法值为 1-L.length+1 if(i&lt;1 || i&gt;L.length+1)&#123; printf(\"插入的位置有问题\"); return ERROR; //i值不合法 &#125; //若线性表已满 则分配空间 if(L.length&gt;=L.listSize)&#123; ElemType *newbase = (ElemType*)realloc(L.elem,(L.listSize+INIT_INCREMENT)*sizeof(ElemType)); //增加分配空间 if(!newbase)&#123; printf(\"存储分配失败\"); return ERROR; //是否成功分配 &#125; L.elem = newbase; L.listSize += INIT_INCREMENT; //更改长度 &#125; ElemType *p = &amp;(L.elem[i-1]); //p为插入点指针 ElemType *q = &amp;(L.elem[L.length-1]); //q为最后一个元素指针 while(p&lt;=q)&#123; //插入 *(q+1) = *q; q--; &#125; *p = e; L.length++; return OK;&#125; //删除第i个元素 用e返回 L长度减1Status ListDelete_Sq(SqList &amp;L,int i,ElemType &amp;e)&#123; if(i&gt;L.length || i&lt;1)&#123; //删除元素有误 printf(\"被删除元素位置有误\"); return ERROR; &#125; ElemType *p = &amp;(L.elem[i-1]); //p指向被删除元素 e = *p; ElemType *q = &amp;(L.elem[L.length-1]); //q指向末元素 while(p&lt;q)&#123; //删除 *p = *(p+1); p++; &#125; L.length--; return OK; &#125; //输出线性表 Status ListTraverse_Sq(SqList &amp;L)&#123; if(!L.elem)&#123; printf(\"\\n线性表未初始化或被销毁了!!!\"); return ERROR; &#125; if(L.length==0)&#123; printf(\"线性表中无元素!!!\"); return ERROR; &#125; int i; for( i = 0 ; i &lt;L.length ; i++) visit(L.elem[i]); return OK;&#125;//textvoid initMenu(SqList L) &#123; printf(\"\\n\\t\\t\\*------------------------------------------*\\n\"); printf(\"\\n\\t\\t 初始化成功，L.length=%d\\n\", L.length); printf(\"\\n\\t\\t 1.创建随机链表\\t 2.遍历线性表\\n\\t\\t 3.清空线性表\\t\\t 4.线性表插入\\n\\t\\t 5.查找表中元素\"); printf(\"\\t 6.判断元素是否在表中\\n\\t\\t 7.删除某个元素\\t 8.线性表长度\\n\\t\\t 9.线性表是否为空\\t 10.回到主菜单\\n\\t\\t 0.退出\");&#125;void mainMenu() &#123; printf(\"\\n\\t\\t*------------------------------------------*\\n\"); printf(\"\\n\\t\\t 欢迎回到主菜单\\n\"); printf(\"\\n\\t\\t 1.创建随机链表\\t 2.遍历线性表\\n\\t\\t 3.清空线性表\\t\\t 4.线性表插入\\n\\t\\t 5.查找表中元素\"); printf(\"\\t 6.判断元素是否在表中\\n\\t\\t 7.删除某个元素\\t 8.线性表长度\\n\\t\\t 9.线性表是否为空\\t 10.回到主菜单\\n\\t\\t 0.退出\");&#125;void text()&#123; int lLength, i; ElemType e; SqList L; InitList_Sq(L); initMenu(L); int select; while(1) &#123; printf(\"\\n请选择你的操作：\"); scanf(\"%d\", &amp;select); switch(select) &#123; case 1: InitList_Sq(L); printf(\"创建随机链表：\"); ListTraverse_Sq(L); break; case 2: printf(\"遍历线性表：\"); ListTraverse_Sq(L); break; case 3: ClearList_Sq(L); printf(\"清空L后：L.length = %d\\n\", L.length); ListTraverse_Sq(L); break; case 4: printf(\"请输入要插入的元素位置和元素的值(eg:1 2)：\"); scanf(\"%d %d\", &amp;i, &amp;e); while(ListInsert_Sq(L, i, e)) &#123; printf(\"插入完毕，现在线性表为：\"); ListTraverse_Sq(L); printf(\" 是否继续？ 1.是 0.否 \"); int selectAgain ; scanf(\"%d\", &amp;selectAgain); if(selectAgain==0) break; printf(\"请输入要插入的元素位置和元素的值：\"); scanf(\"%d %d\", &amp;i, &amp;e); &#125; printf(\"\\n\"); break; case 5: printf(\"请输入要查找的元素位置：\"); scanf(\"%d\",&amp;i); if(GetElem_Sq(L, i, e)) printf(\"第%d个元素的值为：%d\\n\", i, e); else printf(\"请输入正确的数字！！！\\n\"); break; case 6: printf(\"请输入你想知道是否在表中的数值：\"); scanf(\"%d\", &amp;e); // 这里假定随机数组中的元素互不重复 i = LocateElem_Sq(L, e); if(i) printf(\"值为%d是表中的第%d个元素\\n\", e, i); else printf(\"没有值为%d的元素\\n\", e); break; case 7: printf(\"请输入要删除的元素位置：\"); scanf(\"%d\", &amp;i); if(ListDelete_Sq(L, i, e))&#123; printf(\"元素%d删除完毕，现在线性表为：\\n\", e); ListTraverse_Sq(L); &#125;else printf(\"\\n\"); break; case 8: lLength = ListLength_Sq(L); printf(\"线性表的长度为: %d \\n\", lLength); break; case 9: if (!ListEmpty_Sq(L)) printf(\"该线性表为空.\\n\"); else printf(\"该线性表非空.\\n\"); break; case 10: mainMenu(); break; case 0: break; default: printf(\"请输入正确的数字!!!\\n\"); break; &#125; &#125; &#125; int main() &#123; text(); return 0;&#125; LinkList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;conio.h&gt;#include &lt;malloc.h&gt;#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0typedef int ElemType ;typedef int Status ;/* 自定义结点类型指针 结点包括数据项date和指向（struct LNode）的指针 Link Position为指向结点的指针类型 */typedef struct LNode&#123; ElemType date; struct LNode *next;&#125;*Link , *Position; /* 自定义指针结构指针 head tail是Link类型指针 用来指向结点 len存储链表长度 */ typedef struct List&#123; Link head,tail; //分别指向头尾 int len = 0; //长度 &#125;LinkList; /*//初始化一个空的线性链表L Status InitList_L(LinkList &amp;L)&#123; L.head = (Link)malloc(sizeof(struct LNode)); if(!L.head)&#123; printf(\"分配空间失败\"); return ERROR; &#125; L.head-&gt;next = NULL; return OK;&#125;*///分配p指向e的结点Status MakeNode_L(Link p,ElemType e)&#123; p = (Link)malloc(sizeof(struct LNode)); if(p != NULL)&#123; p -&gt; date = e; p -&gt; next = NULL; return OK; &#125; return ERROR;&#125; //释放p指向的结点Status FreeNode_L(Link &amp;p)&#123; free(p); p = NULL; return OK;&#125; //创建指定长度单链表Status CreateList_L(LinkList &amp;L,int n)&#123; L.head = L.tail = (Link)malloc(sizeof(struct LNode)); L.head -&gt; next = NULL; //建立一个带头节点的单链表 if(!L.head)&#123; printf(\"&gt;&gt;初始化失败！\"); return ERROR; &#125; Link q = L.head ; //p指向头节点 printf(\"&gt;&gt;输入链表的值：\"); while(n--)&#123; Link p = (Link)malloc(sizeof(struct LNode)); //申请一个新结点 scanf(\"%d\",&amp;p-&gt;date); //输入数据 q -&gt; next = p; //插入到表尾 q = p; L.len++ ; //长度+1 &#125; L.tail = q; L.tail-&gt;next = NULL; printf(\"&gt;&gt;初始化成功！\\n\"); return OK; &#125; //销毁线性表LStatus DestroyList_L(LinkList &amp;L)&#123; Link p; while(L.head != L.tail)&#123; //头结点开始 依次释放结点 p = L.head; L.head = L.head -&gt; next; FreeNode_L(p); &#125; L.head = NULL; L.tail = NULL; //防止野指针 L.len = 0; return OK; &#125;//清空线性表Status ClearList_L(LinkList &amp;L)&#123; if(L.len == 0) return OK; Link p,q; p = L.head -&gt; next; while(p)&#123; q = p -&gt; next; FreeNode_L(p); p = q; L.len--; &#125; L.head -&gt; next = L.tail; printf(\"&gt;&gt;清空成功!\\n\"); return OK;&#125;//在链表的第一个位置插入节点，h指向头结点Status InsFirst_L(Link h,Link s)&#123; s-&gt;next = h-&gt;next; h-&gt;next = s; return OK;&#125;//在删除链表中第一个节点并以p返回，h为头结点指针Status DelFirst_L(Link h,Link p)&#123; p = h-&gt;next; h-&gt;next = h-&gt;next-&gt;next; return OK;&#125;//将s所指的一串结点连接在线性表L的最后一个结点Status Append_L(LinkList &amp;L,Link s)&#123; if(L.head)&#123; L.tail -&gt; next = s; Link temp = L.head; while(temp -&gt; next) temp = temp -&gt; next; L.tail = temp; //L.tail指向最后一个结点temp-&gt;next==NULL return OK; &#125; return ERROR;&#125; //第i个元素存在时，将第i个元素赋值个e并返回OK 否则返回ERROR Status GetELem_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(i&lt;1) &#123; //输入值有误 printf(\"&gt;&gt;输入值有误!\"); return ERROR; &#125; int j; Link p = L.head -&gt; next; while( j &lt; i &amp;&amp; p)&#123; //j&lt;i且p不为空 找到第i个元素 p = p -&gt; next; j++; &#125; if( !p || j&gt;i )&#123; printf(\"第%d个元素不存在\",i); return ERROR; &#125; e = p -&gt; date; //e返回第i个元素的值 return OK; &#125; //在第i个元素之前插入元素eStatus InsBefore_L(LinkList &amp;L,int i,ElemType e) &#123; Link s; Link p = L.head; int j = 0; while( p &amp;&amp; j &lt; i-1)&#123; //找到第i-1个元素 并将p指向 p = p-&gt; next; j++; &#125; if( !p || j &gt; i-1 ) &#123; //输入值有误 printf(\"&gt;&gt;输入插入点有误！\"); return ERROR; &#125; s = (Link)malloc(sizeof(struct LNode)); //插入 s -&gt; date = e; s -&gt; next = p -&gt; next; p -&gt; next = s; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //更新长度 return OK; &#125;//向线性表末尾添加一个元素Status InsertRear_L(LinkList &amp;L, ElemType e)&#123; Link p = L.tail; //p指向表尾 Link q = (Link)malloc(sizeof(struct LNode)); //新建结点 q -&gt; date = e; q -&gt; next = p -&gt; next; //插入 p -&gt; next = q; p = p -&gt; next; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //长度+1 return OK;&#125; //向有序链表插入一个元素 使之依然有序Status InsertOrder_L(LinkList &amp;L,ElemType e)&#123; Link p = L.head -&gt; next; //p指向第一个结点 Link q = L.head; //q指向p的上一个结点 if( (p-&gt;date) &gt; (p-&gt;next-&gt;date) )&#123; //判断有序还是逆序 while(p &amp;&amp; p-&gt;date &gt; e)&#123; q = p; p = p-&gt;next; &#125; &#125;else&#123; while( p &amp;&amp; p-&gt;date &lt; e)&#123; q = p; p = p-&gt;next; &#125; &#125; //此时p指向插入点 q指向插入点的上一个结点 Link z = (Link)malloc(sizeof(struct LNode)); //新建结点 z -&gt; date = e; z -&gt; next = q -&gt; next; q -&gt; next = z; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //长度+1 return OK;&#125; //删除第i个元素 并用e返回其值Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(i &gt; L.len)&#123; printf(\"&gt;&gt;删除位置有误!\\n\"); return ERROR; &#125; int j = 0; Link q; Link p = L.head; while( p &amp;&amp; j &lt; i-1 )&#123; //寻找第i个节点 并使p指向其前驱 p = p -&gt; next; j++; &#125; if( !(p -&gt; next) &amp;&amp; j &gt; i-1)&#123; //结点位置错误 printf(\"&gt;&gt;删除位置有误!\"); return ERROR; &#125; q = p -&gt; next; //删除 p -&gt; next = q -&gt;next; e = q -&gt;date; free(q); printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK; &#125; //删除表尾元素Status DeleteRear_L(LinkList &amp;L,ElemType &amp;e)&#123; Link p = L.head ; while( (p-&gt;next) != L.tail) //p指向尾元素的前驱 p = p -&gt; next; e = L.tail -&gt; date; p -&gt; next = NULL; FreeNode_L(L.tail); L.tail = p; printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK;&#125; //删除给定值的第一个元素Status Delete_L(LinkList &amp;L,ElemType e)&#123; Link p = L.head -&gt; next; Link q = L.head; while(p)&#123; if(p-&gt;date == e) break; q = p; p = p -&gt; next; &#125; if(!p)&#123; printf(\"&gt;&gt;输入元素在线性表L中不存在！\\n\"); return ERROR; &#125; q -&gt; next = p -&gt; next; free(p); printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK;&#125; //设置p所指向节点的值Status SetCurElem(Link &amp;p,ElemType e)&#123; p-&gt;date = e; return OK;&#125;//计算链表的长度int ListLength(LinkList L)&#123; return L.len;&#125;//p指向L的一个结点，返回p指向结点的前驱的位置 无前驱返回NULLPosition PriorPos_L(LinkList &amp;L,Link p)&#123; Link temp = L.head; while( temp -&gt; next != p) temp = temp -&gt; next; return temp;&#125; //p指向L的一个结点，返回p指向结点的后继的位置 无后继返回NULLPosition NextPos_L(LinkList &amp;L,Link p)&#123; return p -&gt; next;&#125; //查找链表中第i个元素并以p返回Status LocatePos_L(LinkList &amp;L,int i,Link &amp;p)&#123; int iCount = 0; if( i &gt; 0 &amp;&amp; i &lt;= L.len)&#123; p = L.head; while(iCount++ != i) p = p -&gt; next; return OK; &#125; return ERROR;&#125; //返回头结点位置Position GetHead_L(LinkList L)&#123; return L.head;&#125; //返回尾结点位置Position GetLast_L(LinkList L)&#123; return L.tail;&#125; //查找与e相等的节点并返回该节点Position LocateElem_L(LinkList &amp;L,ElemType e)&#123; Link temp = L.head -&gt; next; while( temp -&gt; date != e ) //元素不在线性表中的情况未考虑 temp = temp -&gt; next; return temp;&#125;//合并两个有序表Status MergeList_L(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)&#123; //已知La，Lb为非逆序 Link pa = La.head -&gt; next; Link pb = Lb.head -&gt; next; Link pc; Lc = La; //La做Lc的头结点 pc = pa; while(pa &amp;&amp; pb)&#123; if(pa -&gt; date &lt;= pb -&gt; date)&#123; pc -&gt; next = pa; pc = pa; pa = pa -&gt; next; &#125;else&#123; pc -&gt; next = pb; pc = pb; pb = pb -&gt; next; &#125; &#125; pc -&gt;next = pa ? pa :pb; //插入剩余段 free(Lb.head); printf(\"&gt;&gt;合并成功!\\n\"); return OK;&#125;//遍历单链表Status ListTraverse_L(LinkList &amp;L)&#123; Link p = L.head -&gt; next; int i = L.len; printf(\"&gt;&gt;当前单链表L = (\"); while(p)&#123; printf(\" %d\",p-&gt;date); p = p-&gt;next; &#125; printf(\" )\\n\"); return OK; &#125; //text void InitMainMenu()&#123; printf(\"\\n\\t\\t\\t\\t 单链表的基本操作\\n\"); printf(\"\\t\\t/*--------------------------------------------------*/\\n\"); printf(\"\\t\\t 1.创建单链表\\t\\t 2.销毁线性表\\n\"); printf(\"\\t\\t 3.清空单链表\\t\\t 4.删除一个元素\\n\"); printf(\"\\t\\t 5.插入一个元素\\t 6.合并两个顺序表\\n\"); printf(\"\\t\\t 7.查找元素的前驱\\t 8.输出L\\n\");&#125; void text()&#123; Link p,h,s; LinkList L; LinkList La,Lb,Lc; ElemType e; int pos; int select; InitMainMenu(); while(1)&#123; printf(\"\\n&gt;请选择你的操作:\"); scanf(\"%d\",&amp;select); switch(select)&#123; case 1: printf(\"&gt;&gt;输入你想创建的链表长度:\"); scanf(\"%d\",&amp;pos); //InitList_L(L); CreateList_L(L,pos); ListTraverse_L(L); break; case 2: DestroyList_L(L); break; case 3: ClearList_L(L); ListTraverse_L(L); break; case 4: printf(\"&gt;&gt;输入你想要的删除方式：1.指定位置删除 2.表尾删除 3.删除给定值的第一个元素 \"); int deleteSelect; scanf(\"%d\",&amp;deleteSelect); switch(deleteSelect)&#123; case 1: printf(\"&gt;&gt;请输入删除位置：\"); scanf(\"%d\",&amp;pos); if(ListDelete_L(L,pos,e)) printf(\"&gt;&gt;删除第%d个元素%d\\n\",pos,e); ListTraverse_L(L); break; case 2: DeleteRear_L(L,e); printf(\"&gt;&gt;删除表尾元素%d\\n\",e); ListTraverse_L(L); break; case 3: printf(\"&gt;&gt;请输入删除元素：\"); scanf(\"%d\",&amp;e); Delete_L(L,e); ListTraverse_L(L); break; &#125; break; case 5: printf(\"&gt;&gt;输入你想要的插入方式：1.指定位置插入 2.表尾插入 3.有序链表插入 \"); int insertSelect; scanf(\"%d\",&amp;insertSelect); switch(insertSelect)&#123; case 1: printf(\"&gt;&gt;请输入插入位置和插入元素：\"); scanf(\"%d %d\",&amp;pos,&amp;e); InsBefore_L(L,pos,e); ListTraverse_L(L); break; case 2: printf(\"&gt;&gt;请输入插入元素：\"); scanf(\"%d\",&amp;e); InsertRear_L(L,e); ListTraverse_L(L); break; case 3: printf(\"&gt;&gt;请输入插入元素：\"); scanf(\"%d\",&amp;e); InsertOrder_L(L,e); ListTraverse_L(L); break; &#125; break; case 6: printf(\"&gt;&gt;输入第一个链表长度:\"); scanf(\"%d\",&amp;pos); CreateList_L(La,pos); ListTraverse_L(La); printf(\"&gt;&gt;输入第二个链表长度:\"); scanf(\"%d\",&amp;pos); CreateList_L(Lb,pos); ListTraverse_L(Lb); MergeList_L(La,Lb,Lc); ListTraverse_L(Lc); break; case 7: printf(\"&gt;&gt;请输入查找方式：1.查找固定位置元素的前驱 2.查找固定元素的前驱 \"); Link k; int posSelect; scanf(\"%d\",&amp;posSelect); switch(posSelect)&#123; case 1: printf(\"&gt;&gt;&gt;请输入元素位置：\"); scanf(\"%d\",&amp;pos); if(LocatePos_L(L,pos,p))&#123; k = PriorPos_L(L,p); if(k == L.head) printf(\"&gt;&gt;&gt;第1个元素无直接前驱!\\n\"); else printf(\"&gt;&gt;&gt;第%d个元素的前驱为：%d\\n\",pos,k-&gt;date); &#125;else printf(\"&gt;&gt;&gt;输入元素位置错误!\\n\"); break; case 2: printf(\"&gt;&gt;&gt;请输入元素的值：\"); scanf(\"%d\",&amp;e); p = LocateElem_L(L,e); if(p != NULL)&#123; k = PriorPos_L(L,p); if(k == L.head) printf(\"&gt;&gt;&gt;元素%d为第1个元素无直接前驱!\\n\",e); else printf(\"&gt;&gt;&gt;元素%d的前驱为：%d\\n\",e,k-&gt;date); &#125;else printf(\"&gt;&gt;&gt;输入元素不在单链表L中!\\n\"); break; &#125; break; case 8: printf(\"&gt;&gt;首指针指向：%d 尾指针指向：%d 链表长度为：%d\",L.head-&gt;next-&gt;date,L.tail-&gt;date,L.len); break; &#125; &#125; &#125;int main() &#123; text(); return 0;&#125; StatcList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include&lt;stdio.h&gt;#define MAXSIZE 100#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef int ElemType;typedef struct&#123; ElemType data; int cur;&#125;component,SLinkList[MAXSIZE];//求链表长度int Length_SL(SLinkList S)&#123; int j = 0; int i = S[MAXSIZE-1].cur; while(i)&#123; j++; i = S[i].cur; &#125; return j; &#125; //动态分配函数int malloc_SL(SLinkList S)&#123; int i = S[0].cur; if(i == 0)&#123; printf(\"备用链表为空，无法分配！\"); return ERROR; &#125; S[0].cur = S[i].cur; return i; &#125;//freeStatus Free(SLinkList S, int k)&#123; //将位置为k的空闲结点释放 //即插入到备用链表第一个结点前 S[k].cur = S[0].cur; S[0].cur = k; return OK;&#125;//初始化Status InitList_SL(SLinkList S)&#123; int i; S[MAXSIZE-1].cur = 0; //链表头结点为空 for(i = 0 ;i &lt; MAXSIZE - 2 ; i++) S[i].cur = i+1; //备用链表 S[MAXSIZE-2].cur = 0; //链表最后一个元素为空 return OK;&#125; //销毁Status DestoryList_SL(SLinkList S)&#123; int i = S[MAXSIZE-1].cur; S[MAXSIZE-1].cur=0; //头结点指向空 int k = S[0].cur; //k记录备用链表第一个结点 S[0].cur = i; //S[0].cur 指向链表第一个元素 int j; while(i)&#123; //找到S最后一个结点 赋值给j j = i; i = S[i].cur; &#125; S[j].cur = k; //链接两个链表 return OK; &#125; //判空Status ListEmpty_SL(SLinkList S)&#123; if(S[MAXSIZE-1].cur == 0) return TRUE; else return FALSE; &#125; //取元素Status GetElem_SL(SLinkList S,int i,ElemType &amp;e)&#123; int j=1, k = S[MAXSIZE-1].cur; if (i&lt;1 || i &gt; Length_SL(S))&#123; //判断位置是否合理 printf(\"查找位置不合理！\"); return ERROR; &#125; while (k &amp;&amp; j&lt;i)&#123; //找到第i个位置 ++j; k = S[k].cur; &#125; e = S[k].data; return OK;&#125; //查找元素int LocateElem_SL(SLinkList S,ElemType e)&#123; int i = S[MAXSIZE-1].cur; int j = 0; while(i)&#123; j++; if(S[i].data == e) return j; else i = S[i].cur; &#125; if(!i)&#123; printf(\"查无此元素！\"); return ERROR; &#125; &#125; //找前驱 Status PriorElem_SL(SLinkList S, ElemType e, ElemType &amp;cur_e) &#123; int i = S[MAXSIZE-1].cur; int j ; while (j)&#123; j = S[i].cur; if (j &amp;&amp; S[j].data == e)&#123; cur_e = S[i].data; return OK; &#125; i = j; &#125; return ERROR; &#125; //找后继 Status NextElem_SL(SLinkList S, ElemType e, ElemType &amp;nex_e) &#123; int i = S[MAXSIZE-1].cur; int j; while (i)&#123; j = S[i].cur; if (j &amp;&amp; S[i].data == e)&#123; nex_e = S[j].data; return OK; &#125; i = j; &#125; return ERROR; &#125;//前插入Status Ins_SL(SLinkList S,int i,ElemType e)&#123; int s; int j = 1; int k = S[MAXSIZE-1].cur; if(i &lt; 1 || i &gt; Length_SL(S)+1)&#123; printf(\"插入位置不合理\"); return ERROR; &#125; while( k &amp;&amp; j &lt;i-1 )&#123; j++; k = S[k].cur; &#125; s = malloc_SL(S); S[s].data = e; S[s].cur = S[k].cur; S[k].cur = s; return OK; &#125; //删除 Status ListDelete(SLinkList S, int i, ElemType &amp;e) &#123; int k = S[MAXSIZE-1].cur; int j = 1, m; if (i&lt;1 || i&gt;Length_SL(S))&#123; //判断位置是否合理 printf(\"删除位置不合理！\"); return ERROR; &#125; while (k &amp;&amp; j&lt;i-1)&#123; //找到第i-1个位置 ++j; k = S[k].cur; &#125; m = S[k].cur; //m指向第i个位置 e = S[m].data; S[k].cur = S[m].cur; Free(S, m); //将空闲结点m释放到备用链表中 return OK; &#125;void TravelList(SLinkList S)&#123; int j = 0; int i = S[MAXSIZE-1].cur; while (i)&#123; j++; printf(\"第%d个结点为：%d\\n\", j, S[i].data); i = S[i].cur; &#125;&#125;int main()&#123; SLinkList S; ElemType e,cur_e,nex_e; int pos; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]}]}