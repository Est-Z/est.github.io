{"meta":{"title":"Est","subtitle":null,"description":"一个专注划水的博客","author":"Est","url":"https://Est-C.coding.me/Est-C.coding.me"},"pages":[],"posts":[{"title":"程序人生-Hello’s P2P","slug":"程序人生-Hello’s-P2P","date":"2018-12-30T06:44:21.000Z","updated":"2018-12-30T07:35:33.860Z","comments":true,"path":"2018/12/30/程序人生-Hello’s-P2P/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/","excerpt":"哈尔滨工业大学计算机系统大作业，作者：1170300629 时志敏","text":"哈尔滨工业大学计算机系统大作业，作者：1170300629 时志敏 摘 要hello.c是我们每个程序员的初恋。但是它究竟是怎么过完它的一生的，你是否知道？恐怕很难说得清楚吧。本文对从hello.c的诞生，历经预处理、编译、汇编、链接生成可执行文件，再到shell解析命令、fork为其创建进程、execve为其加载、内核为其处理异常、存储管理为其读取数据、IO管理为其显示结果，最后被shell回收完美谢幕的整个过程每一步都进行了详细的说明分析，将整个hello的时候活灵活现地展示于大家面前。 关键词：预处理、编译、汇编、链接、存储管理、IO设备、进程管理、异常处理 第1章 概述1.1 Hello简介首先我们利用一个IDE编写生成了hello.c，这样hello就诞生了，但现在只是我们知道要让它做什么，硬件并不知道，我们要将它转换成可执行程序。hello.c要经过预处理、编译、汇编、链接这样几个看起来很简洁其实很繁复的过程为一个可执行文件hello，这样hello就从一个program变成了process，完成了P2P的过程。之后我们在shell中输入对应的执行指令，shell调用fork为其创建进程，调用execve为其加载，hello拥有了自己的进程，然后存储管理系统为它读取数据、IO设备为它实现外部交互、内核为其处理种种异常，hello有条不紊的完成了它的所有指令，最后被shell结束，默默走完了它的一生，不留下一丝踪影，只有CS知道它来过。这就是hello从无到无的O2O过程。 1.2 环境与工具硬件环境：AMD FX-7500 Radeon R7,10 Computer Cores 4G+6G软件环境：Ubuntu16.04.1 LTS开发与调试工具：gedit，gcc，as，ld，edb，readelf 1.3 中间结果文件名内容 |:—-:|:——-:||hello.i|hello.c经过预处理之后生成的文件||hello.s|hello.i经过编译之后生成的汇编代码文件||hello.o|hello.s经过汇编之后生成的可重定位文件||hello|hello.o经过链接之后生成的可执行文件||hello.elf|hello.o的ELF格式||helloout.elf|hello的ELF格式||helloout.asm|hello反汇编生成的代码||hello.asm|hello.o反汇编生成的代码| 1.4 本章小结介绍一些基本的东西，接下来我们就要解剖hello运行的整个过程了。 第2章 预处理2.1 预处理的概念与作用2.1.1概念顾名思义，预处理就是在程序编译之前的处理。主要有三方面的内容，包括：宏定义、文件包含、条件编译。宏定义：将#define标识的变量和函数进行替换。文件包含：将#include标识的头文件调用出来。头文件通常用.h作为扩展名。对头文件也要预处理，也就是说头文件的宏定义、文件包含、条件编译也要就行处理，这样层层嵌套不断扩大。所以我们预处理得到的文件大小可能是源文件大小的数倍。条件编译：通过一些特定符号（例如：#ifdef、#else、#endif）来处理条件分支语句，使其部分程序段在条件满足时再编译。 2.1.2作用预处理其作为源文件进入编译环节之前的重要操作，最主要的作用无疑就是方便编译器更好的执行编译功能。 2.2在Ubuntu下预处理的命令命令：cpp hello.c &gt; hello.i 图2-1 hello.c的预处理指令执行 2.3 Hello的预处理结果解析图2-2 hello.i文件中的main函数这便是我用gedit打开的hello.i文件，也就是预处理之后的文件。一番寻找之后我在文件的最后找到了我们源文件编写的hello.c。可以看到没什么太大的变化，但是#include标识的头文件引用不见了，#define标识的宏常量也不见了。之前我们在2.1部分已经较为详细的介绍了预处理具体要做什么，主要是三件事：宏定义处理、文件包含处理、条件编译处理。对应到这个hello.i可以发现，原来有的三个头文件stdio.h、unistd.h、stdlib.h被扩展成了三千多行的一大坨。里面的#define定义也都不见了，还出现了许多#ifdef、#else、#endif等来分割程序块，帮助进行条件编译。 2.4 本章小结编译器为了让程序员可以更加方便地编写代码，做了很多妥协，自己承受了很多委屈。而预处理就是委屈的一些体现，在这里编译器做一些必要的还原工作，为下一步大刀阔斧的处理备好了材料。 第3章 编译3.1 编译的概念与作用3.1.1概念此处的编译主要是指狭义的编译，即编译器将hello.i转换成hello.s的过程。这个过程主要有五个步骤： （1）词法分析：词法分析的任务是对由字符组成的单词进行处理，从左至右逐个字符地对源程序进行扫描，产生一个个的单词符号，把作为字符串的源程序改造成为单词符号串的中间程序。执行词法分析的程序称为词法分析程序或扫描器。（2）语法分析：编译程序的语法分析器以单词符号作为输入，分析单词符号串是否形成符合语法规则的语法单位，如表达式、赋值、循环等，最后看是否构成一个符合要求的程序，按该语言使用的语法规则分析检查每条语句是否有正确的逻辑结构，程序是最终的一个语法单位。编译程序的语法规则可用上下文无关文法来刻画。（3）生成中间代码：中间代码是源程序的一种内部表示，或称中间语言。中间代码的作用是可使编译程序的结构在逻辑上更为简单明确，特别是可使目标代码的优化比较容易实现中间代码，即为中间语言程序，中间语言的复杂性介于源程序语言和机器语言之间。中间语言有多种形式，常见的有逆波兰记号、四元式、三元式和树。（4）代码优化：代码优化是指对程序进行多种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。所谓等价，是指不改变程序的运行结果。所谓有效，主要指目标代码运行时间较短，以及占用的存储空间较小。这种变换称为优化。GCC编译器可以提供不同等级的优化。（5）生成目标代码：目标代码生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。 3.1.2作用编译这阶段产生的.s文件也就是汇编代码，是高级语言转换成机器语言的一个缓冲。 3.2 在Ubuntu下编译的命令命令：gcc -S hello.i -o hello.s 图3-1 hello.i文件编译指令执行 图3-2 hello.i执行生成文件展示 3.3 Hello的编译结果解析3.3.1汇编指令图3-3 hello.s文件中一些汇编指令展示 指令 含义 .file 源文件 .globl 全局变量 .data 数据段 .type 数据类型 .size 数据大小 .long 长整数类型 .string 字符串类型 .align 对齐 .section .rodata 只读数据 .text 代码段 3.3.2数据（1）string型在hello.s代码中共有两个字符串类型，均在.rodata只读数据节。 图3-4 字符串数据展示第一个字符串是“Usage：Hello 学号 姓名！\\n”，此字符串在代码中作为printf函数的输出参数，根据图3-4可以发现字符串被编码成UTF-8格式，一个汉字在UTF-8编码中占三个字节。第二个字符串是“Hello %s %s\\n”，此此字符串在代码中也是作为printf函数的输出参数。 （2）int型在hello.s中出现的int型变量总共有3个，全局变量sleepsecs、循环计数变量i和作为mian函数参数的变量argc。 图3-5 hello.s数据段展示第一个int型变量sleepsecs被声明为全局变量，并且是已经初始化的全局变量，所以被存储在.data段。在data段中表明了其大小为4个字节，类型为对象，数据类型为long，并且值为2（此处我也不太明白为什么int型被声明为long）。第二个和第三个int型变量为局部变量，所以并不能在.data段找到。它们在程序需要的时候声明，存放于寄存器或者栈里面，程序运行结束也就消亡了，但我们仍然可以在.text段发现他们的一丝踪迹（见图3-6）。 图3-6 局部变量i在hello.s中展示（3）数组类型程序中用到的数组只有一个：char *argv[]。这个数据也是局部变量，所以我们在.data段也找不到。同样的，它是存在于运行时栈和寄存器中的，而且也是昙花一现，我们只能在.text段中看出一点踪影。 图3-7 指针型数组argv在hello.s中展示（4）其他程序中还有一些立即数，是直接被当做立即数编辑在hello.s中的。 3.3.3赋值程序中的赋值操作共有两处：第一处为 int sleepsecs = 2.5。这段赋值在代码段没有出现，因为sleepsecs是全局变量，并且声明即赋值，所以赋值隐式的表现在.data段（前面已经详细说过，可见3.3.2）。第二处为i = 0。因为i是局部变量，所以我们在.text段能看到赋值过程。（这个前面也详细说过了，可以见图3-6）。 3.3.4类型转换程序中的类型转换只有一处：int sleepsecs = 2.5。此处为隐式类型转换。sleepsecs本身被声明为int类型，但是赋值的时候却用了一个浮点数2.5。而浮点数默认是double型，明显类型不匹配。所以此处发生了隐式类型转换，将double转换成了int型，采用的是去尾法，所以sleepsecs的实际值为2。 3.3.5算数操作在hello.c中出现的算术操作有一处，就是循环变量i的自增运算。在汇编代码中的体现是：addl $1,-4(%rbp)。其中%rbp-4是存放i的地址，-4（%rbp）就是i，然后add是加法操作，其指令模式是：add src A，dst B。作用是把A和B相加，得到的值存在B中。因为i是int型 的，所以用l作为后缀，表明是四字节加法。$1是立即数，表示十进制的1。那么整句代码的意思就是，把i+1的值再放到i里面，也就实现了i的自增运算。 3.3.6关系操作在hello.c中出现的关系操作有两处：（1）argc!=3。在汇编代码中的体现是cmpl $3, -20(%rbp)。cmp执行的是比较运算。指令格式为：cmp src A, dst B。作用效果是执行一个B-A的减法运算，将标志位更新，然后其他语句根据标志位来判断A和B的大小关系(比如其下一句为je .L2，就是根据其设置的标志位来判断A和B的大小关系，如果相等就跳转至.L2)。然后同样的l的后缀表示的四字节的运算。总的来说cmp运算就是一个不赋值的减法，纯粹为了更新标志位。根据上面的讲述我们可以得出这句代码的意思为：将存放在%rbp-20地址中的数与3相减，设置标志位，然后结合下一句就是如果两者相等，就跳转执行.L2处的代码。（2）i&lt;10。在汇编代码中的体现是cmpl $9, -4(%rbp)。cmp上面已经解释过了，此处就直接解释这句代码的意思。将存放在%rbp-4中的数与9进行相减运算，更新标志位。下一句为jle .L4。就是如果-4（%rbp）&lt;=9,就跳转.L4的代码（此处.L4处的代码即为循环体的代码，符合hello.c所描述的程序行为）。 3.3.7数组存取在hello.c中出现了一个字符指针型数组，即char *argv[]。这个数组是作为main函数的参数存在的，是一个局部变量，所以我们只能在栈帧里面找到它。在这里我们给出main函数的部分栈帧结构： |:——————–:||调用main函数的返回地址||%rbp（栈帧顶部）(%rbp-0)||(%rbp-8)||(%rbp-16)||argc(%rbp-20)||(%rbp-24)||argv(%rbp-32)| (%rbp-32)处存放的就是字符指针型数组的首地址，通过首地址+0、+8、+16就可以一次访问到它的元素argv[0]、argv[1]、argv[2]。根据地址访问我们就能实际操作数组里面的数据了。具体汇编代码可见图3-7。 3.3.8控制转移汇编代码实现控制转移主要通过jx指令，下面列出了jx的相关操作： JX指令 效果 jmp label 无条件跳转 jmp *Operand 无条件间接跳转 je label 相等时跳转 jne label 不相等时跳转 js label 结果为负数时跳转 jns label 结果为非负数时跳转 jg label 大于时跳转（有符号数） jge label 大于等于时跳转（有符号数） jl label 小于时跳转（有符号数） jle label 小于等于时跳转（有符号数） ja label 大于时跳转（无符号数） jb label 小于时跳转（无符号数） 通常JX指令要结合cmp指令（设置标志位）或者test指令来实现控制转移。程序中的控制转移共有两处：第一个是单分支的if条件语句，转换为goto风格即为t = test-exprif(!t) goto nextif-statement在图3-8中我们可以看到它是如何根据跳转指令实现控制转移的，模式与上面所写的goto模式完全相同。 图3-8 if分支语句的控制实现分析第二处是for循环语句，for循环的goto风格为：loop: body-statement update-expr; t = test-expr; if(t) goto loop; else-statement 基本模式就是先执行循环体，然后循环变量自增，之后判断循环边界，如果满足就回跳，不满足就顺序向下跳出循环。具体实现可以看图3-9。 图3-9 for循环语句控制实现分析 3.3.9函数操作函数操作主要表现在各个函数之间的调用，一个函数要调用另一个函数通常要实现两个块内容：数据传送和控制转移。函数调用的大致过程如下：首先是调用时要将参数（如果有参数的话）通过寄存器和栈准备好，然后通过call指令将控制转移给被调用函数。被调用函数执行完所有操作后要给调用函数已反馈。这个时候可分为数据传送和控制转移两部分。函数返回值默认放在%rax中，控制权通过ret指令返回给调用函数，至此一个函数的调用过程才完整结束。接下来详细说明一下数据传送的细节，说说函数是怎么传参的。在64位系统中，共有六个寄存器用来存放参数，分别是%rdi、%rsi、%rdx、%rcx、%r8、%r9，分别对应于第1-6个参数。当函数参数大于七个的时候将被存放在栈中，由最后一个参数到第七个参数一次入栈。它们在栈中通过栈帧指针（可选）或者栈指针被调用。详细的栈帧结构看图3-10。 图3-10 栈帧结构程序中设计的函数调用有以下几处：（1）系统函数调用main函数数据传送：第一个参数int argc被存放在%edi中，第二个参数char *argv[]被存放在%rsi中。控制转移：hello.s代码中并没有实际体现，但是其确实是被系统函数call了的。数据返回：将$0 存放在%eax中作为返回值。控制返回：①通过ret；②通过call exit。（2）main函数调用puts函数数据传送：将字符串.LC0（首地址之类的信息）存放在%edi中作为第一个参数，也是唯一一个参数。控制转移：call puts数据返回：无控制返回：通过ret（3）main函数调用exit函数数据传送：将$1送至%edi中作为唯一一个参数。控制转移：call exit。数据返回：无。控制返回：exit是系统退出函数，不会再将控制流返回。（4）main函数调用printf函数数据传送：将第三个参数argv[2]传送至%rdx，将第二个参数argv[1]传送至%rsi，将第一个参数字符串.LC1（首地址）传送至%edi。控制转移：call printf。数据返回：无。控制返回：通过ret。（5）main函数调用sleep函数数据传送：将参数sleepsecs传送至%edi作为唯一一个参数。控制转移：call sleep。数据返回：无。控制返回：通过ret。（6）main函数调用getchar函数数据传送：无。控制转移：call getchar。数据返回：该代码中main函数并未接收被调用函数的返回值。控制返回：通过ret。 3.4 本章小结编译过程中，不管你原来是什么高级语言，通通要经过一场大手术，将你改造得面目全非（只有汇编程序员才能懂）。不为其他目的，就是为了能让机器更好地看清楚你想干什么，高级语言太高级，机器看不懂。虽然汇编也不是机器语言，当相较来说它离机器更进一步了。 第4章 汇编4.1 汇编的概念与作用4.1.1概念汇编就是汇编器（as）通过解析各种汇编指令，将汇编代码（.s文件）转换成可重定位的机器语言（.o文件）。 4.1.2作用将汇编代码转换成机器代码，p2p过程重要一环。 4.2 在Ubuntu下汇编的命令指令：as hello.s -o hello.o 图4-1 对hello.s汇编 4.3 可重定位目标elf格式使用指令readelf -a hello.o &gt; hello.elf获得hello.o的ELF格式。典型的ELF文件具有如下表所示的格式。文件开始是ELF头，表明了一些基本信息，最后是节头部表，表明了不同节的位置和大小。夹在ELF头和节头部表之间的都是节。 4.3.1ELF头ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小（64字节）、目标文件的类型（可重定位）、机器类型（x86-64）、节部头表的文件偏移（1112字节）、以及节头部表中条目的大小（64字节）和数量（13）。 图4-2 hello.o的ELF格式的ELF头 4.3.2节头部表节头部表如图4-3所示，表示了每个节的基本信息，包括名称、类型、地址、偏移量、大小、全体大小、权限等。就像一个目录一样，对链接器起着指引作用。 图4-3 hello.o的ELF格式的节头部表 4.3.3部分节展示（1）.rela.text节这是一个重定位节，具体内容如图4-4所示。里面包含的是代码段的重定位条目。当链接器把这个目标文件与其他文件组合时需要修改这些位置。这8个条目分别对应.LC0（第一个字符串）、puts函数、exit函数、.LC1（第二个字符串）、printf函数、全局变量sleepsecs、sleep函数、getchar函数。包含了hello.c中所有的外部函数和全局变量。 图4-4 hello.o的ELF格式的.rela.text节 （2）.symtab节（符号表） 这个节是一个符号表，具体内容如图4-5所示。它存放了程序中定义和引用的函数和全局变量的信息。其中value是距定义该目标的节的起始位置的偏移。size是该目标的大小（以字节为单位）。type表明目标类型，通常就OBJECT（数据）和FUNC（函数）两种。bind表明目标是本地的还是全局的。 图4-5 hello.o的ELF格式的.symtab节 4.4 Hello.o的结果解析通过指令objdump -d -r hello.o &gt; hello.asm 得到反汇编代码如图4-6，其与hello.s中的汇编代码（图4-7）进行对比后，得到以下几点不同：（1）在原汇编代码中的代码块标记（如.L3）在反汇编代码中都没有了，取而代之的是间接寻址。这也不难理解，翻译成机器语言后这个汇编代码中帮助识别的部分也就不见了，展现的是机器能识别的地址。（2）函数调用时，原汇编代码用的是函数名称，而反汇编代码用的直接是函数地址。这个原因和上面的差不多，汇编代码还要让人看，而机器语言就是为了让机器看的，所以这点差别也是理应存在的。（3）在反汇编代码中全局变量的访问也是通过代码，而原汇编代码是通过符号标识。（4）在反汇编代码中同步出现了机器码。总的来说，两者大体还是相同的。造成不同的原因也很显然，一个是被机器“嚼”过一遍的，一个是没被机器“嚼”过一遍的，自然“味道”就有些不同了。 图4-6 反汇编代码部分展示 图4-7 原汇编代码部分展示 4.5 本章小结本阶段相当于是继承了上一阶段，“手术”进行到底的结果。经过编译和汇编的联合大手术，机器也算是能读懂我们想要做什么了。但是信息尚是支离破碎，需要链接器的进一步组织，机器才能准确把握我们程序员的意图。 第5章 链接5.1 链接的概念与作用5.1.1概念链接是将各种代码和数据片段收集起来并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接由链接器自动执行。 5.1.2作用将源程序所调用的所有外部函数组织起来，通过符号解析和重定位把可重定位文件转换成可执行文件，完成高级语言向机器语言转换的最后一步。 5.2 在Ubuntu下链接的命令通过链接命令ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o获得hello可执行文件，如图5-1。 图5-1 hello.o链接产生可执行文件展示 5.3 可执行目标文件hello的格式通过命令readelf -a hello &gt; helloout.elf生成hello的ELF格式文件helloout.elf。可执行文件的ELF格式与可重定位文件的ELF格式大体相同，具体格式如下表。就格式来看我们可以发现相比于可重定位文件的ELF格式，可执行文件的ELF格式多了.init节和一个程序头表、少了重定位节。这样的格式也是为了让该文件可以更好地执行。ELF头程序头表.init.text.rodata.data.bss.symtab.debug.strtab.line节头表 下面是节头表部分，这里有各个节的基本信息，具体情况如图5-2所示。与可重定位ELF格式一样，节头表表明了各个节的名称、类型、地址、偏移量等信息。该文件共有25个节 图5-2 helloELF格式的节头表 图5-3 helloELF格式的程序头表展示 然后是程序头表。程序头表中记录了各个段的信息，具体情况如图5-3。其中offset是目标文件中的便偏移、virtaddr/physaddr为内存地址、align为对齐要求、filesiz为目标文件段大小、memsiz为内存中段大小、flags为运行时访问权限。 5.4 hello的虚拟地址空间通过使用edb加载hello，分别查看被加载的两大部分：数据段和代码段。它们在虚拟地址空间的对应地址为0x0000 0000 0060 0000~0x0000 0000 0060 1000和 0x0000 0000 0040 0000~0x0000 0000 0040 1000。查看dump可以发现每个节开始的地址与图5-2节头表所示地址完全相同，如图5-4所示。 图5-4 使用edb查看几个典型段的虚拟地址 5.5 链接的重定位过程分析通过objdump -d -r hello &gt; helloout.asm指令生成可执行文件的反汇编代码。将其与可重定位生成的反汇编hello.asm代码相比较，我们大致可以看到重定位的过程。当汇编器生成一个可重定位文件时，它并不知道数据和代码最终会被放在内存的什么位置，它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目（如图5-5），告诉链接器在将目标文件合并成可执行文件的时候如何修改这个引用。代码的重定位条目放在.rel.text（可回看图4-4）中，已初始化数据的重定位条目放在.rel.data。重定位条目的格式中重点有四个部分：偏移量（相距被引用节起始偏移量）、类型（主要有R_X86_64_PC32和R_X86_64_32两种）、符号名称（目标所在节）、加数（相较于目标所在节起始位置的引用偏移）。 图5-5 hello.asm中的重定位信息下面我们详细说一下究竟如何根据重定位条目计算引用的地址。重定位条目根据类型分为两种相对引用（R_X86_64_PC32）和绝对引用（R_X86_64_32）。相对引用是根据距离运行时pc的地址进行引用，此时我们通常会将pc的值进行修改，进行控制转移，一般用于函数调用。绝对引用就是计算其绝对地址，不修改pc值，只进行数据访问。 5.5.1相对地址的重定位首先是相对地址（refptr）的计算方法：符号所在节首地址 + 加数 + 符号被引用节首地址 + 偏移量。运行时，碰到相对引用重定位信息时，就将pc的值压入栈中，然后更新pc的值为pc+refptr，就实现了控制转移。 5.5.2绝对地址的重定位相较于基于相对地址的重定位，绝对地址的重定位就简单一些了。通过符号所在节首地址加上偏移量就可以定位到引用符号的地址了。图5-6是helloout.asm中一些重定位结果，其中红框所圈的就是相对地址的重定位，绿框所圈的是绝对地址的重定位。 图5-6 部分重定位结果展示 5.6 hello的执行流程下面列出了hello从开始到结束整个过程中依次调用的函数，以及它们的地址。 函数名|函数地址|:——:|:——-:||ld-2.23.so!_dl_start|0x00007fc7843379b0||ld-2.23.so!_dl_init|0x00007fc784346740||hello!_start|0x00000000004004d0||libc-2.23.so!libc_start_main|0x00007fc783f86740||-libc-2.23.so!cxa_atexit|0x00007fc783fa0280||-libc-2.23.so!libc_csu_init|0x0000000000400580||hello!_init|0x0000000000400430||libc-2.23.so!_setjmp|0x00007fc783f9b250||-libc-2.23.so!_sigsetjmp|0x00007fc783f9b1b0||-libc-2.23.so!sigjmp_save|0x00007fc783f9b210||hello!main|0x0000000000400523||hello!puts@plt|0x0000000000400460||hello!exit@plt|0x00000000004004a0||hello!printf@plt|0x0000000000400470||hello!sleep@plt|0x00000000004004b0||*hello!getchar@plt|0x0000000000400490||-ld-2.23.so!_dl_fixup|0x00007fc7843459f0||–ld-2.23.so!_dl_lookup_symbol_x|0x00007fc7843409d0||libc-2.23.so!_exit|0x00007fc7843515b0| 5.7 Hello的动态链接分析动态链接依赖于位置无关函数PIC。PIC函数的代码可以直接加载无需重定位。动态链接过程主要就是实现PIC的数据引用和PIC的函数调用。PIC数据引用通过一个全局偏移量表（GOT），它位于数据段的开始，如图5-7所示。在GOT中，每个被目标代码所引用的全局数据目标（过程或全局变量）都有一个八字节条目。编译器会为每个条目都生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得他们包含正确的绝对地址。PIC函数调用采用一个延迟绑定的策略，GNU编译器将过程地址的绑定推迟到第一次调用该过程时。延迟绑定是通过两个数据结构之间的交互实现的，这两个数据结构是：GOT和过程链接表（PLT）。如果一个目标模块调用定义在共享库中的任何函数，那么他就有自己的GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分。PLT是一个数组，其中每个条目是16字节代码（如图5-8）。 图5-7 hello在dl_init运行前后的GOT对比通过图5-7中在dl_init运行前后GOT的对比，我们可以看出来动态链接的过程。再结合图5-8我们就能看出函数调用的一些现象。 图5-8 hello的PLT展示 5.8 本章小结链接的过程其实就像是在请帮手，程序要执行的工作太过丰富，大家的功能也比较专一，所以一项工作的完成就需要许多“同伴”来执行。而链接就是组织工作的过程，通过链接却工作虽然分配零碎但是却依然能井然有序的进行。通过预处理、编译、汇编、链接的一系列操作，hello.c摇身一变成为了一个可执行程序，完成了从program到process的完美蜕变，接下来，它终于要投身机器的怀抱，存在于电流与硬件之上了。 第6章 hello进程管理6.1 进程的概念与作用6.1.1概念进程即一个执行中程序的实例。 6.1.2作用进程概念的抽象给我们一种假象，似乎我们的程序是系统当前唯一运行的程序一样。我们的程序像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一存在的对象。 6.2 简述壳Shell-bash的作用与处理流程Shell字面理解就是个“壳”，是操作系统（内核）与用户之间的桥梁，充当命令解释器的作用，将用户输入的命令翻译给系统执行。处理流程如下：（1）读取用户由键盘输入的命令行。（2）分析命令，以命令名作为文件名，并将其它参数改造为系统调用execve( )内部处理所要求的形式。（3）终端进程调用fork( )建立一个子进程。（4）终端进程本身调用wait()来等待子进程完成（如果是后台命令，则不等待）。当子进程运行时调用execve()，子进程根据文件名到目录中查找有关文件，调入内存，执行这个程序。（5）如果命令末尾有&amp;,则终端进程不用执行系统调用wait()，立即发提示符，让用户入下一条命令；否则终端进程会一直等待，当子进程完成工作后，向父进程报告，此时中断进程醒来，作必要的判别工作后，终端发出命令提示符，重复上述处理过程。 6.3 Hello的fork进程创建过程在终端中输入./hello 1170300629 shizhimin，命令输入完成后就都是shell的工作了。首先，shell会解析命令，准备好加载函数execve的各个参数。然后在当前进程下利用fork函数创建一个子进程，这是父进程的一个复制。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，这就意味着，当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程与子进程之间最大的区别在于它们拥有不同的PID。到此为止，hello的进程就创建完毕了。 6.4 Hello的execve过程上面说到hello的进程已经创建好。在创建好的进程下，子进程利用之前准备好的参数调用execve函数。这个函数会删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的堆和栈段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件的内容。最后，execve跳转到_start地址，它最终调用hello的main函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，这时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 6.5 Hello的进程执行自从fork为hello创建新的进程之后，在没有任何异常的情况下，hello都是老老实实的一条一条地执行着它代码段中的指令。当遇到任何异常时候，hello都会陷入内核模式，交由内核处理异常，内核处理完毕后，或许会将控制流返回给hello，或者不会，这依赖于异常的类型。整个异常处理的过程涉及模式切换、上下文切换、信号收发等。下面我们详细介绍一下hello执行sleep时的进程调用情况。 首先hello运行到sleep函数处，sleep是一个系统函数，通过一条称为syscall的陷阱指令来提供的。通过这条指令，sleep显式的请求让进程hello休眠2秒钟。系统调用以后，进入内核模式，内核进行上下文切换，保存当前进程的上下文，恢复某个先前被抢占的进程被保存的上下文，最后将控制传递给这个新恢复的进程。完成上下文切换后，又进入用户模式，执行其他进程。当2秒钟到达后，定时器会产生一个中断信号，当前进程（其他进程）检测到这个信号后，进行异常处理，陷入内核模式，内核模式处理异常，再次进行上下文切换，将控制返回给hello。至此，一个sleep结束，之后的sleep不断重复这样的过程。过程图解见图6-1。 图6-1 hello调用sleep时的进程执行情况 6.6 hello的异常与信号处理在这里我手动模拟了四种情况，下面分别是四种情况的分析。（1）正常结束。如图6-2（a），是正常执行hello程序的结果，当程序执行完成之后，我们通过ps命令可以看到hello的进程已经消失，说明hello确实结束了。（2）键入ctrl-z。如图6-2（b），是在程序输出4条Hello 1170300629 szm之后按下ctrl-z的结果，当按下ctrl-z之后，shell父进程收到SIGSTP信号，信号处理函数的逻辑是打印屏幕回显、将hello进程挂起，通过ps命令我们可以看出hello进程没有被回收，此时它的后台job号是1，调用fg 1将其调到前台，此时shell程序首先打印hello的命令行命令，hello继续运行打印剩下的6条Hello 1170300629 szm，之后输入字串，程序结束。这时我们再输入ps命令可以看到hello进程确实是结束了。（3）键入ctrl-c。如图6-2（c），是在程序输出5条Hello 1170300629 szm之后按下ctrl-c的结果，当按下ctrl-c之后，shell父进程收到SIGINT信号，信号处理函数的逻辑是结束hello，并回收hello进程。通过ps命令可以看到hello的进程已经消失，说明hello已经结束了。（4）中途乱按。如图6-2（d），是在程序运行中途乱按的结果，可以发现，乱按只是将屏幕的输入缓存到stdin，当getchar的时候读出一个’\\n’结尾的字串（作为一次输入），其他字串会当做shell命令行输入。 图6-2（a） hello正常结束 图6-2（b） hello执行过程中键入Ctrl+Z 图6-2（c） hello执行过程中键入Ctrl+C 图6-2（d） hello执行过程中乱按 6.7本章小结这本章中，介绍了hello投身进程洪流之后发生的具体情况。从shell为其fork，为其execve，hello正式成为一个进程，到内核通过各种异常密切关注其运行情况，让它顺利运行，不捅娄子。hello到现在总算是可以出结果了，这一路艰辛不易，恐怕只有它自己和CPU知道吧。 第7章 hello的存储管理7.1 hello的存储器地址空间7.1.1物理地址用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。虽然我们可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。 7.1.3虚拟地址虚拟地址就是依赖于虚拟内存的地址。虚拟内存是对整个内存的抽像描述。它是相对于物理内存来讲的，可以直接理解成“不直实的”，“假的”内存，例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000 - 1那个地址元素。之所以是这样，是因为现代操作系统都提供了一种内存管理的抽像，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。 7.1.4线性地址跟逻辑地址类似，它也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件页式内存的转换前地址。 7.1.2逻辑地址Intel为了兼容，将远古时代的段式内存管理方式保留了下来。逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。 7.2 Intel逻辑地址到线性地址的变换-段式管理一个逻辑地址由两部份组成，段标识符: 段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号，后面3位包含一些硬件细节，如图7-1。 图7-1 段选择符示例索引号可以直接理解成数组下标，它对应的数组就是“段描述符”。段描述符具体地描述了一个段，很多个段描述符，就组了一个数组，叫“段描述符表”。通过段标识符的前13位，我们可以直接在段描述符表中找到一个具体的段描述符，这个描述符就描述了一个段，具体描述了什么内容，我们可以参考图7-2。 图7-2 段描述符结构介绍每个段描述符由8个字节组成，其内容较为复杂，我们这里只关注其Base字段，它描述了一个段的开始位置的线性地址。Intel设计的本意是，一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。那究竟什么时候该用GDT，什么时候该用LDT呢？这是由段选择符中的T1字段表示的，T1=0表示用GDT，T1=1表示用LDT。GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。如图7-3。 图7-3 逻辑地址向线性地址转换示意图现在我们简单讲一下转换步骤。首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]，然后，看段选择符的T1是0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。接着，拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。最后，把Base + offset，就是要转换的线性地址了。 7.3 Hello的线性地址到物理地址的变换-页式管理我们这里首先简单说一下线性地址（虚拟地址）到物理地址的转换原理，之后会在下一节（7.4）详细阐述基于TLB和四级页表的变换。虚拟内存系统将物理内存分割为物理页，虚拟地址的表示范围往往大于物理地址的表示范围，但是它们均以相同大小的页为基础单元。 图7-4 虚拟地址转换物理地址过程具体转换过程如图7-4。两者之间通过页表进行转换。虚拟内存的每一个页都在页表中有对应的条目，如果该虚拟页有对应的物理页，那我们就称它有效，将页表有效为设置为1，如果没有就设置为0。也就是说页表中有效位为1的虚拟页，在内存中一定可以找到它所映射的物理页，并且页表的后几位就存放着物理页的页号。根据页表大小（P=2p字节），我们把虚拟地址和物理地址均划分为两部分，低p位和高位。对应的物理页和虚拟页低p位完全相同。所以我们只要根据虚拟地址找到物理地址的高位就行了，而这个高位地址就存放在页表中，页表中的对应寻找依赖于虚拟地址的高位，如图所示。所以我们这就根据虚拟地址得到了对应的物理地址。 7.4 TLB与四级页表支持下的VA到PA的变换我们以Intel Core i7为例，我们介绍一下TLB和四级页表支持下的虚拟地址转换物理地址，具体流程如图7-5。Intel Core i7满足以下前提：虚拟地址为48位，页大小为212字节；物理地址52位；TLB为16组，每组四个条目；每级页表存放9位VPN；CR3控制寄存器指向第一级页表的起始位置。 图7-5 TLB和四级页表支持下的虚拟地址向物理地址转换具体转换过程为：首先得到虚拟地址，取其高36位为VPN，再将VPN分割为低4位（TLB索引）和高32位（TLB标记），根据TLB索引和TLB标记在TLB中查找，如果找到且标志位为1，即为命中，取出其中的40位PPN，与之前虚拟地址的低12位组成物理地址，转换结束。如果不幸运，TLB中并没有找到，那么我们就得根据36位的VPN在四级页表中分级查找，找到对应的PTE（VPN对应的页表条目），查看其标志位，如果为0，那么就是缺页，需要在磁盘中找到对应页；如果为1，我们可以找到PPN，进而组成物理地址。另外，还要将这个PTE放到TLB当中。 7.5 三级Cache支持下的物理内存访问这里我们着重讨论Cache1的物理访问原理，Cache2和Cache3相同，在最后我们简单介绍一下。 图7-6 物理地址访存展示为了解释方便，在这里我们假设Cache1是64组，每组有8行。物理地址有52位。具体情况如图7-6。首先我们先将52位的物理地址解析为低6位的位偏移、中间6位的组索引、高40位的组标记。然后通过组索引我们找到对应的组，再通过组标记在这个组中查看能不能找到，如果找到并且标志位为 1，那么就是缓存命中，我们可以通过块偏移在这个块中找到对应的物理字节；如果找不到或者标志位为0，那么就是缓存不命中，就要执行驱逐或者替换策略，从Cache2中寻找对应的物理地址来更新缓存。Cache2的命中过程与Cache1基本相似，只不过Cache2比Cache1更大。如果Cache2也找不到，就类推到更大的存储级别中去找。存储级别如图7-7。 图7-7 存储器层次结构 7.6 hello进程fork时的内存映射当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 7.7 hello进程execve时的内存映射execve函数在当前进程中加载并运行包含在可执行文件hello中的程序，用hello程序有效的替代了当前程序。其中，execve进行内存映射的具体步骤为： （1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 （2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域椰丝球请求二进制零的，初始长度为零。图7-8概括了私有区域的不同映射。 （3）映射共享区域。将hello的共享对象映射到用户虚拟地址空间的共享区域内。 图7-8 execve是如何映射用户地址空间的区域的 7.8 缺页故障与缺页中断处理缺页是系统异常的一种，异常的通用处理流程如图7-9，这里我们的缺页异常应该return to I_current。具体过程为：首先程序进行内存访问发生页表不命中的时候，硬件会返回一个缺页信号告诉程序发生了缺页异常。程序接收到这个信号以后，将控制权交由内核处理，内核进行异常处理（具体就是驱逐或者替换，引入有效缓存），异常处理成功后，内核会将控制权重新返回给当前指令，让其在执行一遍。而此时缓存已经发生替换，指令就可以顺利执行了。 图7-9 异常处理示意图 7.9动态存储分配管理当hello程序运行到printf时，会调用malloc获得虚拟内存。malloc就是一个动态内存分配器。动态内存分配器维护着一个进程的虚拟内存区域，称为堆；假设堆是一个请求二进制零的区域，他紧接在未初始化的 数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块(blocks)的集合来维护，每个块要么是已分配的，要么是空闲的。已分配的块显式的保留为供应用程序使用。空闲块可以用来分配。一个已分配的块保持已分配的状态，直到它被释放这种释放要不是应用程序显式的执行，要么是内存分配器自身隐式的执行。根据谁来释放已分配的块，动态分配器分为两种风格，一种是显式动态分配器（需要应用显式释放已分配的内存，比如C代码中的free），一种是隐式动态分配器（分配器自已检测不会被使用的已分配块将其释放）。 7.9.1空闲块的组织方式如何将空闲块组织起来，以便于分配器分配、合并、释放等操作是分配器设计的一个核心问题。这里我们介绍一下隐式空闲链表。空闲块的组织形式依赖于空闲块是如何定义的，所以我们先从空闲块的结构看起。通过图7-10的堆块结构我们就可以构造出如图7-11的隐式空闲链表。通过每个块头部的块大小和标志位，我们就可以通过遍历堆中所有的块寻找合适的空闲块进行分配。为了方便合并，我们可以在当前块模式中加入一个脚部，它是头部的复制，如图7-12。这样我们就可以获得双向的隐式空闲链表，如图7-13。 图7-10 一个简单的堆块的格式 图7-11 隐式空闲链表 图7-12 带边界标记的块模式 图7-13 双向隐式空闲链表 7.9.2分配空闲块分配空闲块主要有三种策略：首次适配、下一次适配和最佳适配。首次适配从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配和首次适配很相似，只不过不是从链表的起始处开始每次搜索，而是从上一次查询结束的地方开始。最佳适配检查每个空闲块，选择适合所需请求大小的最小空闲块。 7.9.3分割空闲块当分配器找到一个匹配的空闲块，它会选择给程序分配整个空闲块还是只分配其中一部分。假如只分配一部分的话就会将空闲块分割。 7.9.4获得额外的堆内存如果分配器不能为请求块找到合适的空闲块并且最大程度地合并也不行的话，分配器就会通过sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化为一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。 7.9.5合并相邻的空闲块当一个已分配的额内存块被释放时，可能有其他空闲块与这个新释放的空闲块相邻。那么我们就要将其合并成为更大的空闲块，以满足以后较大的块请求。这里讲一下带边界标记的合并。相较于图7-10的块模式，我们无法快速合并当前块和前一块。所以我们改进其模式为图7-12的块模式，这个模式中我们加入了脚部，它是头部的复制。因为前一块的脚部与当前块的头部相邻，所以我们就可以访问到前一块了。 7.10本章小结在本章中，我们详细讨论了一下hello是如何存在的。包括它的主体在哪里，怎么被读，怎么被写。还有后来进程过程中，如何被内核所“指导”、“监督”、“辅助”。内核在竭尽所能的满足hello的一切需要，可以说是“既当爹又当妈”。 第8章 hello的IO管理8.1 Linux的IO设备管理方法设备的模型化：所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为Unix I/O。 8.2 简述Unix IO接口及其函数8.2.1Unix I/O接口统一操作（1）打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。（2）Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。（3）改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。（4）读写文件：一个读操作就是从文件复制n&gt;0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k&gt;=m时，触发EOF。类似一个写操作就是从内存中复制n&gt;0个字节到一个文件，从当前文件位置k开始，然后更新k。（5）关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。 8.2.2 Unix I/O函数int open(char filename,int flags,mode_t mode) ，进程通过调用open函数来打开一个存在的文件或是创建一个新文件的。open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。int close(fd)，fd是需要关闭的文件的描述符，close返回操作结果。ssize_t read(int fd,void buf,size_t n)，read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF，否则返回值表示的是实际传送的字节数量。ssize_t wirte(int fd,const void *buf,size_t n)，write函数从内存位置buf复制至多n个字节到描述符为fd的当前文件。 8.3 printf的实现分析我们首先查看一下printf的代码 ：123456789int printf(const char *fmt,…)&#123; int i； char buf[265]; va_list arg = (va_list)((char*)(&amp;fmt)+4); i = vsprintf(buf,fmt,arg); write(buf,i); return i;&#125; 首先我们来看这一句va_list arg = (va_list)((char)(&amp;fmt) + 4)；va_list的定义： typedef char va_list ，这说明它是一个字符指针。其中的： (char*)(&amp;fmt) + 4) 表示的是…中的第一个参数。下面我们来看看下一句：i = vsprintf(buf, fmt, arg); 让我们来看看vsprintf(buf, fmt, arg)是什么函数。1234567891011121314151617181920212223242526int vsprintf(char *buf, const char *fmt, va_list args) &#123; char* p; char tmp[256]; va_list p_next_arg = args; for (p=buf;*fmt;fmt++) &#123; if (*fmt != '%') &#123; *p++ = *fmt; continue; &#125; fmt++; switch (*fmt) &#123; case 'x': itoa(tmp, *((int*)p_next_arg)); strcpy(p, tmp); p_next_arg += 4; p += strlen(tmp); break; case 's': break; default: break; &#125; &#125; return (p - buf); &#125; 我们先不看它的具体内容。我们继续分析printf，它接受一个格式化的命令，并把指定的匹配的参数格式化输出。通过看vsprintf我们可以发现，它返回要打印出来的字符串的长度。接下来是write(buf, i);的实现就有点复杂了，我们先看看write。12345 write: mov eax, _NR_writemov ebx, [esp + 4]mov ecx, [esp + 8] int INT_VECTOR_SYS_CALL 这里是给几个寄存器传递了几个参数，然后一个int结束。这里的int INT_VECTOR_SYS_CALL 是通过系统来调用sys_call这个函数。1234567891011sys_call: call save push dword [p_proc_ready] sti push ecx push ebx call [sys_call_table + eax * 4] add esp, 4 * 3 mov [esi + EAXREG - P_STACKBASE], eax cli ret sys_call将字符串中的字节“Hello 1170300629 szm”从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。于是我们的打印字符串“Hello 1170300629 szm”就显示在了屏幕上。 8.4 getchar的实现分析异步异常-键盘中断的处理：用户按键之后，键盘接口会得到按键扫描码，同时产生一个中断信号，之后当前程序陷入内核模式，处理该中断。具体就是接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。然后程序继续执行到getchar之后，getchar调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结本章我们看了一看hello是如何与用户进行交互的。熟悉了Linux的IO设备管理方法、Unix IO接口及其函数，分析了printf函数和getchar函数。 结论hello，它悄悄地来了，然后悄悄地走了，挥一挥衣袖，不留下一丝痕迹。但它的点滴，CS都一一记录了下来： 1. 编写hello.c。程序员通过IDE编写构造出hello的最初形态； 2. 预处理hello.c。预处理器将hello.c中调用的外部代码块合并到源代码中形成hello.i。 3. 编译hello.i。编译器把hello.i编译成hello.s。 4. 汇编hello.s。汇编器as将hello.s汇编成为可从定位文件hello.o。 5. 链接hello.o。链接器ld将hello.o和其调用的外部函数通过符号解析和重定位生成可执行文件hello。 6. 运行hello。在shell中输入./1170300629 szm执行hello。 7. 创建进程。shell通过fork函数为hello创建新的进程。 8. 加载hello。shell解析命令./1170300629 szm后，将其作为参数调用execve加载hello。 9. 执行hello。hello在自己的进程中逐条执行它的指令，内核关注其执行状态，随时处理异常情况。 10. 访问内存。内存管理系统将代码中的段地址转换为虚拟地址，再通过TLB和四级页表将虚拟地址转换为物理地址，再根据物理地址通过三级缓存找到对应数据。 11. 申请动态内存。动态内存分配器为hello分配动态内存。 12. 结束程序。CPU执行完hello的最后一条指令后，shell父进程回收hello进程。 附件文件名内容hello.ihello.c经过预处理之后生成的文件hello.shello.i经过编译之后生成的汇编代码文件hello.ohello.s经过汇编之后生成的可重定位文件hellohello.o经过链接之后生成的可执行文件hello.elfhello.o的ELF格式helloout.elfhello的ELF格式helloout.asmhello反汇编生成的代码hello.asmhello.o反汇编生成的代码 参考文献 [1] Randal E.Bryant, David R.O’Hallaron著,龚奕利，贺莲译.深入理解计算机系统（第3版）[M].北京：机械工业出版社，2016.7（2018.4重印）[2] printf函数的深入剖析：https://www.cnblogs.com/pianist/p/3315801.html[3] 逻辑地址、物理地址、虚拟地址、线性地址：https://www.cnblogs.com/zengkefu/p/5452792.html","categories":[],"tags":[]},{"title":"BiTree","slug":"BiTree","date":"2018-11-27T15:34:21.000Z","updated":"2018-11-27T15:56:22.232Z","comments":true,"path":"2018/11/27/BiTree/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/11/27/BiTree/","excerpt":"This is a blog to show BiTree and BiThrTree.","text":"This is a blog to show BiTree and BiThrTree. TreeBiTree1234567891011121314151617181920typedef int Status;typedef char TElemType;typedef struct BiTNode&#123; TElemType data; struct BiTNode *lchild,*rchild; struct BiTNode *parent;&#125;BiTNode,*BiTree;//输出 Status PrintTElemType(TElemType e)&#123; printf(\"%c\",e); return OK;&#125;Status CreateBiTree(BiTree &amp;T); //先序序列构建二叉树Status PreOrderTraverse(BiTree T); //先序遍历Status InOrderTraverse(BiTree T); //中序遍历Status PostOrderTraverse(BiTree T); //后序遍历Status LevelOrderTraverse(BiTree T); //层序遍历 CreateBiTree先序序列构建二叉树12345678910111213141516171819202122Status CreateBiTree(BiTree &amp;T,BiTNode *par)&#123; char ch; scanf(\"%c\",&amp;ch); if(ch==' ') T = NULL; else&#123; if(!(T = (BiTNode*)malloc(sizeof(BiTNode)))) return OVERFLOW; T-&gt;data = ch; //设置数据域 T-&gt;parent = par; //父节点指向 par = T; //记录根结点为父节点 CreateBiTree(T-&gt;lchild,par); //设置左子树 CreateBiTree(T-&gt;rchild,par); //设置右子树 &#125; return OK;&#125; PreOrderTraverse先序遍历123456789Status PreOrderTraverse(BiTree T)&#123; if(T)&#123; PrintTElemType(T-&gt;data); //输出 PreOrderTraverse(T-&gt;lchild); //先序左子树 PreOrderTraverse(T-&gt;rchild); //先序右子树 &#125; return OK;&#125;//递归方法 InOrderTraverse中序遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879typedef BiTNode* SElemType; typedef struct StackNode&#123; SElemType data; //数据域 struct StackNode *next; //结构体指针 &#125;StackNode , *LinkStackPtr;typedef struct LinkStack&#123; //栈指针 LinkStackPtr top; //top指针 int count; //栈元素个数 &#125;LinkStack;Status InitStack(LinkStack &amp;S)&#123; S.top = (LinkStackPtr)malloc(sizeof(StackNode)); //申请空间 S.count = 0; if(!S.top) //是否申请成功 return ERROR; S.top-&gt;next = NULL; //头结点指向NULL (栈底) return OK;&#125;Status StackEmpty(LinkStack &amp;S)&#123; return S.count == 0 ? TRUE : FALSE;&#125; //判空Status Push(LinkStack &amp;S , SElemType e)&#123; LinkStackPtr p = (LinkStackPtr)malloc(sizeof(StackNode)); //申请新节点 p -&gt; data = e; p -&gt; next = S.top; //结点赋值 S.top = p; S.count++; //更改链表关系 return OK;&#125;//入栈Status Pop(LinkStack &amp;S,SElemType &amp;e)&#123; if(StackEmpty(S)) return ERROR; LinkStackPtr p = S.top; //p指向栈顶 e = p-&gt;data; S.top = S.top -&gt; next; S.count--; //更新链表关系 free(p); return OK;&#125; //出栈Status InOrderTraverse(BiTree T)&#123; LinkStack S; InitStack(S); //初始化栈 while( T || !StackEmpty(S) )&#123; if(T)&#123; Push(S,T); //当前不为NULL，则自己入栈 T = T-&gt;lchild; //T指向左子树 &#125;else&#123; Pop(S,T); //为NULL 出栈 PrintTElemType(T-&gt;data); //输出 T = T-&gt;rchild; //T指向右子树 &#125; &#125; return OK;&#125;//非递归方法 12345678910Status InOrderTraverse2(BiTree T)&#123; if(T)&#123; InOrderTraverse2(T-&gt;lchild); PrintTElemType(T-&gt;data); InOrderTraverse2(T-&gt;rchild); &#125; return OK; &#125;//递归方法 PostOrderTraverse后序遍历1234567891011Status PostOrderTraverse(BiTree T)&#123; if(T)&#123; PostOrderTraverse(T-&gt;lchild); PostOrderTraverse(T-&gt;rchild); PrintTElemType(T-&gt;data); &#125; return OK;&#125;//递归 LevelOrderTraverse层序遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788typedef BiTree QElemType;typedef struct QNode&#123; //队列结点 QElemType data; struct QNode *next; &#125;QNode, *QueuePtr;typedef struct&#123; //队列指针 QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 &#125;LinkQueue;Status InitQueue(LinkQueue &amp;Q)&#123; Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); //申请结点 if(!Q.front) //是否申请成功 return ERROR; Q.front -&gt; next = NULL; return OK;&#125;//初始化Status QueueEmpty(LinkQueue &amp;Q)&#123; if(Q.front == Q.rear) return TRUE; else return FALSE;&#125;//判空Status EnQueue(LinkQueue &amp;Q,QElemType e)&#123; QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); if(!p) return ERROR; p -&gt; next = NULL; p -&gt; data = e; Q.rear -&gt; next = p; Q.rear = p; return OK;&#125;//入队Status DeQueue(LinkQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) return ERROR; QueuePtr p = Q.front -&gt; next; e = p -&gt; data; Q.front -&gt; next = p -&gt; next; if(Q.rear == p) Q.rear = Q.front; free(p); return OK;&#125;//出队 Status LevelOrderTraverse(BiTree T)&#123; LinkQueue Q; InitQueue(Q); BiTree p = T; EnQueue(Q,p); PrintTElemType(p-&gt;data); while(!QueueEmpty(Q))&#123; DeQueue(Q,p); if(p-&gt;lchild)&#123; PrintTElemType(p-&gt;lchild-&gt;data); EnQueue(Q,p-&gt;lchild); &#125; if(p-&gt;rchild)&#123; PrintTElemType(p-&gt;rchild-&gt;data); EnQueue(Q,p-&gt;rchild); &#125; &#125; return OK;&#125; main1234567891011121314151617181920212223int main()&#123; BiTree T; TElemType e; CreateBiTree(T,NULL); printf(\"先序遍历：\"); PreOrderTraverse(T); printf(\"\\n\"); printf(\"中序遍历：\"); InOrderTraverse(T); printf(\"\\n\"); printf(\"中序遍历：\"); InOrderTraverse2(T); printf(\"\\n\"); printf(\"后序遍历：\"); PostOrderTraverse(T); printf(\"\\n\"); printf(\"先序遍历：\"); LevelOrderTraverse(T); return 0; &#125; BiThrTree中序线索二叉树 123456789101112131415typedef int Status;typedef int TElemType; typedef enum PointerTag&#123; Link, Thread &#125;PointerTag;typedef struct BiThrNode&#123; TElemType data; struct BiThrNode *lchild,*rchild; PointerTag LTag,RTag;&#125;BiThrNode,*BiThrTree;Status visit(TElemType e)&#123; printf(\"%c\",e); return OK;&#125;//输出 CreateBiTree先序序列构建二叉树123456789101112131415161718192021Status CreateBiTree(BiThrTree &amp;T)&#123; char ch; scanf(\"%c\",&amp;ch); if(ch==' ') T = NULL; else&#123; if(!(T = (BiThrNode*)malloc(sizeof(BiThrNode)))) return OVERFLOW; T-&gt;data = ch; //设置数据域 T-&gt;LTag = Link; T-&gt;RTag = Link; CreateBiTree(T-&gt;lchild); //设置左子树 CreateBiTree(T-&gt;rchild); //设置右子树 &#125; return OK;&#125; InOrderThreading中序遍历二叉树，使其线索化（Thrt是头结点）123456789101112131415161718192021222324252627282930313233343536373839404142BiThrTree pre;void InTreading(BiThrTree p)&#123; if(p)&#123; InTreading(p-&gt;lchild); if(!p-&gt;lchild)&#123; p-&gt;LTag = Thread; p-&gt;lchild = pre; &#125; if(!pre-&gt;rchild)&#123; pre-&gt;RTag = Thread; pre-&gt;rchild = p; &#125; pre = p; InTreading(p-&gt;rchild); &#125;&#125;Status InOrderThreading(BiThrTree &amp;Thrt,BiThrTree T)&#123; if(!(Thrt = (BiThrTree)malloc(sizeof(BiThrNode)))) return OVERFLOW; Thrt-&gt;LTag = Link; Thrt-&gt;RTag = Thread; Thrt-&gt;rchild = Thrt; if(!T) Thrt-&gt;lchild = Thrt; else&#123; Thrt-&gt;lchild = T; pre = Thrt; InTreading(T); //线索化 pre-&gt;rchild = Thrt; pre-&gt;RTag = Thread; Thrt-&gt;rchild = pre; &#125; return OK;&#125; InOrderTraverse_Thr线索二叉树中序遍历1234567891011121314151617181920Status InOrderTraverse_Thr(BiThrTree Thrt)&#123; BiThrTree p = Thrt-&gt;lchild; while(p!=Thrt)&#123; while(p-&gt;LTag==Link) //找第一个元素 p = p-&gt;lchild; visit(p-&gt;data); while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=Thrt)&#123; p = p-&gt;rchild; visit(p-&gt;data); &#125; p = p-&gt;rchild; &#125; return OK;&#125; main12345678910int main()&#123; BiThrTree T,Thrt; CreateBiTree(T); InOrderThreading(Thrt,T); InOrderTraverse_Thr(Thrt); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"SparseMatrix","slug":"SparseMatrix","date":"2018-11-01T13:52:25.000Z","updated":"2018-11-01T13:59:36.731Z","comments":true,"path":"2018/11/01/SparseMatrix/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/11/01/SparseMatrix/","excerpt":"This is a blog to show SparseMatrix.","text":"This is a blog to show SparseMatrix. SparseMatrix稀疏矩阵 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define ERROR 0#define OK 1#define TRUE 1#define FALSE 0#define MAXSIZE 12500 //非零元最大值typedef int ElemType;typedef int Status; typedef struct&#123; int i,j; //该非零元的横下标与列下标 ElemType e; //非零元 &#125;Tirple;typedef struct&#123; Tirple data[MAXSIZE+1]; //三元表 data[0]未用 int mu,nu,tu; //矩阵行数 列数 非零元个数 &#125;TSMatrix; //操作Status CreatSMatrix(TSMatrix &amp;M); //创建稀疏矩阵Status DestorySMatrix(TSMatrix &amp;M); //销毁稀疏矩阵void PrintSMatrix(TSMatrix M); //输出稀疏矩阵Status CopySMatrix(TSMatrix M,TSMatrix &amp;T); //由稀疏矩阵M赋值得到T Status AddSMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q); //Q=M+NStatus SubtMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q); //Q=M-NStatus MultSMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q); //Q=M*NStatus TransposeSMatrix(TSMatrix M,TSMatrix &amp;T); //由M转置得T CreatSMatrix1234567891011121314151617181920212223242526272829//创建稀疏矩阵Status CreatSMatrix(TSMatrix &amp;M)&#123; int i,flag,m,n; ElemType e; printf(\"请输入矩阵的行数，列数，非零元个数:\"); scanf(\"%d %d %d\",&amp;M.mu,&amp;M.nu,&amp;M.tu); M.data[0].i = 0; //data[0]未用 for( i = 1 ; i &lt;= M.tu ;i++)&#123; do&#123; printf(\"请输入非零元素的行、列、值：\\n\"); scanf(\"%d %d %d\",&amp;m,&amp;n,&amp;e); flag = 0; if( m &lt; 1 || m &gt; M.mu || n &lt; 1 || n &gt; M.nu) //输入行列不合法 flag = 1; if( m &lt; M.data[i-1].i || m == M.data[i-1].i &amp;&amp; n &lt;= M.data[i-1].j ) //行列合法但顺序不对 flag = 1; &#125;while(flag == 1); //输入行列值没问题 存入三元表 M.data[i].i = m; M.data[i].j = n; M.data[i].e = e; &#125; &#125; DestorySMatrix123456//销毁稀疏矩阵Status DestorySMatrix(TSMatrix &amp;M)&#123; M.mu = 0; M.nu = 0; M.tu = 0;&#125; PrintSMatrix1234567891011//输出稀疏矩阵void PrintSMatrix(TSMatrix M)&#123; int i; printf(\"\\n%d行 %d列 %d个非零元素\",M.mu,M.nu,M.tu); printf(\"\\n==================\\n\"); printf(\" i j e\\n\"); for( i = 1 ; i &lt;= M.tu ; i++) printf(\"%4d %4d %4d\\n\",M.data[i].i,M.data[i].j,M.data[i].e); printf(\"\\n==================\\n\"); &#125; CopySMatrix12345//由稀疏矩阵M赋值得到T Status CopySMatrix(TSMatrix M,TSMatrix &amp;T)&#123; T = M;&#125; AddSMatrix1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Q=M+Nint compare(int c1,int c2)&#123; if(c1 == c2) return 0; else if(c1 &lt; c2) return 1; else return -1;&#125; Status AddSMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q)&#123; Tirple *Mp,*Me,*Np,*Ne,*Qh,*Qe; if(M.mu != N.mu || M.nu != N.nu) return ERROR; Mp = &amp;M.data[1]; //Mp指向三元表M的首元素 Np = &amp;N.data[1]; Me = &amp;M.data[M.tu]; //Me指向三元表M的未元素 Ne = &amp;N.data[N.tu]; Qh = Qe = Q.data; while(Mp &lt;= Me &amp;&amp; Np &lt;= Ne)&#123; Qe++; switch(compare(Mp-&gt;i,Np-&gt;i))&#123; case 1: *Qe = *(Mp++); break; case -1: *Qe = *(Np++); break; case 0: switch(compare(Mp-&gt;j,Np-&gt;j))&#123; case 1: *Qe = *(Mp++); break; case -1: *Qe = *(Np++); break; case 0: *Qe = *Mp; Qe-&gt;e += Np-&gt;e; if(!Qe-&gt;e) //之和为0 Qe--; Mp++; Np++; break; &#125; &#125; &#125; if(Mp&gt;Me) //M处理完毕 while(Np&lt;=Ne) *(++Qe) = *(Np++); if(Np&gt;Ne) //N处理完毕 while(Mp&lt;=Me) *(++Qe) = *(Mp++); Q.tu = Qe - Qh; //Q元素个数 Q.mu = M.mu; Q.nu = M.nu; return OK; &#125; SubtMatrix123456789//Q=M-N =&gt;（Q = M + -N） Status SubtMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q)&#123; int i; for( i = 1 ; i &lt;= N.tu ; i++) N.data[i].e *= -1; AddSMatrix(M,N,Q); return OK; &#125; MultSMatrix12345678910111213141516171819202122232425262728293031323334353637383940414243//Q=M*NStatus MultSMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q)&#123; int i,j,k; int q; if( M.nu != N.mu) //M的行不等于N的列 return ERROR; else&#123; Q.data[0].i = 0; //0未用 Q.mu = M.mu; //Q的行等于M的行 Q.nu = N.nu; //Q的列等于N的列 for( k = 1 ;k &lt;= Q.mu*Q.nu ; k++ ) //赋初值 Q.data[k].e = 0; i = 1; k = 1; while( i &lt;= M.tu )&#123; //两个矩阵的非零元未处理完 for( j = 1 ; j &lt;= N.tu ; j++)&#123; //M.j == N.i 则相乘 if( M.data[i].j == N.data[j].i) &#123; Q.data[k].i = M.data[i].i; //行列赋值 Q.data[k].j = N.data[j].j; Q.data[k].e = M.data[i].e*N.data[j].e; //相乘的结果 for( q = 1 ; q &lt;k ; q++ ) //在已存三元表里查找行列相同的元素 相加 if( Q.data[k].i == Q.data[q].i &amp;&amp; Q.data[k].j == Q.data[q].j)&#123; Q.data[q].e += Q.data[k].e; k--; //k退回 &#125; k++; &#125; &#125; i++; &#125; Q.tu = --k; //非零元个数 &#125; &#125; TransposeSMatrix1234567891011121314151617181920//由M转置得TStatus TransposeSMatrix(TSMatrix M,TSMatrix &amp;T)&#123; T.mu = M.nu; T.nu = M.mu; T.tu = M.tu; int i,j,k; if(T.tu)&#123; k = 1; for( i = 1 ; i &lt;= M.nu ; i++) for( j = 1 ; j &lt;= M.tu ; j++) //整个三元表中依次查找列数等于i的元素 if(M.data[j].j == i)&#123; T.data[k].i = M.data[j].j; T.data[k].j = M.data[j].i; T.data[k].e = M.data[j].e; k++; &#125; &#125; return OK;&#125; main123456789101112131415161718192021222324252627282930int main()&#123; TSMatrix M,N,Q,P,T,Z; CreatSMatrix(M); CreatSMatrix(N); printf(\"&gt;&gt;M N:\"); PrintSMatrix(M); PrintSMatrix(N); AddSMatrix(M,N,Q); SubtMatrix(M,N,P); printf(\"&gt;&gt;M+N:\"); PrintSMatrix(Q); printf(\"&gt;&gt;M-N:\"); PrintSMatrix(P); TransposeSMatrix(M,T); printf(\"&gt;&gt;M转置:\"); PrintSMatrix(T); printf(\"&gt;&gt;M*N:\"); MultSMatrix(M,N,Z); PrintSMatrix(Z); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"排序算法","slug":"排序算法","date":"2018-10-26T14:33:36.000Z","updated":"2018-11-03T02:00:08.817Z","comments":true,"path":"2018/10/26/排序算法/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/26/排序算法/","excerpt":"This is a blog to show Sort.","text":"This is a blog to show Sort. 本文以时间复杂度区分算法，主要分为O(n^)、O(nlogn)、O(n+k)三类复杂度 123本文动图均来自博客：https://www.cnblogs.com/eniac12/p/5329396.html (主要介绍比较排序)https://www.cnblogs.com/onepixel/articles/7674659.html (以非线性时间比较类排序和线性时间非比较类排序区分) 几个重要概念： 1.比较排序与非比较排序123456比较类排序：通过比较来决定元素间的相对次序，所以时间复杂度不能突破O(nlogn)，称为非线性时间比较类排序非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行复杂度为O(n^)-O(nlogn)的算法均为比较类排序，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序,希尔排序等。非比较排序时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。 2.稳定排序算法1对于相同元素 若排序前和和排序后先后位置不会改变 则为稳定排序算法 3.内部排序算法1数据存储在内存上进行排序操作 数据间比较和移动指令一般是相同的 4.原址排序算法1除了全部输入数据所占空间外 只需有限额外空间 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;/* 排序算法 样例数组为 a[10] = &#123;22,36,22,6,26,45,75,13,31,52&#125; 排序后 a[10] =&#123;6 13 22 22 26 31 36 45 52 75&#125;*/ void Swap(int *x, int *y) &#123; *x = *x ^ *y; //异或交换数字 *y = *x ^ *y; *x = *x ^ *y; &#125;&#123; //排序算法&#125;int main()&#123; int a[10] = &#123;22,36,22,6,26,45,75,13,31,52&#125;; int len = sizeof(a)/sizeof(int); //SelectSort(a,len); //InsertSort(a,len); //BubbleSort(a,len); //CockrailSort(a,len); //ShellSort(a,len); //QuickSort(a,0,len-1); //MergeSort(a,0,len-1); //HeapSort(a,len); //CountingSort(a,len); //BucketSort(a,len); RadixSort(a,len); int j = 0 ; for( j = 0; j &lt;len ; j++ ) printf(\"%d \",a[j]); return 0;&#125; O(n^)选择排序选择排序原理十分简单，可以理解为“抓小数”，每一轮遍历都找出一个最小数放在已排序列的末尾，直到排序完毕 1234567891011void SelectSort(ElemType L[],int n)&#123; int i,j,k; //i指向未排序的首元素 k指向最小元素 j遍历未排序数组 for( i=0 ; i&lt;n-1 ; i++)&#123; //若有n个元素 则需遍历n次 for( j=i+1,k=i ; j&lt;n ; j++) //每次找出当前未排序的最小元素 if( L[k] &gt; L[j] ) k = j; if(i != k) Swap(&amp;L[i],&amp;L[k]); //将最小元素放在合适位置 &#125;&#125; 冒泡排序冒泡排序如同它的名字，像水中冒泡一般，每次选择一个最大的数放在未排序序列的末尾冒泡排序与选择排序不同，冒泡排序只要发现元素顺序不对，就交换数字，而选择排序则是记录位置，遍历结束后交换 12345678void BubbleSort(ElemType L[],int n)&#123; int i,j; for(i = 0 ; i &lt; n ; i++) for(j = n-1; j &gt; i ; j--) if(L[j]&lt;L[j-1]) Swap(&amp;L[j],&amp;L[j-1]);&#125; 冒泡排序改进 –鸡尾酒排序 鸡尾酒排序采用“低-&gt;高-&gt;低-&gt;…”的方式排序，略优于冒泡排序 12345678910111213141516171819void CockrailSort(ElemType L[],int n)&#123; int i; int left = 0; int right = n-1; while( left &lt;= right )&#123; for( i=left ; i&lt;right ; i++) if(L[i]&gt;L[i+1]) Swap(&amp;L[i],&amp;L[i+1]); right--; for( i=right ; i&gt;left ; i-- ) if(L[i-1]&gt;L[i]) Swap(&amp;L[i-1],&amp;L[i]); left++; &#125; &#125; 插入排序插入排序就像打扑克牌，将数字分为已排序和未排序两部分，每次从未排序中取一个数字，在已排序数字中从后往前依次寻找合适的插入位置，直到排序完毕 1234567891011121314151617void InsertSort(ElemType L[],int n)&#123; int i,j; ElemType temp; for(i = 1;i &lt; n; i++)&#123; for(j = i-1,temp = L[i]; j&gt;=0;j--)&#123; if(L[j]&gt;temp) L[j+1] = L[j]; else&#123; L[j+1] = temp; break; &#125; &#125; if( j == -1) L[0] = temp; &#125;&#125; O(nlogn)-O(n^)希尔排序希尔排序是根据插入排序改进而来的 将排序序列分成h个间距为h的子序列，对每一个子序列进行排序堆排序 1234567891011121314151617181920void ShellSort(ElemType L[],int n)&#123; int i; int h = 0; while(h &lt;= n) //生成增量 h = 3*h + 1; while(h &gt;=1)&#123; for( i=h ; i&lt;n ; i++)&#123; int j = i-h ; ElemType temp = L[i]; while(j &gt;=0 &amp;&amp; L[j]&gt;temp)&#123; L[j+h] = L[j]; j -= h; &#125; L[j+h] = temp; &#125; h = (h-1)/3; &#125;&#125; O(nlogn)快速排序快速排序采用分治策略 核心是划分(Partition),每次选取一个数作为划分元(Pivot),与其他n-1个数字比较，将小于Pivot的元素移至划分元左边，大于或等于Pivot的元素移至划分元右边，用同样的方法对左右序列排序，至排序完成 1234567891011121314151617181920212223242526272829int Partition(ElemType L[],int frist,int last)&#123; int left = frist; int right = last; ElemType pivot = L[frist]; //每次选择第一个元素为基准 while(left&lt;right)&#123; while((right&gt;left)&amp;&amp;(L[right]&gt;=pivot)) //right左移 right--; if(left&lt;right) L[left++] = L[right]; while((left&lt;right)&amp;&amp;(L[left]&lt;pivot)) //left右移 left++; if(left&lt;right) L[right--] = L[left]; &#125; L[left] = pivot; return left;&#125;void QuickSort(ElemType L[],int first,int last)&#123; if(first&lt;last)&#123; int split = Partition(L,first,last); QuickSort(L,first,split-1); QuickSort(L,split+1,last); &#125; &#125; 归并排序归并排序也采用分治策略，但做法与快速排序恰恰相反，将一个序列分为两个小序列，分别排序后在合并为一个有序序列 1234567891011121314151617181920212223242526272829303132333435363738void Merge(ElemType S[],int left,int mid,int right)&#123; int len = right - left + 1; ElemType T[len]; int i = left; //前一数组起始元素 int j = mid+1; //后一数组起始元素 int k,index = 0; while( (i&lt;=mid) &amp;&amp; (j&lt;=right)) T[index++] = S[i] &lt;= S[j] ? S[i++] : S[j++]; while(i&lt;=mid) T[index++] = S[i++]; while(j&lt;=right) T[index++] = S[j++]; for(k=0;k&lt;len;k++) S[left++] = T[k]; free(T);&#125;void MergeSort(ElemType L[],int first,int last)&#123; if (first == last) return; int mid = (first+last)/2; MergeSort(L,first,mid); MergeSort(L,mid+1,last); Merge(L,first,mid,last); &#125; //改进void MergeSort2() &#123;&#125; 堆排序堆排序是O(nlogn)阶排序算法，采用二叉树的结构，但却没有用二叉树的指针，只是在数组上实现树的结构 !相较于快速排序： 快速排序很难保证划分平衡，最差时间复杂度为O(n^),且需要O(n)-O(logn)的辅助空间；而堆排序采用二叉 树结构，复杂度为 O(nlogn),且只需要O(1)的辅助空间。 !相较于合并排序： 复杂度相差不大，但合并排序需要较大空间(存储数据和下标) 堆排序过程： 1.建堆：通过比较移动，使每个节点的值大于其左右节点的值(BuildHeap) 2.根元素删除-堆修复：最大元素沉到堆尾(Swap(&amp;L[0],&amp;L[i]))，修复堆(FixHeap) 123456789101112131415161718192021222324252627282930313233343536373839404142void FixHeap(ElemType L[],int Hsize,int root,int k)&#123; //修复 //若root有两个子节点，则为L[2*root],L[2*root+1] int larger; //larger存放要和root结点比较的子节点 if((2*root) &gt; Hsize) //2*root&gt;Hsize 说明L[root]没有子结点 不需要修复 L[root-1] = k; else&#123; if((2*root) == Hsize) //只有一个子节点 larger = 2*root; else if(L[2*root-1] &gt; L[2*root+1-1]) //取左右子节点中较大的一个 larger = 2*root; else larger = 2*root+1; if(k &gt; L[larger-1]) //不交换 L[root-1] = k; else&#123; //交换 继续修复新的父节点 L[root-1] = L[larger-1]; FixHeap(L,Hsize,larger,k); &#125; &#125; &#125; void BuildHeap(ElemType L[],int n)&#123; //建树 int i; for(i = n/2; i&gt;=1 ; i--) //i&gt;n/2时，L[i]是叶节点 不必修复 FixHeap(L,n,i,L[i-1]); &#125; void HeapSort(ElemType L[],int n)&#123; //堆排序 int i; BuildHeap(L,n); for(i = n-1; i&gt;0 ; i--)&#123; //最后一个结点开始 将最大数“沉”下去 Swap(&amp;L[0],&amp;L[i]); //交换根与树尾 FixHeap(L,i,1,L[0]); //修复根 &#125; &#125; O(n+k)计数排序计数排序不是基于比较的排序 基本思想： 将要排序的序列按照一定关系存入额外开辟的数组中(数组下标表示该元素值，该下标对应的值表示该值的元 素个数 eg: counter[75]=1表示有一个值为75的元素) 优点： 可将时间复杂度降低到线性缺点： 输入必须是有确定范围的数(数的范围不能太大) 当O(K)&gt;O(nlogn)时，性能不如比较排序 1234567891011121314151617181920212223242526272829int CountingSort(ElemType L[],int n)&#123; int i; int len = n; ElemType max=L[0],min=L[0]; //查找最大元素 for( i = 0 ; i &lt; n ; i++ )&#123; min = min&lt;L[i]?min:L[i]; max = max&gt;L[i]?max:L[i]; &#125; ElemType *counter = (ElemType*)malloc(sizeof(ElemType)*(max-min+1));//申请所需数组空间 大小为max-min+1 if(!counter)&#123; free(counter); return -1; &#125; for( i = 0 ; i &lt;= max-min ; i++ ) //初始化数组 counter[i] = 0; for( i = 0 ; i &lt; len ; i++ ) //统计数值出现次数 counter[L[i]-min]++; //逆向遍历数组 保持稳定 for( i = max-min ; i &gt;= 0 ; i--) while( counter[i]-- != 0) L[--len] = i + min; free(counter); &#125; 桶排序桶排序是计数排序的升级版 是一种函数映射关系(类哈希的链式结构) !桶划分的越小 各桶之间的数据越少，排序时间越少，但空间消耗越大 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//链表存储数据 typedef struct node&#123; ElemType key; struct node* next;&#125;KeyNode;void BucketSort(ElemType L[],int n)&#123; int i,j=0; //桶初始化 int bucket_size = 10; //桶深为5 KeyNode **bucket_table = (KeyNode**)malloc(bucket_size*sizeof(KeyNode*)); //结构体数组 for( i = 0 ; i &lt;bucket_size ; i++)&#123; //每一个结构体赋初值 key=0 next=NULL bucket_table[i]=(KeyNode*)malloc(sizeof(KeyNode)); bucket_table[i]-&gt;key=0; bucket_table[i]-&gt;next=NULL; &#125; for( i = 0 ; i &lt; n ; i++)&#123; //遍历排序序列 插入合适位置 KeyNode * node = (KeyNode*)malloc(sizeof(KeyNode)); //新建结点存储该数值 node-&gt;key = L[i]; node-&gt;next = NULL; int index = L[i]/10; //分类方式（排序改进核心） KeyNode *p = bucket_table[index]; //p指向要插入的桶中 if(p-&gt;key == 0)&#123; //桶中无元素 直接放入 p-&gt;next = node; p-&gt;key++; &#125; else&#123; //桶中有元素 找到合适位置插入 while(p-&gt;next!=NULL &amp;&amp; p-&gt;next-&gt;key &lt;= node-&gt;key) // '&lt;=' 保证稳定性 p = p-&gt;next; node-&gt;next = p-&gt;next; p-&gt;next = node; (bucket_table[index]-&gt;key)++; //桶元素个数+1 &#125; &#125; KeyNode * k = NULL; for( i = 0 ; i &lt; bucket_size ; i++) for( k = bucket_table[i]-&gt;next; k!=NULL ; k = k-&gt;next ) L[j++] = k-&gt;key; &#125; 基数排序基数排序是将数据先按低位排序，收集，再按高位排序，再收集，依次直至最高未(适合小范围数) 1234567891011121314151617181920212223242526272829303132333435363738394041void RadixSort(ElemType L[],int n)&#123; int i,j; int max,maxDigit=0; //最大值 最大值位数 int dev = 1,mod = 10; //求余取位值 max = L[0]; //找最大数 for( i = 0 ; i &lt; n ; i++ ) max = max&gt;L[i]?max:L[i]; do &#123; //求最大值位数 maxDigit++; max /= 10 ; &#125; while( max&gt;0 ); int *bucket[10]; //指针数组 0-9十个桶 深度为n+1 for(i=0; i&lt;10; i++)&#123; bucket[i] = (int *)malloc(sizeof(int) * (n+1)); bucket[i][0] = 0; //0出存储元素个数 &#125; for( i = 1 ; i &lt;= maxDigit ; i++,dev*=10,mod*=10)&#123; //对每一位数进行排序 for( j = 0 ; j &lt; n ; j++)&#123; int num = L[j] % mod / dev; //取出该位置的值 int index = ++bucket[num][0]; //插入合适位置 bucket[num][index] = L[j]; &#125; int index = 0; for( j = 0 ; j &lt; 10 ; j++)&#123; //取出 int k; for( k = 1 ; k &lt;= bucket[j][0] ; k++) L[index++] = bucket[j][k]; bucket[j][0] = 0; // 复位 &#125; &#125;&#125; O( )猴子排序“猴子排序”的名字出自“无限猴子定理”——让一只猴子在打字机上随机地按键,当按键时间达到无穷时,几乎必然能够打出任何给定的文字,比如莎士比亚的全套著作. 排序思路：随机打乱数组-检查是否排序成功-不成功再次打乱-检查… 123456789101112131415161718192021222324252627void BogoSort(ElemType L[],int n)&#123; int i,j; int flag = 0; while(1)&#123; flag = 1; //判断是否有序 for(i = 0; i &lt; n-1; i++) if(L[i] &gt; L[i+1])&#123; flag = 0; break; &#125; if(flag) break; //随机打乱 for(i = 0; i &lt; n; i++)&#123; while( (j = rand() % n) == i); //若i==j 异或为0 ; Swap( &amp;L[i], &amp;L[j]); &#125; &#125; &#125; continue…","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/算法/"}]},{"title":"Array","slug":"Array","date":"2018-10-24T07:17:02.000Z","updated":"2018-10-31T16:33:02.592Z","comments":true,"path":"2018/10/24/Array/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/24/Array/","excerpt":"This is blog to show Array.","text":"This is blog to show Array. Array12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;stdarg.h&gt; //提供宏va_start、va_arg、va_end #include&lt;stdlib.h&gt; //变长参数列表需要 #define ERROR 0#define OK 1#define TRUE 1#define FALSE 0#define OVERFLOW -1 #define UNDEFLOW -2 #define MAX_ARRAY_DIM 8 //维数最大为8typedef int ElemType; typedef int Status;typedef struct&#123; ElemType * base; //数组元素基址 由InitArray分配 int dim; //维数 int * bounds; //数组维界基址 由InitArray分配 eg:bounds[0]=3,bounds[1]=4,bounds[2]=2,表示3页4行2列的数组 int * constants; //数组映像函数常量基址 由InitArray分配 /* 定位作用 对于3页4行2列的数组,跨越一页8个元素，一行2个元素，一列1个元素 这样给定一个下标A[2][3][1],2*8+2*3+1=23,再根据基地址base就可找到A[2][3][1]的地址 可以看出最后一维肯定是1即constants[dim-1] = 1（跨越最后一维只需要移动一个元素） */ &#125;Array;Status InitArray(Array &amp;A,int dim,...); //若维数dim和各维长度均合法 构造AStatus DestoryArray(Array &amp;A); //销毁数组AStatus Value(Array A,ElemType &amp;e,...); //e返回指定下标的值Status Assign(Array &amp;A,ElemType e,...); //e的值赋给指定位置Status Locate(Array A,va_list ap,int &amp;off); //ap指示的下标合法 则求出该元素在A中相对地址off InitArray 12345678910111213141516171819202122232425262728293031323334353637383940//若维数dim和各维长度均合法 构造AStatus InitArray(Array &amp;A,int dim,...)&#123; int elemtotal = 1; //A的总元素 累加 va_list ap; //ap为存放变长参数表信息的数组 if( dim&lt;1 || dim&gt;MAX_ARRAY_DIM ) //dim是否合法 return ERROR; A.dim = dim; //维度赋值 A.bounds = (int *)malloc(dim * sizeof(int)); //数组维界地址赋值 if(!A.bounds) exit(OVERFLOW); va_start(ap,dim); //从dim开始读取参数 int i; for(i=0;i&lt;dim;i++)&#123; A.bounds[i] = va_arg(ap,int); //逐一将参数赋值给A.bounds[i] if(A.bounds&lt;0) return UNDEFLOW; //下溢出 elemtotal *= A.bounds[i]; //改变元素个数 &#125; va_end(ap); //结束提取变长参数 A.base = (ElemType*)malloc(elemtotal*sizeof(ElemType)); //申请数组需要的空间 if(!A.base) exit(OVERFLOW); A.constants = (int*)malloc(dim*sizeof(int)); if(!A.constants) //动态分配数组偏移量基址 exit(OVERFLOW); A.constants[dim - 1] = 1; //最后一维的偏移量为1 for ( i = dim - 2; i &gt;= 0; i--) A.constants[i] = A.bounds[i + 1] * A.constants[i + 1]; //每一维的偏移量 return OK;&#125; DestoryArray123456789101112131415161718//销毁数组AStatus DestoryArray(Array &amp;A)&#123; //依次释放A.base A.bounds A.constants指针 if(!A.base) return ERROR; free(A.base); A.base = NULL; if(!A.bounds) return ERROR; free(A.bounds); A.bounds = NULL; if(!A.constants) return ERROR; free(A.constants); A.constants = NULL; return OK;&#125; Locate123456789101112131415//ap指示的下标合法 则求出该元素在A中相对地址offStatus Locate(Array A,va_list ap,int &amp;off)&#123; off = 0; int i = 0,ind; for( i=0 ; i&lt;A.dim ; i++)&#123; ind = va_arg(ap,int); if(ind&lt;0 || ind&gt;=A.bounds[i]) //下表越界 return OVERFLOW; off += A.constants[i] * ind; // 每一维下表乘偏移量 &#125; return OK;&#125; Value12345678910111213//e返回指定下标的值Status Value(Array A,ElemType &amp;e,...)&#123; int result,off; va_list ap; //ap为va_list类型 是存放变长参数信息表的数值 va_start(ap,e); if((result = Locate(A,ap,off)&lt;=0)) //下标越界 return result; e = *(A.base + off); //e返回指定值 return OK; &#125; Assign1234567891011121314//e的值赋给指定位置Status Assign(Array &amp;A,ElemType e,...)&#123; int result,off; va_list ap; va_start(ap,e); if((result = Locate(A,ap,off)&lt;=0)) //下标越界 return result; *(A.base + off) = e; return OK;&#125; main123456789101112int main()&#123; Array A; ElemType e; InitArray(A,3,3,4,2);//3维数组，3页4行2列 printf(\"%d %d %d\\n\",A.constants[0],A.constants[1],A.constants[2]); Assign(A,-8,2,3,1); Value(A,e,2,3,1); printf(\"这个元素为%d\",e); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"malloc() and free()","slug":"malloc-and-free","date":"2018-10-23T15:53:43.000Z","updated":"2018-10-24T07:24:38.311Z","comments":true,"path":"2018/10/23/malloc-and-free/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/23/malloc-and-free/","excerpt":"malloc()函数与free()函数","text":"malloc()函数与free()函数 在介绍malloc()与free()之前，我们先看一下alloc()与afree()函数，了解内存地址运算 alloc()/afree()alloc()函数返回一个指向n个连续字符存储单元的指针afree()函数释放已分配的存储空间 这两个函数功能类是malloc()与free()，但它们是“不完善的”，因为alloc()与free()是以栈的方式（后进先出）进行存储空间管理的 alloc()与afree()的实现alloc()是对一个大数组allocbuf中的空间进行分配 allocbuf是alloc()与afree()的私有数组，并且在管理中并不需要数组下表，因此可以申明为static类型，使其不可见，实际使用过程中可用malloc申请一个指向无名存储块的指针获得 allocbuf中使用指针allocp指向下一块可用空间：如果空间够，则alloc()返回allocp的值，不够则返回0 如果p在allocbuf边界之内，则afree(p)仅仅是将allocp的值设置为p 源码1234567891011121314151617#define ALLOCSIZE 10000static char allocbuf[ALLOCSIZE]; static char *allocp = allocbuf;char *alloc(int n)&#123; if(allocbuf + ALLOCSIZE-allocp &gt;=n)&#123; allocp += n; return allocp - n; &#125;else return 0;&#125;void afree(char *p)&#123; if( q &gt;= allocubuf &amp;&amp; p &lt; allocbuf + ALLOCSZIE) alloc = p;&#125; continue……","categories":[],"tags":[{"name":"C源码","slug":"C源码","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/C源码/"}]},{"title":"String","slug":"String","date":"2018-10-21T14:30:41.000Z","updated":"2018-11-05T16:19:58.796Z","comments":true,"path":"2018/10/21/String/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/21/String/","excerpt":"This is a blog to show SString.","text":"This is a blog to show SString. StringSString12345678910111213141516171819#define MAXSTRLEN 255 //用户可在255以内定义最大串长 typedef unsigned char SString[MAXSTRLEN + 1]; //0号单元存放串的长度 typedef int Status;void StrPrint(SString T) ; // 输出字符串TStatus StrAssign(SString &amp;T,char chars[]); //生成一个其值等于chars的串T Status StrCopy(SString &amp;T,SString S); //由串S赋值得串TStatus ClearString(SString &amp;S); //将串置空Status StrDestory(SString &amp;T); //销毁Status StrEmpty(SString S); //判空int StrCompare(SString S,SString T); //S&gt;T 返回&gt;0 S=T 返回0 S&lt;T 返回&lt;0int StrLength(SString S); //返回串长度Status Concat(SString &amp;T,SString S1,SString S2); //连接串 S1S2 未截断返回 1 截断返回 0 Status SubString(SString &amp;Sub,SString S,int pos,int len); //用Sub返回串S的自第pos个字符起长度为len的子串int Index(SString S,SString T,int pos); //返回子串T在主串S中第pos个字符之后的位置 若不存在，则函数值为0Status StrInsert(SString &amp;S,int pos,SString T); //在串S的第pos个字符前插入串T 完全插入返回1 部分插入返回0Status StrDelete(SString S,int pos,int len) ; // 从串S中删除自第pos个字符起长度为len的子串Status Replace(SString &amp;S,SString T,SString V); //用V替换主串S中出现的所有与T相等的不重叠的子串 StrPrint12345678// 输出字符串Tvoid StrPrint(SString T) &#123; int i; for(i=1;i&lt;=T[0];i++) printf(\"%c\",T[i]); printf(\"\\n\"); &#125; StrAssign 12345678910111213141516//生成一个其值等于chars的串T Status StrAssign(SString &amp;T,char chars[])&#123; int i; if(strlen(chars) &gt; MAXSTRLEN)&#123; printf(\"&gt;串长超过最大串长\"); return ERROR; &#125;else&#123; T[0] = strlen(chars); //T[0]存放串长度 for(i=1 ; i&lt;=T[0] ; i ++) T[i] = *(chars+i-1); //逐个赋值 return OK; &#125; &#125; StrCopy 123456789//由串S赋值得串TStatus StrCopy(SString &amp;T,SString S)&#123; int i; for(i=0 ; i&lt;=S[0] ; i++) //赋值(带0一起复制) T[i] = S[i]; return OK; &#125; ClearString123456//将串置空Status ClearString(SString &amp;S)&#123; S[1] = '\\0'; S[0] = 0;&#125; StrDestory123456//销毁Status StrDestory(SString &amp;T)&#123; ClearString(T); return OK;&#125; StrEmpty123456789//判空Status StrEmpty(SString S)&#123; if(S[0] == 0) //0号存储字符串长度 return TRUE; else return FALSE; &#125; StrCompare1234567891011//S&gt;T 返回&gt;0 S=T 返回0 S&lt;T 返回&lt;0int StrCompare(SString S,SString T)&#123; int i; for( i=1 ; i&lt;=S[0]&amp;&amp;i&lt;=T[0] ; i++ ) if(S[i] != T[i]) //不相等 返回ascll码差值 return S[i] - T[i]; return S[0] - T[0]; //包含关系 返回长度差值 &#125; StrLength12345//返回串长度int StrLength(SString S)&#123; return S[0];&#125; Concat 1234567891011121314151617181920212223242526//连接串 S1S2 未截断返回 1 截断返回 0 Status Concat(SString &amp;T,SString S1,SString S2)&#123; int i,j; if( S1[0] + S2[0] &lt;= MAXSTRLEN)&#123; //未截断 T[0] = S1[0] + S2[0]; for( i=1 ; i &lt;= S1[0] ; i++ ) //连接S1 T[i] = S1[i]; for( j=1 ; j &lt;= S2[0] ; j++ ) //连接S2 T[i++] = S2[j]; return OK; &#125;else&#123; //截断 for( i=1 ; i &lt;= S1[0] ; i++ ) //连接S1 T[i] = S1[i]; for( j=1 ; i &lt;= MAXSTRLEN ; j++ ) //连接S2 T[i++] = S2[j]; T[0] = MAXSTRLEN; return FALSE; &#125;&#125; SubString 12345678910111213//用Sub返回串S的自第pos个字符起长度为len的子串Status SubString(SString &amp;Sub,SString S,int pos,int len)&#123; int i; if( pos&lt;1 || pos&gt;S[0] || len&lt;0 || len&gt;S[0]-pos+1) //条件错误 return ERROR; for( i=1 ; i&lt;=len ; i++) //赋值 Sub[i] = S[pos+i-1]; Sub[0] = len; return OK;&#125; Index1234567891011121314151617181920//返回子串T在主串S中第pos个字符之后的位置 若不存在，则函数值为0。 int Index(SString S,SString T,int pos)&#123; //算法改进 --查找字符串 (KMP) int i,n,m; SString sub; if( 1&lt;=pos &amp;&amp; pos&lt;=S[0])&#123; //位置合理 n = S[0]; m = T[0]; i = pos; while( i &lt;= n-m+1 )&#123; SubString(sub,S,i,m); if(StrCompare(sub,T) != 0) i++; else return i; &#125; &#125; return 0;&#125; StrInsert 1234567891011121314151617181920212223//在串S的第pos个字符前插入串T 完全插入返回1 部分插入返回0 Status StrInsert(SString &amp;S,int pos,SString T)&#123; int i; if( pos&lt;1 || pos&gt;S[0]+1 ) //插入位置(1-S[0]+1) return ERROR; if(S[0]+T[0]&lt;=MAXSTRLEN)&#123; //完全插入 for( i=S[0]; i&gt;=pos ;i-- ) S[i+T[0]] = S[i]; //插入点后面的字符串向后位移Strlen(T) for( i=pos; i&lt;pos+T[0] ; i++) S[i] = T[i-pos+1]; S[0] += T[0]; return OK; &#125;else&#123; //部分插入 for( i=MAXSTRLEN;i&gt;=pos+T[0];i--) S[i] = S[i-T[0]]; for( i=pos;i&lt;pos+T[0] &amp;&amp; i&lt;=MAXSTRLEN;i++ ) S[i] = T[i-pos+1]; S[0] = MAXSTRLEN; return FALSE; &#125;&#125; StrDelete 1234567891011// 从串S中删除自第pos个字符起长度为len的子串Status StrDelete(SString S,int pos,int len)&#123; int i; if( pos&lt;1 || pos&gt;S[0]-len+1 || len&lt;0) return ERROR; for( i=pos+len ; i&lt;=S[0];i++) S[i-len] = S[i]; S[0] -= len; return OK;&#125; Replace123456789101112131415161718192021222324//用V替换主串S中出现的所有与T相等的不重叠的子串 Status Replace(SString &amp;S,SString T,SString V)&#123; int i =1; //第一个位置开始查找 Status k; if(StrEmpty(T)) //T为空串 return ERROR; while(i)&#123; i = Index(S,T,i); if(i)&#123; StrDelete(S,i,StrLength(T)); k = StrInsert(S,i,V); if(!k) return ERROR; i += StrLength(V); &#125; &#125; return OK; &#125; Test12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void text()&#123; int i,j; Status k; char s,c[MAXSTRLEN]; SString t,s1,s2,s3,s4,s5,s6,s7; printf(\"请输入串s1: \"); gets(c); k=StrAssign(s1,c); printf(\"串长为%d 串空否？%d(1:是0:否)\\n\",StrLength(s1),StrEmpty(s1)); StrCopy(s3,s1); printf(\"拷贝s1生成的串为\"); StrPrint(s3); printf(\"请输入串s2: \"); gets(c); k=StrAssign(s2,c); StrPrint(s2); Concat(t,s1,s2); printf(\"连接s1s2为t：\"); StrPrint(t); SubString(s4,t,2,4); printf(\"t的字串 2-4 为：\"); StrPrint(s4); StrDelete(t,3,3); printf(\"删除t的字串 3-3后：\"); StrPrint(t); printf(\"请输入插入串: \"); gets(c); k=StrAssign(s5,c); StrInsert(t,3,s5); printf(\"在第三个位置插入后t为：\"); StrPrint(t); printf(\"请输入替换串: \"); gets(c); k=StrAssign(s6,c); printf(\"请输入要替换串: \"); gets(c); k=StrAssign(s7,c); Replace(t,s7,s6); printf(\"替换后t为：\"); StrPrint(t);&#125;int main()&#123; SString T,S; char chars[] = \"this is\"; text(); return 0;&#125; HString1234typedef struct&#123; char * ch; int length;&#125;HString; 123456Status StrAssign(HString &amp;T,char *chars); //生成一个其值等于串常量chars的串Tint StrLength(HString S); //返回S元素个数 即串S的长度int StrCompare(HString S,HString T); //S&gt;T 返回大于0 S&lt;T 返回小于0Status ClearString(HString &amp;S); //将S变为空串 并释放S所占空间Status Concat(HString &amp;T,HString S1,HString S2); //T返回S1与S2连接而成的串Status SubString(HString &amp;Sub,HString S,int pos,int len); //返回串S第pos个元素起长度为len的字串 StrAssign123456789101112131415161718192021//生成一个其值等于串常量chars的串TStatus StrAssign(HString &amp;T,char *chars)&#123; int i,j; char *c; if(T.ch) //释放T原有空间 free(T.ch); for(i=0,c=chars;*c;i++,c++) ; //求chars长度 if(!i)&#123; T.ch = NULL; T.length = 0; &#125; else&#123; if(!(T.ch = (char*)malloc(i*sizeof(char)))) //申请失败 return ERROR; for(j=0 ; j&lt;i ; j++) //复制 T.ch[j] = chars[j]; &#125; return OK;&#125; StrLength1234//返回S元素个数 即串S的长度int StrLength(HString S)&#123; return S.length; &#125; StrCompare123456789//S&gt;T 返回大于0 S&lt;T 返回小于0int StrCompare(HString S,HString T)&#123; int i; for(i=0 ; i&lt;S.length &amp;&amp; i&lt;T.length ; i++) if(S.ch[i] != T.ch[i]) return S.ch[i] - T.ch[i]; return S.length - T.length;&#125; ClearString123456789//将S变为空串 并释放S所占空间Status ClearString(HString &amp;S)&#123; if(S.ch)&#123; free(S.ch); S.ch = NULL; &#125; S.length = 0; return OK;&#125; Concat123456789101112131415161718//T返回S1与S2连接而成的串Status Concat(HString &amp;T,HString S1,HString S2)&#123; int i,j; if(T.ch) free(T.ch); if(!(T.ch = (char*)malloc((S1.length+S2.length)*sizeof(char)))) return ERROR; for( i=0 ; i&lt;S1.length ; i++) T.ch[i] = S1.ch[i]; for( j=0 ; j&lt;S2.length ; j++) T.ch[i++] = S2.ch[j]; T.length = S1.length + S2.length; return OK;&#125; SubString12345678910111213141516171819202122//返回串S第pos个元素起长度为len的字串 Status SubString(HString &amp;Sub,HString S,int pos,int len)&#123; int i; if( pos&lt;1 || pos&gt;S.length || len&lt;0 || len&gt;S.length-pos+1 ) //条件错误 return ERROR; if(Sub.ch) //释放Sub原有空间 free(Sub.ch); if(!len)&#123; //字串长度为0 Sub.ch = NULL; Sub.length = 0; &#125;else&#123; Sub.ch = (char*)malloc(len*sizeof(char)); for( i=0 ; i&lt;len ; i++ ) //复制 Sub.ch[i] = Sub.ch[i+pos-1]; Sub.length = len; &#125;&#125; text1234int main()&#123; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"Queue","slug":"Queue","date":"2018-10-19T14:48:58.000Z","updated":"2018-11-05T16:18:49.541Z","comments":true,"path":"2018/10/19/Queue/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/19/Queue/","excerpt":"This is a blog to show SqQueue and LinkQueue.","text":"This is a blog to show SqQueue and LinkQueue. QueueSqQueue顺序队列有八个操作：初始化、判空、销毁、置空、求长、获取队头、入队、出队 123456789#define QUEUE_INIT_SIZE 100 //栈的大小#define STACKINCREMENT 10 //栈的增量typedef struct&#123; //栈的结构体 QElemType * base; QElemType front; QElemType rear; int queuesize;&#125;SqQueue; 初始化12345678910111213141516//初始化Status InitQueue(SqQueue &amp;Q)&#123; Q.base = (QElemType *)malloc(QUEUE_INIT_SIZE * sizeof(QElemType)); //分配空间 if(!Q.base)&#123; //判断是否申请成功 Q.queuesize = 0; return ERROR; &#125; Q.rear = 0; Q.front = 0; Q.queuesize = QUEUE_INIT_SIZE; return OK;&#125; 判空12345678//判断是否为空队列 Status QueueEmpty(SqQueue &amp;Q)&#123; if(Q.front == Q.rear) return TRUE; else return FALSE;&#125; 销毁123456//销毁Status DestroyQueue(SqQueue &amp;Q)&#123; free(Q.base); return OK; &#125; 置空123456//置为空队列 Status ClearEmpty(SqQueue &amp;Q)&#123; Q.front = Q.rear ; return OK;&#125; 求长12345//求队列的长度int QueueLength(SqQueue &amp;Q)&#123; return (Q.rear-Q.front+Q.queuesize) % Q.queuesize;&#125; 返回队头12345678910//返回队列头元素Status GetTop(SqQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) return ERROR; e = Q.base[Q.front]; return OK;&#125; 入队123456789//对尾插入Status EnQueue(SqQueue &amp;Q,QElemType e)&#123; Q.base[Q.rear] = e; //压栈 Q.rear = (Q.rear + 1) % Q.queuesize; return OK;&#125; 出队123456789101112//队头删除Status DeQueue(SqQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) //判空 return ERROR; e = Q.base[Q.front]; //出栈 Q.front = (Q.front + 1) % Q.queuesize; return OK;&#125; 输出123456789101112//遍历Status QueueTraverse(SqQueue Q)&#123; if(QueueEmpty(Q)) //判空 return ERROR; while(Q.front != Q.rear) printf(\"%d \",Q.base[Q.front++]); //输出 printf(\"\\n\"); return OK;&#125; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//textvoid text()&#123; SqQueue Q; QElemType e; InitQueue(Q); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLength(Q)); //队列插入为1 2 3 4 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); //删除对头 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); if(QueueEmpty(Q)) printf(\"栈空\\n\"); else printf(\"栈不空\\n\"); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLength(Q)); ClearEmpty(Q); //置空 QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLength(Q));&#125;int main()&#123; text(); return 0;&#125; LinkQueue123456789typedef struct QNode&#123; //队列结点 QElemType data; //数据域 struct QNode *next; //指针 &#125;QNode, *QueuePtr;typedef struct&#123; //队列指针 QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 &#125;LinkQueue; 初始化123456789101112//初始化Status InitQueue(LinkQueue &amp;Q)&#123; Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); //申请结点 if(!Q.front) //是否申请成功 return ERROR; Q.front -&gt; next = NULL; return OK;&#125; 销毁12345678910//销毁队列Status DestoryQueue(LinkQueue &amp;Q)&#123; while(Q.front)&#123; Q.rear = Q.front -&gt; next; free(Q.front); Q.front = Q.rear; &#125; &#125; 清空123456//请空队列Status ClearQueue(LinkQueue &amp;Q)&#123; Q.rear = Q.front; Q.front -&gt; next =NULL; return OK;&#125; 判空1234567//判空Status QueueEmpty(LinkQueue &amp;Q)&#123; if(Q.front == Q.rear) return TRUE; else return FALSE;&#125; 求长12345678910111213//求队列元素个数int QueueLenght(LinkQueue &amp;Q)&#123; QueuePtr p = Q.front -&gt; next; int iCount=0; while(p)&#123; iCount++; p = p -&gt; next; &#125; return iCount;&#125; 返回队头12345678910//返回队头Status GetHead(LinkQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) return ERROR; e = Q.front -&gt; next -&gt; data; return OK;&#125; 入队12345678910111213141516//插入元素Status EnQueue(LinkQueue &amp;Q,QElemType e)&#123; QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); if(!p) return ERROR; p -&gt; next = NULL; p -&gt; data = e; Q.rear -&gt; next = p; Q.rear = p; return OK;&#125; 出队1234567891011121314151617//删除元素Status DeQueue(LinkQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) return ERROR; QueuePtr p = Q.front -&gt; next; e = p -&gt; data; Q.front -&gt; next = p -&gt; next; if(Q.rear == p) Q.rear = Q.front; free(p); return OK;&#125; 输出123456789101112//遍历Status QueueTraverse(LinkQueue Q)&#123; Q.front = Q.front -&gt; next; while(Q.front)&#123; printf(\"%d \",Q.front-&gt;data); Q.front = Q.front -&gt; next; &#125; printf(\"\\n\"); return OK;&#125; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//textvoid text()&#123; LinkQueue Q; QElemType e; InitQueue(Q); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLenght(Q)); //队列插入为1 2 3 4 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); //删除对头 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); if(QueueEmpty(Q)) printf(\"栈空\\n\"); else printf(\"栈不空\\n\"); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLenght(Q)); ClearQueue(Q); //置空 QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLenght(Q)); &#125; int main()&#123; text(); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"Stack","slug":"Stack","date":"2018-10-18T16:19:10.000Z","updated":"2018-11-05T16:16:30.372Z","comments":true,"path":"2018/10/19/Stack/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/19/Stack/","excerpt":"This is a blog to show SqStack and LinkStack.","text":"This is a blog to show SqStack and LinkStack. StackSqStack12345678#define STACK_INIT_SIZE 100 //栈的大小#define STACKINCREMENT 10 //栈的增量typedef struct&#123; //栈的结构体 SElemType * base; //栈底指针 SElemType * top; //栈顶指针 int stacksize; //栈大小 &#125;SqStack; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/* 栈的顺序存储结构*///初始化Status InitStack(SqStack &amp;S)&#123; S.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType)); //分配空间 if(!S.base)&#123; //判断是否申请成功 S.stacksize = 0; return ERROR; &#125; S.top = S.base; S.stacksize = STACK_INIT_SIZE; //更新栈 return OK;&#125;//判断是否为空栈Status StackEmpty(SqStack S)&#123; if(S.base == S.top) return TRUE; else return FALSE;&#125;//销毁Status DestroyStack(SqStack &amp;S)&#123; free(S.base); free(S.top); S.base = NULL; S.top = NULL; return OK; &#125;//置为空栈Status ClearEmpyt(SqStack &amp;S)&#123; S.base = S.top; return OK;&#125;//求栈的长度int StackLength(SqStack &amp;S)&#123; return S.top-S.base;&#125;//返回栈顶元素Status GetTop(SqStack S,SElemType &amp;e)&#123; if(S.base==S.top) return ERROR; e = *(S.top-1); return OK;&#125;//栈顶插入Status Push(SqStack &amp;S,SElemType e)&#123; if(S.top - S.base &gt;= S.stacksize)&#123; //栈满 S.base = (SElemType *)realloc(S.base,(S.stacksize+STACKINCREMENT)*sizeof(SElemType)); //申请新空间 if(!S.base)&#123; printf(\"空间申请失败！\"); return ERROR; &#125; S.top = S.base + S.stacksize; //更新栈顶指针 S.stacksize += STACKINCREMENT; //更新长度 &#125; *S.top++ = e; //压栈 return OK;&#125;//栈顶删除Status Pop(SqStack &amp;S,SElemType &amp;e)&#123; if(S.base == S.top) //判空 return ERROR; e = *--S.top; //出栈 return OK;&#125;//遍历Status StackTraverse(SqStack S)&#123; if(StackEmpty) //判空 return ERROR; while(S.base &lt; S.top) printf(\"%c \",*(S.base++)); //输出 printf(\"\\n\"); return OK;&#125;int main()&#123; return 0;&#125; LinkStack123456789typedef struct StackNode&#123; SElemType data; //数据域 struct StackNode *next; //结构体指针 &#125;StackNode , *LinkStackPtr;typedef struct LinkStack&#123; //栈指针 LinkStackPtr top; //top指针 int count; //栈元素个数 &#125;LinkStack; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//初始化Status InitStack(LinkStack &amp;S)&#123; S.top = (LinkStackPtr)malloc(sizeof(StackNode)); //申请空间 S.count = 0; if(!S.top) //是否申请成功 return ERROR; S.top-&gt;next = NULL; //头结点指向NULL (栈底) return OK;&#125;//判空Status StackEmpty(LinkStack &amp;S)&#123; return S.count == 0 ? TRUE : FALSE;&#125; //入栈Status Push(LinkStack &amp;S , SElemType e)&#123; LinkStackPtr p = (LinkStackPtr)malloc(sizeof(StackNode)); //申请新节点 p -&gt; data = e; p -&gt; next = S.top; //结点赋值 S.top = p; S.count++; //更改链表关系 return OK;&#125;//出栈Status Pop(LinkStack &amp;S,SElemType &amp;e)&#123; if(StackEmpty(S))&#123; //是否栈空 printf(\"栈空！！！\"); return ERROR; &#125; LinkStackPtr p = S.top; //p指向栈顶 e = p-&gt;data; S.top = S.top -&gt; next; S.count--; //更新链表关系 free(p); return OK;&#125; //返回栈顶Status GetStack(LinkStack &amp;S,SElemType &amp;e)&#123; if(StackEmpty(S))&#123; printf(\"栈空！！！\"); return ERROR; &#125; e = S.top -&gt; data; return OK;&#125; //获取长度int GetLengthLinkStack(LinkStack &amp;S)&#123; return S.count; &#125; //输出Status Stacktraverse(LinkStack &amp;S)&#123; if(!S.top &amp;&amp; S.count) return ERROR; LinkStackPtr p = S.top; while(p-&gt;next)&#123; printf(\"%d\",p-&gt;data); p = p -&gt; next; &#125; return OK; &#125; //textvoid text()&#123; LinkStack S; SElemType e; LinkStack stack; InitStack(S);//初始化 e=1; Push(S, e); e=2; Push(S, e); e=3; Push(S, e); e=4; Push(S, e); printf(\"链栈元素：\"); Stacktraverse(S); printf(\"链栈元素个数：%d\\n\", GetLengthLinkStack(S)); SElemType e1,e2,e3; Pop(S,e1); printf(\"弹出第一个元素：%d\\n\", e1); Pop(S,e2); printf(\"弹出第二个元素：%d\\n\", e2); Pop(S,e3); printf(\"弹出第二个元素：%d\\n\", e3); printf(\"链栈元素：\"); Stacktraverse(S); printf(\"链栈元素个数：%d\", GetLengthLinkStack(S)); printf(\"\\n\"); GetStack(S,e3); printf(\"$%d\",e3);&#125; int main()&#123; text(); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"List","slug":"List","date":"2018-10-15T14:16:42.000Z","updated":"2018-11-05T16:14:46.644Z","comments":true,"path":"2018/10/15/List/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/15/List/","excerpt":"This is a blog to show SqList LinkStack and StaticStack.","text":"This is a blog to show SqList LinkStack and StaticStack. ListSqList12345678#define LIST_INIT_SIZE 100 //线性表大小 #define INIT_INCREMENT 10 //线性表增量typedef struct&#123; ElemType *elem; int length; int listSize;&#125;SqList; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383//判断元素是否存在 存在返回i的值Status compare(ElemType e1 , ElemType e2)&#123; if( e1 == e2 ) return TRUE; else return FALSE;&#125;//访问每一个元素 Status visit(ElemType e)&#123; printf(\"%d \",e); return OK;&#125;//初始化线性表 Status InitList_Sq(SqList &amp;L)&#123; L.elem = (ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType)); //动态分配空间 L.length = 0; //先令线性表长度为0 即使初始化失败L.length也有明确的值 if(!L.elem)&#123; printf(\"初始化失败\"); return ERROR; //分配失败 返回ERROR &#125; L.listSize = LIST_INIT_SIZE; //线性表d大小 return OK; &#125;//销毁线性表 Status DestoryList_Sq(SqList &amp;L)&#123; free(L.elem); //释放申请来的空间 return OK; &#125; //清空线性表 Status ClearList_Sq(SqList &amp;L)&#123; L.length = 0; //长度变为0 return OK;&#125;//判空表 空返回TRUE 否则FALSE Status ListEmpty_Sq(SqList &amp;L)&#123; return L.length ? TRUE : FALSE ; //长度为0则为空表 &#125; //求线性表长度Status ListLength_Sq(SqList &amp;L)&#123; if(L.length == 0)&#123; printf(\"线性表为空！\"); return ERROR; &#125; return L.length; //返回长度 &#125; //用e返回第i个元素值Status GetElem_Sq(SqList &amp;L,int i,ElemType &amp;e)&#123; if( L.length == 0 || i&lt;1 || i&gt;L.length)&#123; printf(\"输入元素的位置有误\"); return ERROR; &#125; e = L.elem[i-1]; return OK;&#125;//操作结果：返回L中第1个与e满足compare()的数据元素的位序，若这样的数据元素不存在，则返回值为0。Status LocateElem_Sq(SqList &amp;L,ElemType &amp;e)&#123; int i=0; while( i&lt;L.length &amp;&amp; !compare(L.elem[i],e) ) i++; if(compare(L.elem[i],e)) return i; else return 0;&#125;//操作：cur_e是L的元素且不会是第一个 则用pre_e返回他的前驱Status PriorElem_Sq(SqList &amp;L,ElemType cur_e,ElemType &amp;pre_e)&#123; int i = LocateElem_Sq(L,cur_e); //获取cur_e的位置 if(i == 0) printf(\"cur_e不在L中或为首元素\"); else pre_e = L.elem[i-1]; return OK;&#125;//cur_e是L的元素且不会是最后一个 则用next_e返回他的后继Status NextElem_Sq(SqList &amp;L,ElemType cur_e,ElemType &amp;next_e)&#123; int i = LocateElem_Sq(L,cur_e); //获取cur_e的位置 if(i == 0)&#123; printf(\"该元素不在线性表中\"); return ERROR; &#125;else if(i == L.length)&#123; printf(\"该元素为末元素\"); return ERROR; &#125;else next_e = L.elem[i+1]; return OK;&#125;//在L的第i个位置之前插入新元素Status ListInsert_Sq(SqList &amp;L, int i ,ElemType e)&#123; //i的合法值为 1-L.length+1 if(i&lt;1 || i&gt;L.length+1)&#123; printf(\"插入的位置有问题\"); return ERROR; //i值不合法 &#125; //若线性表已满 则分配空间 if(L.length&gt;=L.listSize)&#123; ElemType *newbase = (ElemType*)realloc(L.elem,(L.listSize+INIT_INCREMENT)*sizeof(ElemType)); //增加分配空间 if(!newbase)&#123; printf(\"存储分配失败\"); return ERROR; //是否成功分配 &#125; L.elem = newbase; L.listSize += INIT_INCREMENT; //更改长度 &#125; ElemType *p = &amp;(L.elem[i-1]); //p为插入点指针 ElemType *q = &amp;(L.elem[L.length-1]); //q为最后一个元素指针 while(p&lt;=q)&#123; //插入 *(q+1) = *q; q--; &#125; *p = e; L.length++; return OK;&#125; //删除第i个元素 用e返回 L长度减1Status ListDelete_Sq(SqList &amp;L,int i,ElemType &amp;e)&#123; if(i&gt;L.length || i&lt;1)&#123; //删除元素有误 printf(\"被删除元素位置有误\"); return ERROR; &#125; ElemType *p = &amp;(L.elem[i-1]); //p指向被删除元素 e = *p; ElemType *q = &amp;(L.elem[L.length-1]); //q指向末元素 while(p&lt;q)&#123; //删除 *p = *(p+1); p++; &#125; L.length--; return OK; &#125; //输出线性表 Status ListTraverse_Sq(SqList &amp;L)&#123; if(!L.elem)&#123; printf(\"\\n线性表未初始化或被销毁了!!!\"); return ERROR; &#125; if(L.length==0)&#123; printf(\"线性表中无元素!!!\"); return ERROR; &#125; int i; for( i = 0 ; i &lt;L.length ; i++) visit(L.elem[i]); return OK;&#125;//textvoid initMenu(SqList L) &#123; printf(\"\\n\\t\\t\\*------------------------------------------*\\n\"); printf(\"\\n\\t\\t 初始化成功，L.length=%d\\n\", L.length); printf(\"\\n\\t\\t 1.创建随机链表\\t 2.遍历线性表\\n\\t\\t 3.清空线性表\\t\\t 4.线性表插入\\n\\t\\t 5.查找表中元素\"); printf(\"\\t 6.判断元素是否在表中\\n\\t\\t 7.删除某个元素\\t 8.线性表长度\\n\\t\\t 9.线性表是否为空\\t 10.回到主菜单\\n\\t\\t 0.退出\");&#125;void mainMenu() &#123; printf(\"\\n\\t\\t*------------------------------------------*\\n\"); printf(\"\\n\\t\\t 欢迎回到主菜单\\n\"); printf(\"\\n\\t\\t 1.创建随机链表\\t 2.遍历线性表\\n\\t\\t 3.清空线性表\\t\\t 4.线性表插入\\n\\t\\t 5.查找表中元素\"); printf(\"\\t 6.判断元素是否在表中\\n\\t\\t 7.删除某个元素\\t 8.线性表长度\\n\\t\\t 9.线性表是否为空\\t 10.回到主菜单\\n\\t\\t 0.退出\");&#125;void text()&#123; int lLength, i; ElemType e; SqList L; InitList_Sq(L); initMenu(L); int select; while(1) &#123; printf(\"\\n请选择你的操作：\"); scanf(\"%d\", &amp;select); switch(select) &#123; case 1: InitList_Sq(L); printf(\"创建随机链表：\"); ListTraverse_Sq(L); break; case 2: printf(\"遍历线性表：\"); ListTraverse_Sq(L); break; case 3: ClearList_Sq(L); printf(\"清空L后：L.length = %d\\n\", L.length); ListTraverse_Sq(L); break; case 4: printf(\"请输入要插入的元素位置和元素的值(eg:1 2)：\"); scanf(\"%d %d\", &amp;i, &amp;e); while(ListInsert_Sq(L, i, e)) &#123; printf(\"插入完毕，现在线性表为：\"); ListTraverse_Sq(L); printf(\" 是否继续？ 1.是 0.否 \"); int selectAgain ; scanf(\"%d\", &amp;selectAgain); if(selectAgain==0) break; printf(\"请输入要插入的元素位置和元素的值：\"); scanf(\"%d %d\", &amp;i, &amp;e); &#125; printf(\"\\n\"); break; case 5: printf(\"请输入要查找的元素位置：\"); scanf(\"%d\",&amp;i); if(GetElem_Sq(L, i, e)) printf(\"第%d个元素的值为：%d\\n\", i, e); else printf(\"请输入正确的数字！！！\\n\"); break; case 6: printf(\"请输入你想知道是否在表中的数值：\"); scanf(\"%d\", &amp;e); // 这里假定随机数组中的元素互不重复 i = LocateElem_Sq(L, e); if(i) printf(\"值为%d是表中的第%d个元素\\n\", e, i); else printf(\"没有值为%d的元素\\n\", e); break; case 7: printf(\"请输入要删除的元素位置：\"); scanf(\"%d\", &amp;i); if(ListDelete_Sq(L, i, e))&#123; printf(\"元素%d删除完毕，现在线性表为：\\n\", e); ListTraverse_Sq(L); &#125;else printf(\"\\n\"); break; case 8: lLength = ListLength_Sq(L); printf(\"线性表的长度为: %d \\n\", lLength); break; case 9: if (!ListEmpty_Sq(L)) printf(\"该线性表为空.\\n\"); else printf(\"该线性表非空.\\n\"); break; case 10: mainMenu(); break; case 0: break; default: printf(\"请输入正确的数字!!!\\n\"); break; &#125; &#125; &#125; int main() &#123; text(); return 0;&#125; LinkList1234567891011121314151617181920/* 自定义结点类型指针 结点包括数据项date和指向（struct LNode）的指针 Link Position为指向结点的指针类型 */typedef struct LNode&#123; ElemType date; struct LNode *next;&#125;*Link , *Position; /* 自定义指针结构指针 head tail是Link类型指针 用来指向结点 len存储链表长度 */ typedef struct List&#123; Link head,tail; //分别指向头尾 int len = 0; //长度 &#125;LinkList; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603/*//初始化一个空的线性链表L Status InitList_L(LinkList &amp;L)&#123; L.head = (Link)malloc(sizeof(struct LNode)); if(!L.head)&#123; printf(\"分配空间失败\"); return ERROR; &#125; L.head-&gt;next = NULL; return OK;&#125;*///分配p指向e的结点Status MakeNode_L(Link p,ElemType e)&#123; p = (Link)malloc(sizeof(struct LNode)); if(p != NULL)&#123; p -&gt; date = e; p -&gt; next = NULL; return OK; &#125; return ERROR;&#125; //释放p指向的结点Status FreeNode_L(Link &amp;p)&#123; free(p); p = NULL; return OK;&#125; //创建指定长度单链表Status CreateList_L(LinkList &amp;L,int n)&#123; L.head = L.tail = (Link)malloc(sizeof(struct LNode)); L.head -&gt; next = NULL; //建立一个带头节点的单链表 if(!L.head)&#123; printf(\"&gt;&gt;初始化失败！\"); return ERROR; &#125; Link q = L.head ; //p指向头节点 printf(\"&gt;&gt;输入链表的值：\"); while(n--)&#123; Link p = (Link)malloc(sizeof(struct LNode)); //申请一个新结点 scanf(\"%d\",&amp;p-&gt;date); //输入数据 q -&gt; next = p; //插入到表尾 q = p; L.len++ ; //长度+1 &#125; L.tail = q; L.tail-&gt;next = NULL; printf(\"&gt;&gt;初始化成功！\\n\"); return OK; &#125; //销毁线性表LStatus DestroyList_L(LinkList &amp;L)&#123; Link p; while(L.head != L.tail)&#123; //头结点开始 依次释放结点 p = L.head; L.head = L.head -&gt; next; FreeNode_L(p); &#125; L.head = NULL; L.tail = NULL; //防止野指针 L.len = 0; return OK; &#125;//清空线性表Status ClearList_L(LinkList &amp;L)&#123; if(L.len == 0) return OK; Link p,q; p = L.head -&gt; next; while(p)&#123; q = p -&gt; next; FreeNode_L(p); p = q; L.len--; &#125; L.head -&gt; next = L.tail; printf(\"&gt;&gt;清空成功!\\n\"); return OK;&#125;//在链表的第一个位置插入节点，h指向头结点Status InsFirst_L(Link h,Link s)&#123; s-&gt;next = h-&gt;next; h-&gt;next = s; return OK;&#125;//在删除链表中第一个节点并以p返回，h为头结点指针Status DelFirst_L(Link h,Link p)&#123; p = h-&gt;next; h-&gt;next = h-&gt;next-&gt;next; return OK;&#125;//将s所指的一串结点连接在线性表L的最后一个结点Status Append_L(LinkList &amp;L,Link s)&#123; if(L.head)&#123; L.tail -&gt; next = s; Link temp = L.head; while(temp -&gt; next) temp = temp -&gt; next; L.tail = temp; //L.tail指向最后一个结点temp-&gt;next==NULL return OK; &#125; return ERROR;&#125; //第i个元素存在时，将第i个元素赋值个e并返回OK 否则返回ERROR Status GetELem_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(i&lt;1) &#123; //输入值有误 printf(\"&gt;&gt;输入值有误!\"); return ERROR; &#125; int j; Link p = L.head -&gt; next; while( j &lt; i &amp;&amp; p)&#123; //j&lt;i且p不为空 找到第i个元素 p = p -&gt; next; j++; &#125; if( !p || j&gt;i )&#123; printf(\"第%d个元素不存在\",i); return ERROR; &#125; e = p -&gt; date; //e返回第i个元素的值 return OK; &#125; //在第i个元素之前插入元素eStatus InsBefore_L(LinkList &amp;L,int i,ElemType e) &#123; Link s; Link p = L.head; int j = 0; while( p &amp;&amp; j &lt; i-1)&#123; //找到第i-1个元素 并将p指向 p = p-&gt; next; j++; &#125; if( !p || j &gt; i-1 ) &#123; //输入值有误 printf(\"&gt;&gt;输入插入点有误！\"); return ERROR; &#125; s = (Link)malloc(sizeof(struct LNode)); //插入 s -&gt; date = e; s -&gt; next = p -&gt; next; p -&gt; next = s; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //更新长度 return OK; &#125;//向线性表末尾添加一个元素Status InsertRear_L(LinkList &amp;L, ElemType e)&#123; Link p = L.tail; //p指向表尾 Link q = (Link)malloc(sizeof(struct LNode)); //新建结点 q -&gt; date = e; q -&gt; next = p -&gt; next; //插入 p -&gt; next = q; p = p -&gt; next; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //长度+1 return OK;&#125; //向有序链表插入一个元素 使之依然有序Status InsertOrder_L(LinkList &amp;L,ElemType e)&#123; Link p = L.head -&gt; next; //p指向第一个结点 Link q = L.head; //q指向p的上一个结点 if( (p-&gt;date) &gt; (p-&gt;next-&gt;date) )&#123; //判断有序还是逆序 while(p &amp;&amp; p-&gt;date &gt; e)&#123; q = p; p = p-&gt;next; &#125; &#125;else&#123; while( p &amp;&amp; p-&gt;date &lt; e)&#123; q = p; p = p-&gt;next; &#125; &#125; //此时p指向插入点 q指向插入点的上一个结点 Link z = (Link)malloc(sizeof(struct LNode)); //新建结点 z -&gt; date = e; z -&gt; next = q -&gt; next; q -&gt; next = z; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //长度+1 return OK;&#125; //删除第i个元素 并用e返回其值Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(i &gt; L.len)&#123; printf(\"&gt;&gt;删除位置有误!\\n\"); return ERROR; &#125; int j = 0; Link q; Link p = L.head; while( p &amp;&amp; j &lt; i-1 )&#123; //寻找第i个节点 并使p指向其前驱 p = p -&gt; next; j++; &#125; if( !(p -&gt; next) &amp;&amp; j &gt; i-1)&#123; //结点位置错误 printf(\"&gt;&gt;删除位置有误!\"); return ERROR; &#125; q = p -&gt; next; //删除 p -&gt; next = q -&gt;next; e = q -&gt;date; free(q); printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK; &#125; //删除表尾元素Status DeleteRear_L(LinkList &amp;L,ElemType &amp;e)&#123; Link p = L.head ; while( (p-&gt;next) != L.tail) //p指向尾元素的前驱 p = p -&gt; next; e = L.tail -&gt; date; p -&gt; next = NULL; FreeNode_L(L.tail); L.tail = p; printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK;&#125; //删除给定值的第一个元素Status Delete_L(LinkList &amp;L,ElemType e)&#123; Link p = L.head -&gt; next; Link q = L.head; while(p)&#123; if(p-&gt;date == e) break; q = p; p = p -&gt; next; &#125; if(!p)&#123; printf(\"&gt;&gt;输入元素在线性表L中不存在！\\n\"); return ERROR; &#125; q -&gt; next = p -&gt; next; free(p); printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK;&#125; //设置p所指向节点的值Status SetCurElem(Link &amp;p,ElemType e)&#123; p-&gt;date = e; return OK;&#125;//计算链表的长度int ListLength(LinkList L)&#123; return L.len;&#125;//p指向L的一个结点，返回p指向结点的前驱的位置 无前驱返回NULLPosition PriorPos_L(LinkList &amp;L,Link p)&#123; Link temp = L.head; while( temp -&gt; next != p) temp = temp -&gt; next; return temp;&#125; //p指向L的一个结点，返回p指向结点的后继的位置 无后继返回NULLPosition NextPos_L(LinkList &amp;L,Link p)&#123; return p -&gt; next;&#125; //查找链表中第i个元素并以p返回Status LocatePos_L(LinkList &amp;L,int i,Link &amp;p)&#123; int iCount = 0; if( i &gt; 0 &amp;&amp; i &lt;= L.len)&#123; p = L.head; while(iCount++ != i) p = p -&gt; next; return OK; &#125; return ERROR;&#125; //返回头结点位置Position GetHead_L(LinkList L)&#123; return L.head;&#125; //返回尾结点位置Position GetLast_L(LinkList L)&#123; return L.tail;&#125; //查找与e相等的节点并返回该节点Position LocateElem_L(LinkList &amp;L,ElemType e)&#123; Link temp = L.head -&gt; next; while( temp -&gt; date != e ) //元素不在线性表中的情况未考虑 temp = temp -&gt; next; return temp;&#125;//合并两个有序表Status MergeList_L(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)&#123; //已知La，Lb为非逆序 Link pa = La.head -&gt; next; Link pb = Lb.head -&gt; next; Link pc; Lc = La; //La做Lc的头结点 pc = pa; while(pa &amp;&amp; pb)&#123; if(pa -&gt; date &lt;= pb -&gt; date)&#123; pc -&gt; next = pa; pc = pa; pa = pa -&gt; next; &#125;else&#123; pc -&gt; next = pb; pc = pb; pb = pb -&gt; next; &#125; &#125; pc -&gt;next = pa ? pa :pb; //插入剩余段 free(Lb.head); printf(\"&gt;&gt;合并成功!\\n\"); return OK;&#125;//遍历单链表Status ListTraverse_L(LinkList &amp;L)&#123; Link p = L.head -&gt; next; int i = L.len; printf(\"&gt;&gt;当前单链表L = (\"); while(p)&#123; printf(\" %d\",p-&gt;date); p = p-&gt;next; &#125; printf(\" )\\n\"); return OK; &#125; //text void InitMainMenu()&#123; printf(\"\\n\\t\\t\\t\\t 单链表的基本操作\\n\"); printf(\"\\t\\t/*--------------------------------------------------*/\\n\"); printf(\"\\t\\t 1.创建单链表\\t\\t 2.销毁线性表\\n\"); printf(\"\\t\\t 3.清空单链表\\t\\t 4.删除一个元素\\n\"); printf(\"\\t\\t 5.插入一个元素\\t 6.合并两个顺序表\\n\"); printf(\"\\t\\t 7.查找元素的前驱\\t 8.输出L\\n\");&#125; void text()&#123; Link p,h,s; LinkList L; LinkList La,Lb,Lc; ElemType e; int pos; int select; InitMainMenu(); while(1)&#123; printf(\"\\n&gt;请选择你的操作:\"); scanf(\"%d\",&amp;select); switch(select)&#123; case 1: printf(\"&gt;&gt;输入你想创建的链表长度:\"); scanf(\"%d\",&amp;pos); //InitList_L(L); CreateList_L(L,pos); ListTraverse_L(L); break; case 2: DestroyList_L(L); break; case 3: ClearList_L(L); ListTraverse_L(L); break; case 4: printf(\"&gt;&gt;输入你想要的删除方式：1.指定位置删除 2.表尾删除 3.删除给定值的第一个元素 \"); int deleteSelect; scanf(\"%d\",&amp;deleteSelect); switch(deleteSelect)&#123; case 1: printf(\"&gt;&gt;请输入删除位置：\"); scanf(\"%d\",&amp;pos); if(ListDelete_L(L,pos,e)) printf(\"&gt;&gt;删除第%d个元素%d\\n\",pos,e); ListTraverse_L(L); break; case 2: DeleteRear_L(L,e); printf(\"&gt;&gt;删除表尾元素%d\\n\",e); ListTraverse_L(L); break; case 3: printf(\"&gt;&gt;请输入删除元素：\"); scanf(\"%d\",&amp;e); Delete_L(L,e); ListTraverse_L(L); break; &#125; break; case 5: printf(\"&gt;&gt;输入你想要的插入方式：1.指定位置插入 2.表尾插入 3.有序链表插入 \"); int insertSelect; scanf(\"%d\",&amp;insertSelect); switch(insertSelect)&#123; case 1: printf(\"&gt;&gt;请输入插入位置和插入元素：\"); scanf(\"%d %d\",&amp;pos,&amp;e); InsBefore_L(L,pos,e); ListTraverse_L(L); break; case 2: printf(\"&gt;&gt;请输入插入元素：\"); scanf(\"%d\",&amp;e); InsertRear_L(L,e); ListTraverse_L(L); break; case 3: printf(\"&gt;&gt;请输入插入元素：\"); scanf(\"%d\",&amp;e); InsertOrder_L(L,e); ListTraverse_L(L); break; &#125; break; case 6: printf(\"&gt;&gt;输入第一个链表长度:\"); scanf(\"%d\",&amp;pos); CreateList_L(La,pos); ListTraverse_L(La); printf(\"&gt;&gt;输入第二个链表长度:\"); scanf(\"%d\",&amp;pos); CreateList_L(Lb,pos); ListTraverse_L(Lb); MergeList_L(La,Lb,Lc); ListTraverse_L(Lc); break; case 7: printf(\"&gt;&gt;请输入查找方式：1.查找固定位置元素的前驱 2.查找固定元素的前驱 \"); Link k; int posSelect; scanf(\"%d\",&amp;posSelect); switch(posSelect)&#123; case 1: printf(\"&gt;&gt;&gt;请输入元素位置：\"); scanf(\"%d\",&amp;pos); if(LocatePos_L(L,pos,p))&#123; k = PriorPos_L(L,p); if(k == L.head) printf(\"&gt;&gt;&gt;第1个元素无直接前驱!\\n\"); else printf(\"&gt;&gt;&gt;第%d个元素的前驱为：%d\\n\",pos,k-&gt;date); &#125;else printf(\"&gt;&gt;&gt;输入元素位置错误!\\n\"); break; case 2: printf(\"&gt;&gt;&gt;请输入元素的值：\"); scanf(\"%d\",&amp;e); p = LocateElem_L(L,e); if(p != NULL)&#123; k = PriorPos_L(L,p); if(k == L.head) printf(\"&gt;&gt;&gt;元素%d为第1个元素无直接前驱!\\n\",e); else printf(\"&gt;&gt;&gt;元素%d的前驱为：%d\\n\",e,k-&gt;date); &#125;else printf(\"&gt;&gt;&gt;输入元素不在单链表L中!\\n\"); break; &#125; break; case 8: printf(\"&gt;&gt;首指针指向：%d 尾指针指向：%d 链表长度为：%d\",L.head-&gt;next-&gt;date,L.tail-&gt;date,L.len); break; &#125; &#125; &#125;int main() &#123; text(); return 0;&#125; StatcList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include&lt;stdio.h&gt;#define MAXSIZE 100#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef int ElemType;typedef struct&#123; ElemType data; int cur;&#125;component,SLinkList[MAXSIZE];//求链表长度int Length_SL(SLinkList S)&#123; int j = 0; int i = S[MAXSIZE-1].cur; while(i)&#123; j++; i = S[i].cur; &#125; return j; &#125; //动态分配函数int malloc_SL(SLinkList S)&#123; int i = S[0].cur; if(i == 0)&#123; printf(\"备用链表为空，无法分配！\"); return ERROR; &#125; S[0].cur = S[i].cur; return i; &#125;//freeStatus Free(SLinkList S, int k)&#123; //将位置为k的空闲结点释放 //即插入到备用链表第一个结点前 S[k].cur = S[0].cur; S[0].cur = k; return OK;&#125;//初始化Status InitList_SL(SLinkList S)&#123; int i; S[MAXSIZE-1].cur = 0; //链表头结点为空 for(i = 0 ;i &lt; MAXSIZE - 2 ; i++) S[i].cur = i+1; //备用链表 S[MAXSIZE-2].cur = 0; //链表最后一个元素为空 return OK;&#125; //销毁Status DestoryList_SL(SLinkList S)&#123; int i = S[MAXSIZE-1].cur; S[MAXSIZE-1].cur=0; //头结点指向空 int k = S[0].cur; //k记录备用链表第一个结点 S[0].cur = i; //S[0].cur 指向链表第一个元素 int j; while(i)&#123; //找到S最后一个结点 赋值给j j = i; i = S[i].cur; &#125; S[j].cur = k; //链接两个链表 return OK; &#125; //判空Status ListEmpty_SL(SLinkList S)&#123; if(S[MAXSIZE-1].cur == 0) return TRUE; else return FALSE; &#125; //取元素Status GetElem_SL(SLinkList S,int i,ElemType &amp;e)&#123; int j=1, k = S[MAXSIZE-1].cur; if (i&lt;1 || i &gt; Length_SL(S))&#123; //判断位置是否合理 printf(\"查找位置不合理！\"); return ERROR; &#125; while (k &amp;&amp; j&lt;i)&#123; //找到第i个位置 ++j; k = S[k].cur; &#125; e = S[k].data; return OK;&#125; //查找元素int LocateElem_SL(SLinkList S,ElemType e)&#123; int i = S[MAXSIZE-1].cur; int j = 0; while(i)&#123; j++; if(S[i].data == e) return j; else i = S[i].cur; &#125; if(!i)&#123; printf(\"查无此元素！\"); return ERROR; &#125; &#125; //找前驱 Status PriorElem_SL(SLinkList S, ElemType e, ElemType &amp;cur_e) &#123; int i = S[MAXSIZE-1].cur; int j ; while (j)&#123; j = S[i].cur; if (j &amp;&amp; S[j].data == e)&#123; cur_e = S[i].data; return OK; &#125; i = j; &#125; return ERROR; &#125; //找后继 Status NextElem_SL(SLinkList S, ElemType e, ElemType &amp;nex_e) &#123; int i = S[MAXSIZE-1].cur; int j; while (i)&#123; j = S[i].cur; if (j &amp;&amp; S[i].data == e)&#123; nex_e = S[j].data; return OK; &#125; i = j; &#125; return ERROR; &#125;//前插入Status Ins_SL(SLinkList S,int i,ElemType e)&#123; int s; int j = 1; int k = S[MAXSIZE-1].cur; if(i &lt; 1 || i &gt; Length_SL(S)+1)&#123; printf(\"插入位置不合理\"); return ERROR; &#125; while( k &amp;&amp; j &lt;i-1 )&#123; j++; k = S[k].cur; &#125; s = malloc_SL(S); S[s].data = e; S[s].cur = S[k].cur; S[k].cur = s; return OK; &#125; //删除 Status ListDelete(SLinkList S, int i, ElemType &amp;e) &#123; int k = S[MAXSIZE-1].cur; int j = 1, m; if (i&lt;1 || i&gt;Length_SL(S))&#123; //判断位置是否合理 printf(\"删除位置不合理！\"); return ERROR; &#125; while (k &amp;&amp; j&lt;i-1)&#123; //找到第i-1个位置 ++j; k = S[k].cur; &#125; m = S[k].cur; //m指向第i个位置 e = S[m].data; S[k].cur = S[m].cur; Free(S, m); //将空闲结点m释放到备用链表中 return OK; &#125;void TravelList(SLinkList S)&#123; int j = 0; int i = S[MAXSIZE-1].cur; while (i)&#123; j++; printf(\"第%d个结点为：%d\\n\", j, S[i].data); i = S[i].cur; &#125;&#125;int main()&#123; SLinkList S; ElemType e,cur_e,nex_e; int pos; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]}]}