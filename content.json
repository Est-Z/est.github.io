{"meta":{"title":"Est","subtitle":null,"description":"专注划水的技术博客","author":"Est","url":"https://Est-C.coding.me/Est-C.coding.me"},"pages":[],"posts":[{"title":"Why do I write blog?","slug":"Why-do-I-write-blog","date":"2018-10-15T14:16:42.000Z","updated":"2018-10-15T15:54:42.064Z","comments":true,"path":"2018/10/15/Why-do-I-write-blog/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/15/Why-do-I-write-blog/","excerpt":"","text":"ListLinkList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;conio.h&gt;#include &lt;malloc.h&gt;#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0typedef int ElemType ;typedef int Status ;/* 自定义结点类型指针 结点包括数据项date和指向（struct LNode）的指针 Link Position为指向结点的指针类型 */typedef struct LNode&#123; ElemType date; struct LNode *next;&#125;*Link , *Position; /* 自定义指针结构指针 head tail是Link类型指针 用来指向结点 len存储链表长度 */ typedef struct List&#123; Link head,tail; //分别指向头尾 int len = 0; //长度 &#125;LinkList; /* 本程序中常用临时指针 p q r 来完成操作 均为Link类型 ----Written Est */ /*//初始化一个空的线性链表L Status InitList_L(LinkList &amp;L)&#123; L.head = (Link)malloc(sizeof(struct LNode)); if(!L.head)&#123; printf(\"分配空间失败\"); return ERROR; &#125; L.head-&gt;next = NULL; return OK;&#125;*///分配p指向e的结点Status MakeNode_L(Link p,ElemType e)&#123; p = (Link)malloc(sizeof(struct LNode)); if(p != NULL)&#123; p -&gt; date = e; p -&gt; next = NULL; return OK; &#125; return ERROR;&#125; //释放p指向的结点Status FreeNode_L(Link *p)&#123;&#125; //创建指定长度单链表Status CreateList_L(LinkList &amp;L,int n)&#123; L.head = L.tail = (Link)malloc(sizeof(struct LNode)); L.head -&gt; next = NULL; //建立一个带头节点的单链表 if(!L.head)&#123; printf(\"&gt;&gt;初始化失败！\"); return ERROR; &#125; Link q = L.head ; //p指向头节点 printf(\"&gt;&gt;输入链表的值：\"); while(n--)&#123; Link p = (Link)malloc(sizeof(struct LNode)); //申请一个新结点 scanf(\"%d\",&amp;p-&gt;date); //输入数据 q -&gt; next = p; //插入到表尾 q = p; L.len++ ; //长度+1 &#125; L.tail = q; L.tail-&gt;next = NULL; printf(\"&gt;&gt;初始化成功！\\n\"); return OK; &#125; //销毁线性表LStatus DestroyList_L(LinkList &amp;L)&#123; Link p; while(L.head != L.tail)&#123; //头结点开始 依次释放结点 p = L.head; L.head = L.head -&gt; next; free(p); &#125; if(L.head == L.tail)&#123; printf(\"&gt;&gt;销毁成功!\\n\"); L.head = L.tail = NULL; //头尾结点指向NULL L.len = 0; //长度更新 return OK; &#125; else&#123; printf(\"&gt;&gt;销毁失败!\\n\"); return ERROR; &#125; &#125;//清空线性表Status ClearList_L(LinkList &amp;L)&#123; Link p,q; p = L.head -&gt; next; while(p)&#123; q = p -&gt; next; free(p); p = q; &#125; L.tail = L.head; L.head -&gt; next = NULL; printf(\"&gt;&gt;清空成功!\\n\"); L.len = 0; return OK;&#125;//在链表的第一个位置插入节点，h指向头结点Status InsFirst_L(Link h,Link s)&#123; s-&gt;next = h-&gt;next; h-&gt;next = s; return OK;&#125;//在删除链表中第一个节点并以p返回，h为头结点指针Status DelFirst_L(Link h,Link p)&#123; p = h-&gt;next; h-&gt;next = h-&gt;next-&gt;next; return OK;&#125;//将s所指的一串结点连接在线性表L的最后一个结点Status Append_L(LinkList &amp;L,Link s)&#123; if(L.head)&#123; L.tail -&gt; next = s; Link temp = L.head; while(temp -&gt; next) temp = temp -&gt; next; L.tail = temp; return OK; &#125; return ERROR;&#125; //第i个元素存在时，将第i个元素赋值个e并返回OK 否则返回ERROR Status GetELem_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(i&lt;1) &#123; //输入值有误 printf(\"&gt;&gt;输入值有误!\"); return ERROR; &#125; int j; Link p = L.head -&gt; next; while( j &lt; i &amp;&amp; p)&#123; //j&lt;i且p不为空 找到第i个元素 p = p -&gt; next; j++; &#125; if( !p || j&gt;i )&#123; printf(\"第%d个元素不存在\",i); return ERROR; &#125; e = p -&gt; date; //e返回第i个元素的值 return OK; &#125; //在第i个元素之前插入元素eStatus InsBefore_L(LinkList &amp;L,int i,ElemType e) &#123; Link s; Link p = L.head; int j = 0; while( p &amp;&amp; j &lt; i-1)&#123; //找到第i-1个元素 并将p指向 p = p-&gt; next; j++; &#125; if( !p || j &gt; i-1 ) &#123; //输入值有误 printf(\"&gt;&gt;输入插入点有误！\"); return ERROR; &#125; s = (Link)malloc(sizeof(struct LNode)); //插入 s -&gt; date = e; s -&gt; next = p -&gt; next; p -&gt; next = s; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //更新长度 return OK; &#125;//向线性表末尾添加一个元素Status InsertRear_L(LinkList &amp;L, ElemType e)&#123; Link p = L.tail; //p指向表尾 Link q = (Link)malloc(sizeof(struct LNode)); //新建结点 q -&gt; date = e; q -&gt; next = p -&gt; next; //插入 p -&gt; next = q; p = p -&gt; next; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //长度+1 return OK;&#125; //向有序链表插入一个元素 使之依然有序Status InsertOrder_L(LinkList &amp;L,ElemType e)&#123; Link p = L.head -&gt; next; //p指向第一个结点 Link q = L.head; //q指向p的上一个结点 if( (p-&gt;date) &gt; (p-&gt;next-&gt;date) )&#123; //判断有序还是逆序 while(p &amp;&amp; p-&gt;date &gt; e)&#123; q = p; p = p-&gt;next; &#125; &#125;else&#123; while( p &amp;&amp; p-&gt;date &lt; e)&#123; q = p; p = p-&gt;next; &#125; &#125; //此时p指向插入点 q指向插入点的上一个结点 Link z = (Link)malloc(sizeof(struct LNode)); //新建结点 z -&gt; date = e; z -&gt; next = q -&gt; next; q -&gt; next = z; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //长度+1 return OK;&#125; //删除第i个元素 并用e返回其值Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(i &gt; L.len)&#123; printf(\"&gt;&gt;删除位置有误!\\n\"); return ERROR; &#125; int j = 0; Link q; Link p = L.head; while( p &amp;&amp; j &lt; i-1 )&#123; //寻找第i个节点 并使p指向其前驱 p = p -&gt; next; j++; &#125; if( !(p -&gt; next) &amp;&amp; j &gt; i-1)&#123; printf(\"&gt;&gt;删除位置有误!\"); return ERROR; &#125; q = p -&gt; next; //删除 p -&gt; next = q -&gt;next; e = q -&gt;date; free(q); printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK; &#125; //删除表尾元素Status DeleteRear_L(LinkList &amp;L,ElemType &amp;e)&#123; Link p = L.head ; while( (p-&gt;next) != L.tail) //p指向尾元素的前驱 p = p -&gt; next; e = L.tail -&gt; date; p -&gt; next = NULL; free(L.tail); L.tail = p; printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK;&#125; //删除给定值的第一个元素Status Delete_L(LinkList &amp;L,ElemType e)&#123; Link p = L.head -&gt; next; Link q = L.head; while(p)&#123; if(p-&gt;date == e) break; q = p; p = p -&gt; next; &#125; if(!p)&#123; printf(\"&gt;&gt;输入元素在线性表L中不存在！\\n\"); return ERROR; &#125; q -&gt; next = p -&gt; next; free(p); printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK;&#125; //设置p所指向节点的值Status SetCurElem(Link &amp;p,ElemType e)&#123; p-&gt;date = e; return OK;&#125;//计算链表的长度int ListLength(LinkList L)&#123; return L.len;&#125;//p指向L的一个结点，返回p指向结点的前驱的位置 无前驱返回NULLPosition PriorPos_L(LinkList &amp;L,Link p)&#123; Link temp = L.head; while( temp -&gt; next != p) temp = temp -&gt; next; return temp;&#125; //p指向L的一个结点，返回p指向结点的后继的位置 无后继返回NULLPosition NextPos_L(LinkList &amp;L,Link p)&#123; return p -&gt; next;&#125; //查找链表中第i个元素并以p返回Status LocatePos_L(LinkList &amp;L,int i,Link &amp;p)&#123; // p = NULL; ?? int iCount = 0; if( i &gt; 0 &amp;&amp; i &lt;= L.len)&#123; p = L.head; while(iCount++ != i) p = p -&gt; next; return OK; &#125; return ERROR;&#125; //返回头结点位置Position GetHead_L(LinkList L)&#123; return L.head;&#125; //返回尾结点位置Position GetLast_L(LinkList L)&#123; return L.tail;&#125; //查找与e相等的节点并返回该节点Position LocateElem_L(LinkList &amp;L,ElemType e)&#123; Link temp = L.head -&gt; next; while( temp -&gt; date != e ) //元素不在线性表中的情况未考虑 temp = temp -&gt; next; return temp;&#125;//合并两个有序表Status MergeList_L(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)&#123; //已知La，Lb为非逆序 Link pa = La.head -&gt; next; Link pb = Lb.head -&gt; next; Link pc; Lc = La; //La做Lc的头结点 pc = pa; while(pa &amp;&amp; pb)&#123; if(pa -&gt; date &lt;= pb -&gt; date)&#123; pc -&gt; next = pa; pc = pa; pa = pa -&gt; next; &#125;else&#123; pc -&gt; next = pb; pc = pb; pb = pb -&gt; next; &#125; &#125; pc -&gt;next = pa ? pa :pb; //插入剩余段 free(Lb.head); printf(\"&gt;&gt;合并成功!\\n\"); return OK;&#125;//遍历单链表Status ListTraverse_L(LinkList &amp;L)&#123; Link p = L.head -&gt; next; int i = L.len; printf(\"&gt;&gt;当前单链表L = (\"); while(p)&#123; printf(\" %d\",p-&gt;date); p = p-&gt;next; &#125; printf(\" )\\n\"); return OK; &#125; void InitMainMenu()&#123; printf(\"\\n\\t\\t\\t\\t 单链表的基本操作\\n\"); printf(\"\\t\\t/*--------------------------------------------------*/\\n\"); printf(\"\\t\\t 1.创建单链表\\t\\t 2.销毁线性表\\n\"); printf(\"\\t\\t 3.清空单链表\\t\\t 4.删除一个元素\\n\"); printf(\"\\t\\t 5.插入一个元素\\t 6.合并两个顺序表\\n\"); printf(\"\\t\\t 7.查找元素的前驱\\t 8.输出L\\n\"); printf(\"\\t\\t 9.\\t 10.输出L\\n\");&#125; int main() &#123; Link p,h,s; LinkList L; LinkList La,Lb,Lc; ElemType e; int pos; int select; InitMainMenu(); while(1)&#123; printf(\"\\n&gt;请选择你的操作:\"); scanf(\"%d\",&amp;select); switch(select)&#123; case 1: printf(\"&gt;&gt;输入你想创建的链表长度:\"); scanf(\"%d\",&amp;pos); //InitList_L(L); CreateList_L(L,pos); ListTraverse_L(L); break; case 2: DestroyList_L(L); break; case 3: ClearList_L(L); ListTraverse_L(L); break; case 4: printf(\"&gt;&gt;输入你想要的删除方式：1.指定位置删除 2.表尾删除 3.删除给定值的第一个元素 \"); int deleteSelect; scanf(\"%d\",&amp;deleteSelect); switch(deleteSelect)&#123; case 1: printf(\"&gt;&gt;请输入删除位置：\"); scanf(\"%d\",&amp;pos); if(ListDelete_L(L,pos,e)) printf(\"&gt;&gt;删除第%d个元素%d\\n\",pos,e); ListTraverse_L(L); break; case 2: DeleteRear_L(L,e); printf(\"&gt;&gt;删除表尾元素%d\\n\",e); ListTraverse_L(L); break; case 3: printf(\"&gt;&gt;请输入删除元素：\"); scanf(\"%d\",&amp;e); Delete_L(L,e); ListTraverse_L(L); break; &#125; break; case 5: printf(\"&gt;&gt;输入你想要的插入方式：1.指定位置插入 2.表尾插入 3.有序链表插入 \"); int insertSelect; scanf(\"%d\",&amp;insertSelect); switch(insertSelect)&#123; case 1: printf(\"&gt;&gt;请输入插入位置和插入元素：\"); scanf(\"%d %d\",&amp;pos,&amp;e); InsBefore_L(L,pos,e); ListTraverse_L(L); break; case 2: printf(\"&gt;&gt;请输入插入元素：\"); scanf(\"%d\",&amp;e); InsertRear_L(L,e); ListTraverse_L(L); break; case 3: printf(\"&gt;&gt;请输入插入元素：\"); scanf(\"%d\",&amp;e); InsertOrder_L(L,e); ListTraverse_L(L); break; &#125; break; case 6: printf(\"&gt;&gt;输入第一个链表长度:\"); scanf(\"%d\",&amp;pos); CreateList_L(La,pos); ListTraverse_L(La); printf(\"&gt;&gt;输入第二个链表长度:\"); scanf(\"%d\",&amp;pos); CreateList_L(Lb,pos); ListTraverse_L(Lb); MergeList_L(La,Lb,Lc); ListTraverse_L(Lc); break; case 7: printf(\"&gt;&gt;请输入查找方式：1.查找固定位置元素的前驱 2.查找固定元素的前驱 \"); Link k; int posSelect; scanf(\"%d\",&amp;posSelect); switch(posSelect)&#123; case 1: printf(\"&gt;&gt;&gt;请输入元素位置：\"); scanf(\"%d\",&amp;pos); if(LocatePos_L(L,pos,p))&#123; k = PriorPos_L(L,p); if(k == L.head) printf(\"&gt;&gt;&gt;第1个元素无直接前驱!\\n\"); else printf(\"&gt;&gt;&gt;第%d个元素的前驱为：%d\\n\",pos,k-&gt;date); &#125;else printf(\"&gt;&gt;&gt;输入元素位置错误!\\n\"); break; case 2: printf(\"&gt;&gt;&gt;请输入元素的值：\"); scanf(\"%d\",&amp;e); p = LocateElem_L(L,e); if(p != NULL)&#123; k = PriorPos_L(L,p); if(k == L.head) printf(\"&gt;&gt;&gt;元素%d为第1个元素无直接前驱!\\n\",e); else printf(\"&gt;&gt;&gt;元素%d的前驱为：%d\\n\",e,k-&gt;date); &#125;else printf(\"&gt;&gt;&gt;输入元素不在单链表L中!\\n\"); break; &#125; break; case 10: printf(\"&gt;&gt;首指针指向：%d 尾指针指向：%d 链表长度为：%d\",L.head-&gt;next-&gt;date,L.tail-&gt;date,L.len); break; &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-10-13T15:21:23.447Z","updated":"2018-10-13T15:21:23.447Z","comments":true,"path":"2018/10/13/hello-world/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}