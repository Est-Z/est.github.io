{"meta":{"title":"Est","subtitle":null,"description":"一个专注划水的博客","author":"Est","url":"https://Est-C.coding.me/Est-C.coding.me"},"pages":[{"title":"categories","date":"2019-07-08T14:42:52.000Z","updated":"2019-07-08T14:43:33.118Z","comments":true,"path":"categories/index.html","permalink":"https://Est-C.coding.me/Est-C.coding.me/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-08T14:40:29.000Z","updated":"2019-07-08T14:41:16.625Z","comments":true,"path":"tags/index.html","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BiTree","slug":"BiTree","date":"2018-11-27T15:34:21.000Z","updated":"2018-11-27T15:56:22.232Z","comments":true,"path":"2018/11/27/BiTree/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/11/27/BiTree/","excerpt":"This is a blog to show BiTree and BiThrTree.","text":"This is a blog to show BiTree and BiThrTree. TreeBiTree1234567891011121314151617181920typedef int Status;typedef char TElemType;typedef struct BiTNode&#123; TElemType data; struct BiTNode *lchild,*rchild; struct BiTNode *parent;&#125;BiTNode,*BiTree;//输出 Status PrintTElemType(TElemType e)&#123; printf(\"%c\",e); return OK;&#125;Status CreateBiTree(BiTree &amp;T); //先序序列构建二叉树Status PreOrderTraverse(BiTree T); //先序遍历Status InOrderTraverse(BiTree T); //中序遍历Status PostOrderTraverse(BiTree T); //后序遍历Status LevelOrderTraverse(BiTree T); //层序遍历 CreateBiTree先序序列构建二叉树12345678910111213141516171819202122Status CreateBiTree(BiTree &amp;T,BiTNode *par)&#123; char ch; scanf(\"%c\",&amp;ch); if(ch==' ') T = NULL; else&#123; if(!(T = (BiTNode*)malloc(sizeof(BiTNode)))) return OVERFLOW; T-&gt;data = ch; //设置数据域 T-&gt;parent = par; //父节点指向 par = T; //记录根结点为父节点 CreateBiTree(T-&gt;lchild,par); //设置左子树 CreateBiTree(T-&gt;rchild,par); //设置右子树 &#125; return OK;&#125; PreOrderTraverse先序遍历123456789Status PreOrderTraverse(BiTree T)&#123; if(T)&#123; PrintTElemType(T-&gt;data); //输出 PreOrderTraverse(T-&gt;lchild); //先序左子树 PreOrderTraverse(T-&gt;rchild); //先序右子树 &#125; return OK;&#125;//递归方法 InOrderTraverse中序遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879typedef BiTNode* SElemType; typedef struct StackNode&#123; SElemType data; //数据域 struct StackNode *next; //结构体指针 &#125;StackNode , *LinkStackPtr;typedef struct LinkStack&#123; //栈指针 LinkStackPtr top; //top指针 int count; //栈元素个数 &#125;LinkStack;Status InitStack(LinkStack &amp;S)&#123; S.top = (LinkStackPtr)malloc(sizeof(StackNode)); //申请空间 S.count = 0; if(!S.top) //是否申请成功 return ERROR; S.top-&gt;next = NULL; //头结点指向NULL (栈底) return OK;&#125;Status StackEmpty(LinkStack &amp;S)&#123; return S.count == 0 ? TRUE : FALSE;&#125; //判空Status Push(LinkStack &amp;S , SElemType e)&#123; LinkStackPtr p = (LinkStackPtr)malloc(sizeof(StackNode)); //申请新节点 p -&gt; data = e; p -&gt; next = S.top; //结点赋值 S.top = p; S.count++; //更改链表关系 return OK;&#125;//入栈Status Pop(LinkStack &amp;S,SElemType &amp;e)&#123; if(StackEmpty(S)) return ERROR; LinkStackPtr p = S.top; //p指向栈顶 e = p-&gt;data; S.top = S.top -&gt; next; S.count--; //更新链表关系 free(p); return OK;&#125; //出栈Status InOrderTraverse(BiTree T)&#123; LinkStack S; InitStack(S); //初始化栈 while( T || !StackEmpty(S) )&#123; if(T)&#123; Push(S,T); //当前不为NULL，则自己入栈 T = T-&gt;lchild; //T指向左子树 &#125;else&#123; Pop(S,T); //为NULL 出栈 PrintTElemType(T-&gt;data); //输出 T = T-&gt;rchild; //T指向右子树 &#125; &#125; return OK;&#125;//非递归方法 12345678910Status InOrderTraverse2(BiTree T)&#123; if(T)&#123; InOrderTraverse2(T-&gt;lchild); PrintTElemType(T-&gt;data); InOrderTraverse2(T-&gt;rchild); &#125; return OK; &#125;//递归方法 PostOrderTraverse后序遍历1234567891011Status PostOrderTraverse(BiTree T)&#123; if(T)&#123; PostOrderTraverse(T-&gt;lchild); PostOrderTraverse(T-&gt;rchild); PrintTElemType(T-&gt;data); &#125; return OK;&#125;//递归 LevelOrderTraverse层序遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788typedef BiTree QElemType;typedef struct QNode&#123; //队列结点 QElemType data; struct QNode *next; &#125;QNode, *QueuePtr;typedef struct&#123; //队列指针 QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 &#125;LinkQueue;Status InitQueue(LinkQueue &amp;Q)&#123; Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); //申请结点 if(!Q.front) //是否申请成功 return ERROR; Q.front -&gt; next = NULL; return OK;&#125;//初始化Status QueueEmpty(LinkQueue &amp;Q)&#123; if(Q.front == Q.rear) return TRUE; else return FALSE;&#125;//判空Status EnQueue(LinkQueue &amp;Q,QElemType e)&#123; QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); if(!p) return ERROR; p -&gt; next = NULL; p -&gt; data = e; Q.rear -&gt; next = p; Q.rear = p; return OK;&#125;//入队Status DeQueue(LinkQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) return ERROR; QueuePtr p = Q.front -&gt; next; e = p -&gt; data; Q.front -&gt; next = p -&gt; next; if(Q.rear == p) Q.rear = Q.front; free(p); return OK;&#125;//出队 Status LevelOrderTraverse(BiTree T)&#123; LinkQueue Q; InitQueue(Q); BiTree p = T; EnQueue(Q,p); PrintTElemType(p-&gt;data); while(!QueueEmpty(Q))&#123; DeQueue(Q,p); if(p-&gt;lchild)&#123; PrintTElemType(p-&gt;lchild-&gt;data); EnQueue(Q,p-&gt;lchild); &#125; if(p-&gt;rchild)&#123; PrintTElemType(p-&gt;rchild-&gt;data); EnQueue(Q,p-&gt;rchild); &#125; &#125; return OK;&#125; main1234567891011121314151617181920212223int main()&#123; BiTree T; TElemType e; CreateBiTree(T,NULL); printf(\"先序遍历：\"); PreOrderTraverse(T); printf(\"\\n\"); printf(\"中序遍历：\"); InOrderTraverse(T); printf(\"\\n\"); printf(\"中序遍历：\"); InOrderTraverse2(T); printf(\"\\n\"); printf(\"后序遍历：\"); PostOrderTraverse(T); printf(\"\\n\"); printf(\"先序遍历：\"); LevelOrderTraverse(T); return 0; &#125; BiThrTree中序线索二叉树 123456789101112131415typedef int Status;typedef int TElemType; typedef enum PointerTag&#123; Link, Thread &#125;PointerTag;typedef struct BiThrNode&#123; TElemType data; struct BiThrNode *lchild,*rchild; PointerTag LTag,RTag;&#125;BiThrNode,*BiThrTree;Status visit(TElemType e)&#123; printf(\"%c\",e); return OK;&#125;//输出 CreateBiTree先序序列构建二叉树123456789101112131415161718192021Status CreateBiTree(BiThrTree &amp;T)&#123; char ch; scanf(\"%c\",&amp;ch); if(ch==' ') T = NULL; else&#123; if(!(T = (BiThrNode*)malloc(sizeof(BiThrNode)))) return OVERFLOW; T-&gt;data = ch; //设置数据域 T-&gt;LTag = Link; T-&gt;RTag = Link; CreateBiTree(T-&gt;lchild); //设置左子树 CreateBiTree(T-&gt;rchild); //设置右子树 &#125; return OK;&#125; InOrderThreading中序遍历二叉树，使其线索化（Thrt是头结点）123456789101112131415161718192021222324252627282930313233343536373839404142BiThrTree pre;void InTreading(BiThrTree p)&#123; if(p)&#123; InTreading(p-&gt;lchild); if(!p-&gt;lchild)&#123; p-&gt;LTag = Thread; p-&gt;lchild = pre; &#125; if(!pre-&gt;rchild)&#123; pre-&gt;RTag = Thread; pre-&gt;rchild = p; &#125; pre = p; InTreading(p-&gt;rchild); &#125;&#125;Status InOrderThreading(BiThrTree &amp;Thrt,BiThrTree T)&#123; if(!(Thrt = (BiThrTree)malloc(sizeof(BiThrNode)))) return OVERFLOW; Thrt-&gt;LTag = Link; Thrt-&gt;RTag = Thread; Thrt-&gt;rchild = Thrt; if(!T) Thrt-&gt;lchild = Thrt; else&#123; Thrt-&gt;lchild = T; pre = Thrt; InTreading(T); //线索化 pre-&gt;rchild = Thrt; pre-&gt;RTag = Thread; Thrt-&gt;rchild = pre; &#125; return OK;&#125; InOrderTraverse_Thr线索二叉树中序遍历1234567891011121314151617181920Status InOrderTraverse_Thr(BiThrTree Thrt)&#123; BiThrTree p = Thrt-&gt;lchild; while(p!=Thrt)&#123; while(p-&gt;LTag==Link) //找第一个元素 p = p-&gt;lchild; visit(p-&gt;data); while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=Thrt)&#123; p = p-&gt;rchild; visit(p-&gt;data); &#125; p = p-&gt;rchild; &#125; return OK;&#125; main12345678910int main()&#123; BiThrTree T,Thrt; CreateBiTree(T); InOrderThreading(Thrt,T); InOrderTraverse_Thr(Thrt); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"SparseMatrix","slug":"SparseMatrix","date":"2018-11-01T13:52:25.000Z","updated":"2018-11-01T13:59:36.731Z","comments":true,"path":"2018/11/01/SparseMatrix/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/11/01/SparseMatrix/","excerpt":"This is a blog to show SparseMatrix.","text":"This is a blog to show SparseMatrix. SparseMatrix稀疏矩阵 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define ERROR 0#define OK 1#define TRUE 1#define FALSE 0#define MAXSIZE 12500 //非零元最大值typedef int ElemType;typedef int Status; typedef struct&#123; int i,j; //该非零元的横下标与列下标 ElemType e; //非零元 &#125;Tirple;typedef struct&#123; Tirple data[MAXSIZE+1]; //三元表 data[0]未用 int mu,nu,tu; //矩阵行数 列数 非零元个数 &#125;TSMatrix; //操作Status CreatSMatrix(TSMatrix &amp;M); //创建稀疏矩阵Status DestorySMatrix(TSMatrix &amp;M); //销毁稀疏矩阵void PrintSMatrix(TSMatrix M); //输出稀疏矩阵Status CopySMatrix(TSMatrix M,TSMatrix &amp;T); //由稀疏矩阵M赋值得到T Status AddSMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q); //Q=M+NStatus SubtMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q); //Q=M-NStatus MultSMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q); //Q=M*NStatus TransposeSMatrix(TSMatrix M,TSMatrix &amp;T); //由M转置得T CreatSMatrix1234567891011121314151617181920212223242526272829//创建稀疏矩阵Status CreatSMatrix(TSMatrix &amp;M)&#123; int i,flag,m,n; ElemType e; printf(\"请输入矩阵的行数，列数，非零元个数:\"); scanf(\"%d %d %d\",&amp;M.mu,&amp;M.nu,&amp;M.tu); M.data[0].i = 0; //data[0]未用 for( i = 1 ; i &lt;= M.tu ;i++)&#123; do&#123; printf(\"请输入非零元素的行、列、值：\\n\"); scanf(\"%d %d %d\",&amp;m,&amp;n,&amp;e); flag = 0; if( m &lt; 1 || m &gt; M.mu || n &lt; 1 || n &gt; M.nu) //输入行列不合法 flag = 1; if( m &lt; M.data[i-1].i || m == M.data[i-1].i &amp;&amp; n &lt;= M.data[i-1].j ) //行列合法但顺序不对 flag = 1; &#125;while(flag == 1); //输入行列值没问题 存入三元表 M.data[i].i = m; M.data[i].j = n; M.data[i].e = e; &#125; &#125; DestorySMatrix123456//销毁稀疏矩阵Status DestorySMatrix(TSMatrix &amp;M)&#123; M.mu = 0; M.nu = 0; M.tu = 0;&#125; PrintSMatrix1234567891011//输出稀疏矩阵void PrintSMatrix(TSMatrix M)&#123; int i; printf(\"\\n%d行 %d列 %d个非零元素\",M.mu,M.nu,M.tu); printf(\"\\n==================\\n\"); printf(\" i j e\\n\"); for( i = 1 ; i &lt;= M.tu ; i++) printf(\"%4d %4d %4d\\n\",M.data[i].i,M.data[i].j,M.data[i].e); printf(\"\\n==================\\n\"); &#125; CopySMatrix12345//由稀疏矩阵M赋值得到T Status CopySMatrix(TSMatrix M,TSMatrix &amp;T)&#123; T = M;&#125; AddSMatrix1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Q=M+Nint compare(int c1,int c2)&#123; if(c1 == c2) return 0; else if(c1 &lt; c2) return 1; else return -1;&#125; Status AddSMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q)&#123; Tirple *Mp,*Me,*Np,*Ne,*Qh,*Qe; if(M.mu != N.mu || M.nu != N.nu) return ERROR; Mp = &amp;M.data[1]; //Mp指向三元表M的首元素 Np = &amp;N.data[1]; Me = &amp;M.data[M.tu]; //Me指向三元表M的未元素 Ne = &amp;N.data[N.tu]; Qh = Qe = Q.data; while(Mp &lt;= Me &amp;&amp; Np &lt;= Ne)&#123; Qe++; switch(compare(Mp-&gt;i,Np-&gt;i))&#123; case 1: *Qe = *(Mp++); break; case -1: *Qe = *(Np++); break; case 0: switch(compare(Mp-&gt;j,Np-&gt;j))&#123; case 1: *Qe = *(Mp++); break; case -1: *Qe = *(Np++); break; case 0: *Qe = *Mp; Qe-&gt;e += Np-&gt;e; if(!Qe-&gt;e) //之和为0 Qe--; Mp++; Np++; break; &#125; &#125; &#125; if(Mp&gt;Me) //M处理完毕 while(Np&lt;=Ne) *(++Qe) = *(Np++); if(Np&gt;Ne) //N处理完毕 while(Mp&lt;=Me) *(++Qe) = *(Mp++); Q.tu = Qe - Qh; //Q元素个数 Q.mu = M.mu; Q.nu = M.nu; return OK; &#125; SubtMatrix123456789//Q=M-N =&gt;（Q = M + -N） Status SubtMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q)&#123; int i; for( i = 1 ; i &lt;= N.tu ; i++) N.data[i].e *= -1; AddSMatrix(M,N,Q); return OK; &#125; MultSMatrix12345678910111213141516171819202122232425262728293031323334353637383940414243//Q=M*NStatus MultSMatrix(TSMatrix M,TSMatrix N,TSMatrix &amp;Q)&#123; int i,j,k; int q; if( M.nu != N.mu) //M的行不等于N的列 return ERROR; else&#123; Q.data[0].i = 0; //0未用 Q.mu = M.mu; //Q的行等于M的行 Q.nu = N.nu; //Q的列等于N的列 for( k = 1 ;k &lt;= Q.mu*Q.nu ; k++ ) //赋初值 Q.data[k].e = 0; i = 1; k = 1; while( i &lt;= M.tu )&#123; //两个矩阵的非零元未处理完 for( j = 1 ; j &lt;= N.tu ; j++)&#123; //M.j == N.i 则相乘 if( M.data[i].j == N.data[j].i) &#123; Q.data[k].i = M.data[i].i; //行列赋值 Q.data[k].j = N.data[j].j; Q.data[k].e = M.data[i].e*N.data[j].e; //相乘的结果 for( q = 1 ; q &lt;k ; q++ ) //在已存三元表里查找行列相同的元素 相加 if( Q.data[k].i == Q.data[q].i &amp;&amp; Q.data[k].j == Q.data[q].j)&#123; Q.data[q].e += Q.data[k].e; k--; //k退回 &#125; k++; &#125; &#125; i++; &#125; Q.tu = --k; //非零元个数 &#125; &#125; TransposeSMatrix1234567891011121314151617181920//由M转置得TStatus TransposeSMatrix(TSMatrix M,TSMatrix &amp;T)&#123; T.mu = M.nu; T.nu = M.mu; T.tu = M.tu; int i,j,k; if(T.tu)&#123; k = 1; for( i = 1 ; i &lt;= M.nu ; i++) for( j = 1 ; j &lt;= M.tu ; j++) //整个三元表中依次查找列数等于i的元素 if(M.data[j].j == i)&#123; T.data[k].i = M.data[j].j; T.data[k].j = M.data[j].i; T.data[k].e = M.data[j].e; k++; &#125; &#125; return OK;&#125; main123456789101112131415161718192021222324252627282930int main()&#123; TSMatrix M,N,Q,P,T,Z; CreatSMatrix(M); CreatSMatrix(N); printf(\"&gt;&gt;M N:\"); PrintSMatrix(M); PrintSMatrix(N); AddSMatrix(M,N,Q); SubtMatrix(M,N,P); printf(\"&gt;&gt;M+N:\"); PrintSMatrix(Q); printf(\"&gt;&gt;M-N:\"); PrintSMatrix(P); TransposeSMatrix(M,T); printf(\"&gt;&gt;M转置:\"); PrintSMatrix(T); printf(\"&gt;&gt;M*N:\"); MultSMatrix(M,N,Z); PrintSMatrix(Z); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"排序算法","slug":"排序算法","date":"2018-10-26T14:33:36.000Z","updated":"2018-11-03T02:00:08.817Z","comments":true,"path":"2018/10/26/排序算法/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/26/排序算法/","excerpt":"This is a blog to show Sort.","text":"This is a blog to show Sort. 本文以时间复杂度区分算法，主要分为O(n^)、O(nlogn)、O(n+k)三类复杂度 123本文动图均来自博客：https://www.cnblogs.com/eniac12/p/5329396.html (主要介绍比较排序)https://www.cnblogs.com/onepixel/articles/7674659.html (以非线性时间比较类排序和线性时间非比较类排序区分) 几个重要概念： 1.比较排序与非比较排序123456比较类排序：通过比较来决定元素间的相对次序，所以时间复杂度不能突破O(nlogn)，称为非线性时间比较类排序非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行复杂度为O(n^)-O(nlogn)的算法均为比较类排序，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序,希尔排序等。非比较排序时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。 2.稳定排序算法1对于相同元素 若排序前和和排序后先后位置不会改变 则为稳定排序算法 3.内部排序算法1数据存储在内存上进行排序操作 数据间比较和移动指令一般是相同的 4.原址排序算法1除了全部输入数据所占空间外 只需有限额外空间 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;/* 排序算法 样例数组为 a[10] = &#123;22,36,22,6,26,45,75,13,31,52&#125; 排序后 a[10] =&#123;6 13 22 22 26 31 36 45 52 75&#125;*/ void Swap(int *x, int *y) &#123; *x = *x ^ *y; //异或交换数字 *y = *x ^ *y; *x = *x ^ *y; &#125;&#123; //排序算法&#125;int main()&#123; int a[10] = &#123;22,36,22,6,26,45,75,13,31,52&#125;; int len = sizeof(a)/sizeof(int); //SelectSort(a,len); //InsertSort(a,len); //BubbleSort(a,len); //CockrailSort(a,len); //ShellSort(a,len); //QuickSort(a,0,len-1); //MergeSort(a,0,len-1); //HeapSort(a,len); //CountingSort(a,len); //BucketSort(a,len); RadixSort(a,len); int j = 0 ; for( j = 0; j &lt;len ; j++ ) printf(\"%d \",a[j]); return 0;&#125; O(n^)选择排序选择排序原理十分简单，可以理解为“抓小数”，每一轮遍历都找出一个最小数放在已排序列的末尾，直到排序完毕 1234567891011void SelectSort(ElemType L[],int n)&#123; int i,j,k; //i指向未排序的首元素 k指向最小元素 j遍历未排序数组 for( i=0 ; i&lt;n-1 ; i++)&#123; //若有n个元素 则需遍历n次 for( j=i+1,k=i ; j&lt;n ; j++) //每次找出当前未排序的最小元素 if( L[k] &gt; L[j] ) k = j; if(i != k) Swap(&amp;L[i],&amp;L[k]); //将最小元素放在合适位置 &#125;&#125; 冒泡排序冒泡排序如同它的名字，像水中冒泡一般，每次选择一个最大的数放在未排序序列的末尾冒泡排序与选择排序不同，冒泡排序只要发现元素顺序不对，就交换数字，而选择排序则是记录位置，遍历结束后交换 12345678void BubbleSort(ElemType L[],int n)&#123; int i,j; for(i = 0 ; i &lt; n ; i++) for(j = n-1; j &gt; i ; j--) if(L[j]&lt;L[j-1]) Swap(&amp;L[j],&amp;L[j-1]);&#125; 冒泡排序改进 –鸡尾酒排序 鸡尾酒排序采用“低-&gt;高-&gt;低-&gt;…”的方式排序，略优于冒泡排序 12345678910111213141516171819void CockrailSort(ElemType L[],int n)&#123; int i; int left = 0; int right = n-1; while( left &lt;= right )&#123; for( i=left ; i&lt;right ; i++) if(L[i]&gt;L[i+1]) Swap(&amp;L[i],&amp;L[i+1]); right--; for( i=right ; i&gt;left ; i-- ) if(L[i-1]&gt;L[i]) Swap(&amp;L[i-1],&amp;L[i]); left++; &#125; &#125; 插入排序插入排序就像打扑克牌，将数字分为已排序和未排序两部分，每次从未排序中取一个数字，在已排序数字中从后往前依次寻找合适的插入位置，直到排序完毕 1234567891011121314151617void InsertSort(ElemType L[],int n)&#123; int i,j; ElemType temp; for(i = 1;i &lt; n; i++)&#123; for(j = i-1,temp = L[i]; j&gt;=0;j--)&#123; if(L[j]&gt;temp) L[j+1] = L[j]; else&#123; L[j+1] = temp; break; &#125; &#125; if( j == -1) L[0] = temp; &#125;&#125; O(nlogn)-O(n^)希尔排序希尔排序是根据插入排序改进而来的 将排序序列分成h个间距为h的子序列，对每一个子序列进行排序堆排序 1234567891011121314151617181920void ShellSort(ElemType L[],int n)&#123; int i; int h = 0; while(h &lt;= n) //生成增量 h = 3*h + 1; while(h &gt;=1)&#123; for( i=h ; i&lt;n ; i++)&#123; int j = i-h ; ElemType temp = L[i]; while(j &gt;=0 &amp;&amp; L[j]&gt;temp)&#123; L[j+h] = L[j]; j -= h; &#125; L[j+h] = temp; &#125; h = (h-1)/3; &#125;&#125; O(nlogn)快速排序快速排序采用分治策略 核心是划分(Partition),每次选取一个数作为划分元(Pivot),与其他n-1个数字比较，将小于Pivot的元素移至划分元左边，大于或等于Pivot的元素移至划分元右边，用同样的方法对左右序列排序，至排序完成 1234567891011121314151617181920212223242526272829int Partition(ElemType L[],int frist,int last)&#123; int left = frist; int right = last; ElemType pivot = L[frist]; //每次选择第一个元素为基准 while(left&lt;right)&#123; while((right&gt;left)&amp;&amp;(L[right]&gt;=pivot)) //right左移 right--; if(left&lt;right) L[left++] = L[right]; while((left&lt;right)&amp;&amp;(L[left]&lt;pivot)) //left右移 left++; if(left&lt;right) L[right--] = L[left]; &#125; L[left] = pivot; return left;&#125;void QuickSort(ElemType L[],int first,int last)&#123; if(first&lt;last)&#123; int split = Partition(L,first,last); QuickSort(L,first,split-1); QuickSort(L,split+1,last); &#125; &#125; 归并排序归并排序也采用分治策略，但做法与快速排序恰恰相反，将一个序列分为两个小序列，分别排序后在合并为一个有序序列 1234567891011121314151617181920212223242526272829303132333435363738void Merge(ElemType S[],int left,int mid,int right)&#123; int len = right - left + 1; ElemType T[len]; int i = left; //前一数组起始元素 int j = mid+1; //后一数组起始元素 int k,index = 0; while( (i&lt;=mid) &amp;&amp; (j&lt;=right)) T[index++] = S[i] &lt;= S[j] ? S[i++] : S[j++]; while(i&lt;=mid) T[index++] = S[i++]; while(j&lt;=right) T[index++] = S[j++]; for(k=0;k&lt;len;k++) S[left++] = T[k]; free(T);&#125;void MergeSort(ElemType L[],int first,int last)&#123; if (first == last) return; int mid = (first+last)/2; MergeSort(L,first,mid); MergeSort(L,mid+1,last); Merge(L,first,mid,last); &#125; //改进void MergeSort2() &#123;&#125; 堆排序堆排序是O(nlogn)阶排序算法，采用二叉树的结构，但却没有用二叉树的指针，只是在数组上实现树的结构 !相较于快速排序： 快速排序很难保证划分平衡，最差时间复杂度为O(n^),且需要O(n)-O(logn)的辅助空间；而堆排序采用二叉 树结构，复杂度为 O(nlogn),且只需要O(1)的辅助空间。 !相较于合并排序： 复杂度相差不大，但合并排序需要较大空间(存储数据和下标) 堆排序过程： 1.建堆：通过比较移动，使每个节点的值大于其左右节点的值(BuildHeap) 2.根元素删除-堆修复：最大元素沉到堆尾(Swap(&amp;L[0],&amp;L[i]))，修复堆(FixHeap) 123456789101112131415161718192021222324252627282930313233343536373839404142void FixHeap(ElemType L[],int Hsize,int root,int k)&#123; //修复 //若root有两个子节点，则为L[2*root],L[2*root+1] int larger; //larger存放要和root结点比较的子节点 if((2*root) &gt; Hsize) //2*root&gt;Hsize 说明L[root]没有子结点 不需要修复 L[root-1] = k; else&#123; if((2*root) == Hsize) //只有一个子节点 larger = 2*root; else if(L[2*root-1] &gt; L[2*root+1-1]) //取左右子节点中较大的一个 larger = 2*root; else larger = 2*root+1; if(k &gt; L[larger-1]) //不交换 L[root-1] = k; else&#123; //交换 继续修复新的父节点 L[root-1] = L[larger-1]; FixHeap(L,Hsize,larger,k); &#125; &#125; &#125; void BuildHeap(ElemType L[],int n)&#123; //建树 int i; for(i = n/2; i&gt;=1 ; i--) //i&gt;n/2时，L[i]是叶节点 不必修复 FixHeap(L,n,i,L[i-1]); &#125; void HeapSort(ElemType L[],int n)&#123; //堆排序 int i; BuildHeap(L,n); for(i = n-1; i&gt;0 ; i--)&#123; //最后一个结点开始 将最大数“沉”下去 Swap(&amp;L[0],&amp;L[i]); //交换根与树尾 FixHeap(L,i,1,L[0]); //修复根 &#125; &#125; O(n+k)计数排序计数排序不是基于比较的排序 基本思想： 将要排序的序列按照一定关系存入额外开辟的数组中(数组下标表示该元素值，该下标对应的值表示该值的元 素个数 eg: counter[75]=1表示有一个值为75的元素) 优点： 可将时间复杂度降低到线性缺点： 输入必须是有确定范围的数(数的范围不能太大) 当O(K)&gt;O(nlogn)时，性能不如比较排序 1234567891011121314151617181920212223242526272829int CountingSort(ElemType L[],int n)&#123; int i; int len = n; ElemType max=L[0],min=L[0]; //查找最大元素 for( i = 0 ; i &lt; n ; i++ )&#123; min = min&lt;L[i]?min:L[i]; max = max&gt;L[i]?max:L[i]; &#125; ElemType *counter = (ElemType*)malloc(sizeof(ElemType)*(max-min+1));//申请所需数组空间 大小为max-min+1 if(!counter)&#123; free(counter); return -1; &#125; for( i = 0 ; i &lt;= max-min ; i++ ) //初始化数组 counter[i] = 0; for( i = 0 ; i &lt; len ; i++ ) //统计数值出现次数 counter[L[i]-min]++; //逆向遍历数组 保持稳定 for( i = max-min ; i &gt;= 0 ; i--) while( counter[i]-- != 0) L[--len] = i + min; free(counter); &#125; 桶排序桶排序是计数排序的升级版 是一种函数映射关系(类哈希的链式结构) !桶划分的越小 各桶之间的数据越少，排序时间越少，但空间消耗越大 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//链表存储数据 typedef struct node&#123; ElemType key; struct node* next;&#125;KeyNode;void BucketSort(ElemType L[],int n)&#123; int i,j=0; //桶初始化 int bucket_size = 10; //桶深为5 KeyNode **bucket_table = (KeyNode**)malloc(bucket_size*sizeof(KeyNode*)); //结构体数组 for( i = 0 ; i &lt;bucket_size ; i++)&#123; //每一个结构体赋初值 key=0 next=NULL bucket_table[i]=(KeyNode*)malloc(sizeof(KeyNode)); bucket_table[i]-&gt;key=0; bucket_table[i]-&gt;next=NULL; &#125; for( i = 0 ; i &lt; n ; i++)&#123; //遍历排序序列 插入合适位置 KeyNode * node = (KeyNode*)malloc(sizeof(KeyNode)); //新建结点存储该数值 node-&gt;key = L[i]; node-&gt;next = NULL; int index = L[i]/10; //分类方式（排序改进核心） KeyNode *p = bucket_table[index]; //p指向要插入的桶中 if(p-&gt;key == 0)&#123; //桶中无元素 直接放入 p-&gt;next = node; p-&gt;key++; &#125; else&#123; //桶中有元素 找到合适位置插入 while(p-&gt;next!=NULL &amp;&amp; p-&gt;next-&gt;key &lt;= node-&gt;key) // '&lt;=' 保证稳定性 p = p-&gt;next; node-&gt;next = p-&gt;next; p-&gt;next = node; (bucket_table[index]-&gt;key)++; //桶元素个数+1 &#125; &#125; KeyNode * k = NULL; for( i = 0 ; i &lt; bucket_size ; i++) for( k = bucket_table[i]-&gt;next; k!=NULL ; k = k-&gt;next ) L[j++] = k-&gt;key; &#125; 基数排序基数排序是将数据先按低位排序，收集，再按高位排序，再收集，依次直至最高未(适合小范围数) 1234567891011121314151617181920212223242526272829303132333435363738394041void RadixSort(ElemType L[],int n)&#123; int i,j; int max,maxDigit=0; //最大值 最大值位数 int dev = 1,mod = 10; //求余取位值 max = L[0]; //找最大数 for( i = 0 ; i &lt; n ; i++ ) max = max&gt;L[i]?max:L[i]; do &#123; //求最大值位数 maxDigit++; max /= 10 ; &#125; while( max&gt;0 ); int *bucket[10]; //指针数组 0-9十个桶 深度为n+1 for(i=0; i&lt;10; i++)&#123; bucket[i] = (int *)malloc(sizeof(int) * (n+1)); bucket[i][0] = 0; //0出存储元素个数 &#125; for( i = 1 ; i &lt;= maxDigit ; i++,dev*=10,mod*=10)&#123; //对每一位数进行排序 for( j = 0 ; j &lt; n ; j++)&#123; int num = L[j] % mod / dev; //取出该位置的值 int index = ++bucket[num][0]; //插入合适位置 bucket[num][index] = L[j]; &#125; int index = 0; for( j = 0 ; j &lt; 10 ; j++)&#123; //取出 int k; for( k = 1 ; k &lt;= bucket[j][0] ; k++) L[index++] = bucket[j][k]; bucket[j][0] = 0; // 复位 &#125; &#125;&#125; O( )猴子排序“猴子排序”的名字出自“无限猴子定理”——让一只猴子在打字机上随机地按键,当按键时间达到无穷时,几乎必然能够打出任何给定的文字,比如莎士比亚的全套著作. 排序思路：随机打乱数组-检查是否排序成功-不成功再次打乱-检查… 123456789101112131415161718192021222324252627void BogoSort(ElemType L[],int n)&#123; int i,j; int flag = 0; while(1)&#123; flag = 1; //判断是否有序 for(i = 0; i &lt; n-1; i++) if(L[i] &gt; L[i+1])&#123; flag = 0; break; &#125; if(flag) break; //随机打乱 for(i = 0; i &lt; n; i++)&#123; while( (j = rand() % n) == i); //若i==j 异或为0 ; Swap( &amp;L[i], &amp;L[j]); &#125; &#125; &#125; continue…","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/算法/"}]},{"title":"malloc() and free()","slug":"malloc-and-free","date":"2018-10-23T15:53:43.000Z","updated":"2018-10-24T07:24:38.311Z","comments":true,"path":"2018/10/23/malloc-and-free/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/23/malloc-and-free/","excerpt":"malloc()函数与free()函数","text":"malloc()函数与free()函数 在介绍malloc()与free()之前，我们先看一下alloc()与afree()函数，了解内存地址运算 alloc()/afree()alloc()函数返回一个指向n个连续字符存储单元的指针afree()函数释放已分配的存储空间 这两个函数功能类是malloc()与free()，但它们是“不完善的”，因为alloc()与free()是以栈的方式（后进先出）进行存储空间管理的 alloc()与afree()的实现alloc()是对一个大数组allocbuf中的空间进行分配 allocbuf是alloc()与afree()的私有数组，并且在管理中并不需要数组下表，因此可以申明为static类型，使其不可见，实际使用过程中可用malloc申请一个指向无名存储块的指针获得 allocbuf中使用指针allocp指向下一块可用空间：如果空间够，则alloc()返回allocp的值，不够则返回0 如果p在allocbuf边界之内，则afree(p)仅仅是将allocp的值设置为p 源码1234567891011121314151617#define ALLOCSIZE 10000static char allocbuf[ALLOCSIZE]; static char *allocp = allocbuf;char *alloc(int n)&#123; if(allocbuf + ALLOCSIZE-allocp &gt;=n)&#123; allocp += n; return allocp - n; &#125;else return 0;&#125;void afree(char *p)&#123; if( q &gt;= allocubuf &amp;&amp; p &lt; allocbuf + ALLOCSZIE) alloc = p;&#125; continue……","categories":[],"tags":[{"name":"C源码","slug":"C源码","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/C源码/"}]},{"title":"String","slug":"String","date":"2018-10-21T14:30:41.000Z","updated":"2019-07-08T15:55:50.572Z","comments":true,"path":"2018/10/21/String/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/21/String/","excerpt":"This is a blog to show SString.","text":"This is a blog to show SString. StringSString12345678910111213141516171819#define MAXSTRLEN 255 //用户可在255以内定义最大串长 typedef unsigned char SString[MAXSTRLEN + 1]; //0号单元存放串的长度 typedef int Status;void StrPrint(SString T) ; // 输出字符串TStatus StrAssign(SString &amp;T,char chars[]); //生成一个其值等于chars的串T Status StrCopy(SString &amp;T,SString S); //由串S赋值得串TStatus ClearString(SString &amp;S); //将串置空Status StrDestory(SString &amp;T); //销毁Status StrEmpty(SString S); //判空int StrCompare(SString S,SString T); //S&gt;T 返回&gt;0 S=T 返回0 S&lt;T 返回&lt;0int StrLength(SString S); //返回串长度Status Concat(SString &amp;T,SString S1,SString S2); //连接串 S1S2 未截断返回 1 截断返回 0 Status SubString(SString &amp;Sub,SString S,int pos,int len); //用Sub返回串S的自第pos个字符起长度为len的子串int Index(SString S,SString T,int pos); //返回子串T在主串S中第pos个字符之后的位置 若不存在，则函数值为0Status StrInsert(SString &amp;S,int pos,SString T); //在串S的第pos个字符前插入串T 完全插入返回1 部分插入返回0Status StrDelete(SString S,int pos,int len) ; // 从串S中删除自第pos个字符起长度为len的子串Status Replace(SString &amp;S,SString T,SString V); //用V替换主串S中出现的所有与T相等的不重叠的子串 StrPrint12345678// 输出字符串Tvoid StrPrint(SString T) &#123; int i; for(i=1;i&lt;=T[0];i++) printf(\"%c\",T[i]); printf(\"\\n\"); &#125; StrAssign 12345678910111213141516//生成一个其值等于chars的串T Status StrAssign(SString &amp;T,char chars[])&#123; int i; if(strlen(chars) &gt; MAXSTRLEN)&#123; printf(\"&gt;串长超过最大串长\"); return ERROR; &#125;else&#123; T[0] = strlen(chars); //T[0]存放串长度 for(i=1 ; i&lt;=T[0] ; i ++) T[i] = *(chars+i-1); //逐个赋值 return OK; &#125; &#125; StrCopy 123456789//由串S赋值得串TStatus StrCopy(SString &amp;T,SString S)&#123; int i; for(i=0 ; i&lt;=S[0] ; i++) //赋值(带0一起复制) T[i] = S[i]; return OK; &#125; ClearString123456//将串置空Status ClearString(SString &amp;S)&#123; S[1] = '\\0'; S[0] = 0;&#125; StrDestory123456//销毁Status StrDestory(SString &amp;T)&#123; ClearString(T); return OK;&#125; StrEmpty123456789//判空Status StrEmpty(SString S)&#123; if(S[0] == 0) //0号存储字符串长度 return TRUE; else return FALSE; &#125; StrCompare1234567891011//S&gt;T 返回&gt;0 S=T 返回0 S&lt;T 返回&lt;0int StrCompare(SString S,SString T)&#123; int i; for( i=1 ; i&lt;=S[0]&amp;&amp;i&lt;=T[0] ; i++ ) if(S[i] != T[i]) //不相等 返回ascll码差值 return S[i] - T[i]; return S[0] - T[0]; //包含关系 返回长度差值 &#125; StrLength12345//返回串长度int StrLength(SString S)&#123; return S[0];&#125; Concat 1234567891011121314151617181920212223242526//连接串 S1S2 未截断返回 1 截断返回 0 Status Concat(SString &amp;T,SString S1,SString S2)&#123; int i,j; if( S1[0] + S2[0] &lt;= MAXSTRLEN)&#123; //未截断 T[0] = S1[0] + S2[0]; for( i=1 ; i &lt;= S1[0] ; i++ ) //连接S1 T[i] = S1[i]; for( j=1 ; j &lt;= S2[0] ; j++ ) //连接S2 T[i++] = S2[j]; return OK; &#125;else&#123; //截断 for( i=1 ; i &lt;= S1[0] ; i++ ) //连接S1 T[i] = S1[i]; for( j=1 ; i &lt;= MAXSTRLEN ; j++ ) //连接S2 T[i++] = S2[j]; T[0] = MAXSTRLEN; return FALSE; &#125;&#125; SubString 12345678910111213//用Sub返回串S的自第pos个字符起长度为len的子串Status SubString(SString &amp;Sub,SString S,int pos,int len)&#123; int i; if( pos&lt;1 || pos&gt;S[0] || len&lt;0 || len&gt;S[0]-pos+1) //条件错误 return ERROR; for( i=1 ; i&lt;=len ; i++) //赋值 Sub[i] = S[pos+i-1]; Sub[0] = len; return OK;&#125; Index1234567891011121314151617181920//返回子串T在主串S中第pos个字符之后的位置 若不存在，则函数值为0。 int Index(SString S,SString T,int pos)&#123; //算法改进 --查找字符串 (KMP) int i,n,m; SString sub; if( 1&lt;=pos &amp;&amp; pos&lt;=S[0])&#123; //位置合理 n = S[0]; m = T[0]; i = pos; while( i &lt;= n-m+1 )&#123; SubString(sub,S,i,m); if(StrCompare(sub,T) != 0) i++; else return i; &#125; &#125; return 0;&#125; StrInsert 1234567891011121314151617181920212223//在串S的第pos个字符前插入串T 完全插入返回1 部分插入返回0 Status StrInsert(SString &amp;S,int pos,SString T)&#123; int i; if( pos&lt;1 || pos&gt;S[0]+1 ) //插入位置(1-S[0]+1) return ERROR; if(S[0]+T[0]&lt;=MAXSTRLEN)&#123; //完全插入 for( i=S[0]; i&gt;=pos ;i-- ) S[i+T[0]] = S[i]; //插入点后面的字符串向后位移Strlen(T) for( i=pos; i&lt;pos+T[0] ; i++) S[i] = T[i-pos+1]; S[0] += T[0]; return OK; &#125;else&#123; //部分插入 for( i=MAXSTRLEN;i&gt;=pos+T[0];i--) S[i] = S[i-T[0]]; for( i=pos;i&lt;pos+T[0] &amp;&amp; i&lt;=MAXSTRLEN;i++ ) S[i] = T[i-pos+1]; S[0] = MAXSTRLEN; return FALSE; &#125;&#125; StrDelete 1234567891011// 从串S中删除自第pos个字符起长度为len的子串Status StrDelete(SString S,int pos,int len)&#123; int i; if( pos&lt;1 || pos&gt;S[0]-len+1 || len&lt;0) return ERROR; for( i=pos+len ; i&lt;=S[0];i++) S[i-len] = S[i]; S[0] -= len; return OK;&#125; Replace123456789101112131415161718192021222324//用V替换主串S中出现的所有与T相等的不重叠的子串 Status Replace(SString &amp;S,SString T,SString V)&#123; int i =1; //第一个位置开始查找 Status k; if(StrEmpty(T)) //T为空串 return ERROR; while(i)&#123; i = Index(S,T,i); if(i)&#123; StrDelete(S,i,StrLength(T)); k = StrInsert(S,i,V); if(!k) return ERROR; i += StrLength(V); &#125; &#125; return OK; &#125; Test12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void text()&#123; int i,j; Status k; char s,c[MAXSTRLEN]; SString t,s1,s2,s3,s4,s5,s6,s7; printf(\"请输入串s1: \"); gets(c); k=StrAssign(s1,c); printf(\"串长为%d 串空否？%d(1:是0:否)\\n\",StrLength(s1),StrEmpty(s1)); StrCopy(s3,s1); printf(\"拷贝s1生成的串为\"); StrPrint(s3); printf(\"请输入串s2: \"); gets(c); k=StrAssign(s2,c); StrPrint(s2); Concat(t,s1,s2); printf(\"连接s1s2为t：\"); StrPrint(t); SubString(s4,t,2,4); printf(\"t的字串 2-4 为：\"); StrPrint(s4); StrDelete(t,3,3); printf(\"删除t的字串 3-3后：\"); StrPrint(t); printf(\"请输入插入串: \"); gets(c); k=StrAssign(s5,c); StrInsert(t,3,s5); printf(\"在第三个位置插入后t为：\"); StrPrint(t); printf(\"请输入替换串: \"); gets(c); k=StrAssign(s6,c); printf(\"请输入要替换串: \"); gets(c); k=StrAssign(s7,c); Replace(t,s7,s6); printf(\"替换后t为：\"); StrPrint(t);&#125;int main()&#123; SString T,S; char chars[] = \"this is\"; text(); return 0;&#125; HString1234typedef struct&#123; char * ch; int length;&#125;HString; 123456Status StrAssign(HString &amp;T,char *chars); //生成一个其值等于串常量chars的串Tint StrLength(HString S); //返回S元素个数 即串S的长度int StrCompare(HString S,HString T); //S&gt;T 返回大于0 S&lt;T 返回小于0Status ClearString(HString &amp;S); //将S变为空串 并释放S所占空间Status Concat(HString &amp;T,HString S1,HString S2); //T返回S1与S2连接而成的串Status SubString(HString &amp;Sub,HString S,int pos,int len); //返回串S第pos个元素起长度为len的字串 StrAssign123456789101112131415161718192021//生成一个其值等于串常量chars的串TStatus StrAssign(HString &amp;T,char *chars)&#123; int i,j; char *c; if(T.ch) //释放T原有空间 free(T.ch); for(i=0,c=chars;*c;i++,c++) ; //求chars长度 if(!i)&#123; T.ch = NULL; T.length = 0; &#125; else&#123; if(!(T.ch = (char*)malloc(i*sizeof(char)))) //申请失败 return ERROR; for(j=0 ; j&lt;i ; j++) //复制 T.ch[j] = chars[j]; &#125; return OK;&#125; StrLength1234//返回S元素个数 即串S的长度int StrLength(HString S)&#123; return S.length; &#125; StrCompare123456789//S&gt;T 返回大于0 S&lt;T 返回小于0int StrCompare(HString S,HString T)&#123; int i; for(i=0 ; i&lt;S.length &amp;&amp; i&lt;T.length ; i++) if(S.ch[i] != T.ch[i]) return S.ch[i] - T.ch[i]; return S.length - T.length;&#125; ClearString123456789//将S变为空串 并释放S所占空间Status ClearString(HString &amp;S)&#123; if(S.ch)&#123; free(S.ch); S.ch = NULL; &#125; S.length = 0; return OK;&#125; Concat123456789101112131415161718//T返回S1与S2连接而成的串Status Concat(HString &amp;T,HString S1,HString S2)&#123; int i,j; if(T.ch) free(T.ch); if(!(T.ch = (char*)malloc((S1.length+S2.length)*sizeof(char)))) return ERROR; for( i=0 ; i&lt;S1.length ; i++) T.ch[i] = S1.ch[i]; for( j=0 ; j&lt;S2.length ; j++) T.ch[i++] = S2.ch[j]; T.length = S1.length + S2.length; return OK;&#125; SubString12345678910111213141516171819202122//返回串S第pos个元素起长度为len的字串 Status SubString(HString &amp;Sub,HString S,int pos,int len)&#123; int i; if( pos&lt;1 || pos&gt;S.length || len&lt;0 || len&gt;S.length-pos+1 ) //条件错误 return ERROR; if(Sub.ch) //释放Sub原有空间 free(Sub.ch); if(!len)&#123; //字串长度为0 Sub.ch = NULL; Sub.length = 0; &#125;else&#123; Sub.ch = (char*)malloc(len*sizeof(char)); for( i=0 ; i&lt;len ; i++ ) //复制 Sub.ch[i] = Sub.ch[i+pos-1]; Sub.length = len; &#125;&#125; text1234int main()&#123; return 0;&#125;","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://Est-C.coding.me/Est-C.coding.me/categories/DataStructure/"}],"tags":[{"name":"String","slug":"String","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/String/"}]},{"title":"Queue","slug":"Queue","date":"2018-10-19T14:48:58.000Z","updated":"2018-11-05T16:18:49.541Z","comments":true,"path":"2018/10/19/Queue/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/19/Queue/","excerpt":"This is a blog to show SqQueue and LinkQueue.","text":"This is a blog to show SqQueue and LinkQueue. QueueSqQueue顺序队列有八个操作：初始化、判空、销毁、置空、求长、获取队头、入队、出队 123456789#define QUEUE_INIT_SIZE 100 //栈的大小#define STACKINCREMENT 10 //栈的增量typedef struct&#123; //栈的结构体 QElemType * base; QElemType front; QElemType rear; int queuesize;&#125;SqQueue; 初始化12345678910111213141516//初始化Status InitQueue(SqQueue &amp;Q)&#123; Q.base = (QElemType *)malloc(QUEUE_INIT_SIZE * sizeof(QElemType)); //分配空间 if(!Q.base)&#123; //判断是否申请成功 Q.queuesize = 0; return ERROR; &#125; Q.rear = 0; Q.front = 0; Q.queuesize = QUEUE_INIT_SIZE; return OK;&#125; 判空12345678//判断是否为空队列 Status QueueEmpty(SqQueue &amp;Q)&#123; if(Q.front == Q.rear) return TRUE; else return FALSE;&#125; 销毁123456//销毁Status DestroyQueue(SqQueue &amp;Q)&#123; free(Q.base); return OK; &#125; 置空123456//置为空队列 Status ClearEmpty(SqQueue &amp;Q)&#123; Q.front = Q.rear ; return OK;&#125; 求长12345//求队列的长度int QueueLength(SqQueue &amp;Q)&#123; return (Q.rear-Q.front+Q.queuesize) % Q.queuesize;&#125; 返回队头12345678910//返回队列头元素Status GetTop(SqQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) return ERROR; e = Q.base[Q.front]; return OK;&#125; 入队123456789//对尾插入Status EnQueue(SqQueue &amp;Q,QElemType e)&#123; Q.base[Q.rear] = e; //压栈 Q.rear = (Q.rear + 1) % Q.queuesize; return OK;&#125; 出队123456789101112//队头删除Status DeQueue(SqQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) //判空 return ERROR; e = Q.base[Q.front]; //出栈 Q.front = (Q.front + 1) % Q.queuesize; return OK;&#125; 输出123456789101112//遍历Status QueueTraverse(SqQueue Q)&#123; if(QueueEmpty(Q)) //判空 return ERROR; while(Q.front != Q.rear) printf(\"%d \",Q.base[Q.front++]); //输出 printf(\"\\n\"); return OK;&#125; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//textvoid text()&#123; SqQueue Q; QElemType e; InitQueue(Q); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLength(Q)); //队列插入为1 2 3 4 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); //删除对头 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLength(Q)); if(QueueEmpty(Q)) printf(\"栈空\\n\"); else printf(\"栈不空\\n\"); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLength(Q)); ClearEmpty(Q); //置空 QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLength(Q));&#125;int main()&#123; text(); return 0;&#125; LinkQueue123456789typedef struct QNode&#123; //队列结点 QElemType data; //数据域 struct QNode *next; //指针 &#125;QNode, *QueuePtr;typedef struct&#123; //队列指针 QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 &#125;LinkQueue; 初始化123456789101112//初始化Status InitQueue(LinkQueue &amp;Q)&#123; Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); //申请结点 if(!Q.front) //是否申请成功 return ERROR; Q.front -&gt; next = NULL; return OK;&#125; 销毁12345678910//销毁队列Status DestoryQueue(LinkQueue &amp;Q)&#123; while(Q.front)&#123; Q.rear = Q.front -&gt; next; free(Q.front); Q.front = Q.rear; &#125; &#125; 清空123456//请空队列Status ClearQueue(LinkQueue &amp;Q)&#123; Q.rear = Q.front; Q.front -&gt; next =NULL; return OK;&#125; 判空1234567//判空Status QueueEmpty(LinkQueue &amp;Q)&#123; if(Q.front == Q.rear) return TRUE; else return FALSE;&#125; 求长12345678910111213//求队列元素个数int QueueLenght(LinkQueue &amp;Q)&#123; QueuePtr p = Q.front -&gt; next; int iCount=0; while(p)&#123; iCount++; p = p -&gt; next; &#125; return iCount;&#125; 返回队头12345678910//返回队头Status GetHead(LinkQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) return ERROR; e = Q.front -&gt; next -&gt; data; return OK;&#125; 入队12345678910111213141516//插入元素Status EnQueue(LinkQueue &amp;Q,QElemType e)&#123; QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); if(!p) return ERROR; p -&gt; next = NULL; p -&gt; data = e; Q.rear -&gt; next = p; Q.rear = p; return OK;&#125; 出队1234567891011121314151617//删除元素Status DeQueue(LinkQueue &amp;Q,QElemType &amp;e)&#123; if(QueueEmpty(Q)) return ERROR; QueuePtr p = Q.front -&gt; next; e = p -&gt; data; Q.front -&gt; next = p -&gt; next; if(Q.rear == p) Q.rear = Q.front; free(p); return OK;&#125; 输出123456789101112//遍历Status QueueTraverse(LinkQueue Q)&#123; Q.front = Q.front -&gt; next; while(Q.front)&#123; printf(\"%d \",Q.front-&gt;data); Q.front = Q.front -&gt; next; &#125; printf(\"\\n\"); return OK;&#125; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//textvoid text()&#123; LinkQueue Q; QElemType e; InitQueue(Q); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLenght(Q)); //队列插入为1 2 3 4 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); //删除对头 DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); DeQueue(Q,e); QueueTraverse(Q); printf(\"出队元素为：%d\",e); printf(\" 队列长度为：%d\\n\",QueueLenght(Q)); if(QueueEmpty(Q)) printf(\"栈空\\n\"); else printf(\"栈不空\\n\"); e = 1; EnQueue(Q,e); e = 2; EnQueue(Q,e); e = 3; EnQueue(Q,e); e = 4; EnQueue(Q,e); QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLenght(Q)); ClearQueue(Q); //置空 QueueTraverse(Q); printf(\"队列长度为：%d\\n\",QueueLenght(Q)); &#125; int main()&#123; text(); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"Stack","slug":"Stack","date":"2018-10-18T16:19:10.000Z","updated":"2018-11-05T16:16:30.372Z","comments":true,"path":"2018/10/19/Stack/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/19/Stack/","excerpt":"This is a blog to show SqStack and LinkStack.","text":"This is a blog to show SqStack and LinkStack. StackSqStack12345678#define STACK_INIT_SIZE 100 //栈的大小#define STACKINCREMENT 10 //栈的增量typedef struct&#123; //栈的结构体 SElemType * base; //栈底指针 SElemType * top; //栈顶指针 int stacksize; //栈大小 &#125;SqStack; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/* 栈的顺序存储结构*///初始化Status InitStack(SqStack &amp;S)&#123; S.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType)); //分配空间 if(!S.base)&#123; //判断是否申请成功 S.stacksize = 0; return ERROR; &#125; S.top = S.base; S.stacksize = STACK_INIT_SIZE; //更新栈 return OK;&#125;//判断是否为空栈Status StackEmpty(SqStack S)&#123; if(S.base == S.top) return TRUE; else return FALSE;&#125;//销毁Status DestroyStack(SqStack &amp;S)&#123; free(S.base); free(S.top); S.base = NULL; S.top = NULL; return OK; &#125;//置为空栈Status ClearEmpyt(SqStack &amp;S)&#123; S.base = S.top; return OK;&#125;//求栈的长度int StackLength(SqStack &amp;S)&#123; return S.top-S.base;&#125;//返回栈顶元素Status GetTop(SqStack S,SElemType &amp;e)&#123; if(S.base==S.top) return ERROR; e = *(S.top-1); return OK;&#125;//栈顶插入Status Push(SqStack &amp;S,SElemType e)&#123; if(S.top - S.base &gt;= S.stacksize)&#123; //栈满 S.base = (SElemType *)realloc(S.base,(S.stacksize+STACKINCREMENT)*sizeof(SElemType)); //申请新空间 if(!S.base)&#123; printf(\"空间申请失败！\"); return ERROR; &#125; S.top = S.base + S.stacksize; //更新栈顶指针 S.stacksize += STACKINCREMENT; //更新长度 &#125; *S.top++ = e; //压栈 return OK;&#125;//栈顶删除Status Pop(SqStack &amp;S,SElemType &amp;e)&#123; if(S.base == S.top) //判空 return ERROR; e = *--S.top; //出栈 return OK;&#125;//遍历Status StackTraverse(SqStack S)&#123; if(StackEmpty) //判空 return ERROR; while(S.base &lt; S.top) printf(\"%c \",*(S.base++)); //输出 printf(\"\\n\"); return OK;&#125;int main()&#123; return 0;&#125; LinkStack123456789typedef struct StackNode&#123; SElemType data; //数据域 struct StackNode *next; //结构体指针 &#125;StackNode , *LinkStackPtr;typedef struct LinkStack&#123; //栈指针 LinkStackPtr top; //top指针 int count; //栈元素个数 &#125;LinkStack; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//初始化Status InitStack(LinkStack &amp;S)&#123; S.top = (LinkStackPtr)malloc(sizeof(StackNode)); //申请空间 S.count = 0; if(!S.top) //是否申请成功 return ERROR; S.top-&gt;next = NULL; //头结点指向NULL (栈底) return OK;&#125;//判空Status StackEmpty(LinkStack &amp;S)&#123; return S.count == 0 ? TRUE : FALSE;&#125; //入栈Status Push(LinkStack &amp;S , SElemType e)&#123; LinkStackPtr p = (LinkStackPtr)malloc(sizeof(StackNode)); //申请新节点 p -&gt; data = e; p -&gt; next = S.top; //结点赋值 S.top = p; S.count++; //更改链表关系 return OK;&#125;//出栈Status Pop(LinkStack &amp;S,SElemType &amp;e)&#123; if(StackEmpty(S))&#123; //是否栈空 printf(\"栈空！！！\"); return ERROR; &#125; LinkStackPtr p = S.top; //p指向栈顶 e = p-&gt;data; S.top = S.top -&gt; next; S.count--; //更新链表关系 free(p); return OK;&#125; //返回栈顶Status GetStack(LinkStack &amp;S,SElemType &amp;e)&#123; if(StackEmpty(S))&#123; printf(\"栈空！！！\"); return ERROR; &#125; e = S.top -&gt; data; return OK;&#125; //获取长度int GetLengthLinkStack(LinkStack &amp;S)&#123; return S.count; &#125; //输出Status Stacktraverse(LinkStack &amp;S)&#123; if(!S.top &amp;&amp; S.count) return ERROR; LinkStackPtr p = S.top; while(p-&gt;next)&#123; printf(\"%d\",p-&gt;data); p = p -&gt; next; &#125; return OK; &#125; //textvoid text()&#123; LinkStack S; SElemType e; LinkStack stack; InitStack(S);//初始化 e=1; Push(S, e); e=2; Push(S, e); e=3; Push(S, e); e=4; Push(S, e); printf(\"链栈元素：\"); Stacktraverse(S); printf(\"链栈元素个数：%d\\n\", GetLengthLinkStack(S)); SElemType e1,e2,e3; Pop(S,e1); printf(\"弹出第一个元素：%d\\n\", e1); Pop(S,e2); printf(\"弹出第二个元素：%d\\n\", e2); Pop(S,e3); printf(\"弹出第二个元素：%d\\n\", e3); printf(\"链栈元素：\"); Stacktraverse(S); printf(\"链栈元素个数：%d\", GetLengthLinkStack(S)); printf(\"\\n\"); GetStack(S,e3); printf(\"$%d\",e3);&#125; int main()&#123; text(); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]},{"title":"List","slug":"List","date":"2018-10-15T14:16:42.000Z","updated":"2018-11-05T16:14:46.644Z","comments":true,"path":"2018/10/15/List/","link":"","permalink":"https://Est-C.coding.me/Est-C.coding.me/2018/10/15/List/","excerpt":"This is a blog to show SqList LinkStack and StaticStack.","text":"This is a blog to show SqList LinkStack and StaticStack. ListSqList12345678#define LIST_INIT_SIZE 100 //线性表大小 #define INIT_INCREMENT 10 //线性表增量typedef struct&#123; ElemType *elem; int length; int listSize;&#125;SqList; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383//判断元素是否存在 存在返回i的值Status compare(ElemType e1 , ElemType e2)&#123; if( e1 == e2 ) return TRUE; else return FALSE;&#125;//访问每一个元素 Status visit(ElemType e)&#123; printf(\"%d \",e); return OK;&#125;//初始化线性表 Status InitList_Sq(SqList &amp;L)&#123; L.elem = (ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType)); //动态分配空间 L.length = 0; //先令线性表长度为0 即使初始化失败L.length也有明确的值 if(!L.elem)&#123; printf(\"初始化失败\"); return ERROR; //分配失败 返回ERROR &#125; L.listSize = LIST_INIT_SIZE; //线性表d大小 return OK; &#125;//销毁线性表 Status DestoryList_Sq(SqList &amp;L)&#123; free(L.elem); //释放申请来的空间 return OK; &#125; //清空线性表 Status ClearList_Sq(SqList &amp;L)&#123; L.length = 0; //长度变为0 return OK;&#125;//判空表 空返回TRUE 否则FALSE Status ListEmpty_Sq(SqList &amp;L)&#123; return L.length ? TRUE : FALSE ; //长度为0则为空表 &#125; //求线性表长度Status ListLength_Sq(SqList &amp;L)&#123; if(L.length == 0)&#123; printf(\"线性表为空！\"); return ERROR; &#125; return L.length; //返回长度 &#125; //用e返回第i个元素值Status GetElem_Sq(SqList &amp;L,int i,ElemType &amp;e)&#123; if( L.length == 0 || i&lt;1 || i&gt;L.length)&#123; printf(\"输入元素的位置有误\"); return ERROR; &#125; e = L.elem[i-1]; return OK;&#125;//操作结果：返回L中第1个与e满足compare()的数据元素的位序，若这样的数据元素不存在，则返回值为0。Status LocateElem_Sq(SqList &amp;L,ElemType &amp;e)&#123; int i=0; while( i&lt;L.length &amp;&amp; !compare(L.elem[i],e) ) i++; if(compare(L.elem[i],e)) return i; else return 0;&#125;//操作：cur_e是L的元素且不会是第一个 则用pre_e返回他的前驱Status PriorElem_Sq(SqList &amp;L,ElemType cur_e,ElemType &amp;pre_e)&#123; int i = LocateElem_Sq(L,cur_e); //获取cur_e的位置 if(i == 0) printf(\"cur_e不在L中或为首元素\"); else pre_e = L.elem[i-1]; return OK;&#125;//cur_e是L的元素且不会是最后一个 则用next_e返回他的后继Status NextElem_Sq(SqList &amp;L,ElemType cur_e,ElemType &amp;next_e)&#123; int i = LocateElem_Sq(L,cur_e); //获取cur_e的位置 if(i == 0)&#123; printf(\"该元素不在线性表中\"); return ERROR; &#125;else if(i == L.length)&#123; printf(\"该元素为末元素\"); return ERROR; &#125;else next_e = L.elem[i+1]; return OK;&#125;//在L的第i个位置之前插入新元素Status ListInsert_Sq(SqList &amp;L, int i ,ElemType e)&#123; //i的合法值为 1-L.length+1 if(i&lt;1 || i&gt;L.length+1)&#123; printf(\"插入的位置有问题\"); return ERROR; //i值不合法 &#125; //若线性表已满 则分配空间 if(L.length&gt;=L.listSize)&#123; ElemType *newbase = (ElemType*)realloc(L.elem,(L.listSize+INIT_INCREMENT)*sizeof(ElemType)); //增加分配空间 if(!newbase)&#123; printf(\"存储分配失败\"); return ERROR; //是否成功分配 &#125; L.elem = newbase; L.listSize += INIT_INCREMENT; //更改长度 &#125; ElemType *p = &amp;(L.elem[i-1]); //p为插入点指针 ElemType *q = &amp;(L.elem[L.length-1]); //q为最后一个元素指针 while(p&lt;=q)&#123; //插入 *(q+1) = *q; q--; &#125; *p = e; L.length++; return OK;&#125; //删除第i个元素 用e返回 L长度减1Status ListDelete_Sq(SqList &amp;L,int i,ElemType &amp;e)&#123; if(i&gt;L.length || i&lt;1)&#123; //删除元素有误 printf(\"被删除元素位置有误\"); return ERROR; &#125; ElemType *p = &amp;(L.elem[i-1]); //p指向被删除元素 e = *p; ElemType *q = &amp;(L.elem[L.length-1]); //q指向末元素 while(p&lt;q)&#123; //删除 *p = *(p+1); p++; &#125; L.length--; return OK; &#125; //输出线性表 Status ListTraverse_Sq(SqList &amp;L)&#123; if(!L.elem)&#123; printf(\"\\n线性表未初始化或被销毁了!!!\"); return ERROR; &#125; if(L.length==0)&#123; printf(\"线性表中无元素!!!\"); return ERROR; &#125; int i; for( i = 0 ; i &lt;L.length ; i++) visit(L.elem[i]); return OK;&#125;//textvoid initMenu(SqList L) &#123; printf(\"\\n\\t\\t\\*------------------------------------------*\\n\"); printf(\"\\n\\t\\t 初始化成功，L.length=%d\\n\", L.length); printf(\"\\n\\t\\t 1.创建随机链表\\t 2.遍历线性表\\n\\t\\t 3.清空线性表\\t\\t 4.线性表插入\\n\\t\\t 5.查找表中元素\"); printf(\"\\t 6.判断元素是否在表中\\n\\t\\t 7.删除某个元素\\t 8.线性表长度\\n\\t\\t 9.线性表是否为空\\t 10.回到主菜单\\n\\t\\t 0.退出\");&#125;void mainMenu() &#123; printf(\"\\n\\t\\t*------------------------------------------*\\n\"); printf(\"\\n\\t\\t 欢迎回到主菜单\\n\"); printf(\"\\n\\t\\t 1.创建随机链表\\t 2.遍历线性表\\n\\t\\t 3.清空线性表\\t\\t 4.线性表插入\\n\\t\\t 5.查找表中元素\"); printf(\"\\t 6.判断元素是否在表中\\n\\t\\t 7.删除某个元素\\t 8.线性表长度\\n\\t\\t 9.线性表是否为空\\t 10.回到主菜单\\n\\t\\t 0.退出\");&#125;void text()&#123; int lLength, i; ElemType e; SqList L; InitList_Sq(L); initMenu(L); int select; while(1) &#123; printf(\"\\n请选择你的操作：\"); scanf(\"%d\", &amp;select); switch(select) &#123; case 1: InitList_Sq(L); printf(\"创建随机链表：\"); ListTraverse_Sq(L); break; case 2: printf(\"遍历线性表：\"); ListTraverse_Sq(L); break; case 3: ClearList_Sq(L); printf(\"清空L后：L.length = %d\\n\", L.length); ListTraverse_Sq(L); break; case 4: printf(\"请输入要插入的元素位置和元素的值(eg:1 2)：\"); scanf(\"%d %d\", &amp;i, &amp;e); while(ListInsert_Sq(L, i, e)) &#123; printf(\"插入完毕，现在线性表为：\"); ListTraverse_Sq(L); printf(\" 是否继续？ 1.是 0.否 \"); int selectAgain ; scanf(\"%d\", &amp;selectAgain); if(selectAgain==0) break; printf(\"请输入要插入的元素位置和元素的值：\"); scanf(\"%d %d\", &amp;i, &amp;e); &#125; printf(\"\\n\"); break; case 5: printf(\"请输入要查找的元素位置：\"); scanf(\"%d\",&amp;i); if(GetElem_Sq(L, i, e)) printf(\"第%d个元素的值为：%d\\n\", i, e); else printf(\"请输入正确的数字！！！\\n\"); break; case 6: printf(\"请输入你想知道是否在表中的数值：\"); scanf(\"%d\", &amp;e); // 这里假定随机数组中的元素互不重复 i = LocateElem_Sq(L, e); if(i) printf(\"值为%d是表中的第%d个元素\\n\", e, i); else printf(\"没有值为%d的元素\\n\", e); break; case 7: printf(\"请输入要删除的元素位置：\"); scanf(\"%d\", &amp;i); if(ListDelete_Sq(L, i, e))&#123; printf(\"元素%d删除完毕，现在线性表为：\\n\", e); ListTraverse_Sq(L); &#125;else printf(\"\\n\"); break; case 8: lLength = ListLength_Sq(L); printf(\"线性表的长度为: %d \\n\", lLength); break; case 9: if (!ListEmpty_Sq(L)) printf(\"该线性表为空.\\n\"); else printf(\"该线性表非空.\\n\"); break; case 10: mainMenu(); break; case 0: break; default: printf(\"请输入正确的数字!!!\\n\"); break; &#125; &#125; &#125; int main() &#123; text(); return 0;&#125; LinkList1234567891011121314151617181920/* 自定义结点类型指针 结点包括数据项date和指向（struct LNode）的指针 Link Position为指向结点的指针类型 */typedef struct LNode&#123; ElemType date; struct LNode *next;&#125;*Link , *Position; /* 自定义指针结构指针 head tail是Link类型指针 用来指向结点 len存储链表长度 */ typedef struct List&#123; Link head,tail; //分别指向头尾 int len = 0; //长度 &#125;LinkList; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603/*//初始化一个空的线性链表L Status InitList_L(LinkList &amp;L)&#123; L.head = (Link)malloc(sizeof(struct LNode)); if(!L.head)&#123; printf(\"分配空间失败\"); return ERROR; &#125; L.head-&gt;next = NULL; return OK;&#125;*///分配p指向e的结点Status MakeNode_L(Link p,ElemType e)&#123; p = (Link)malloc(sizeof(struct LNode)); if(p != NULL)&#123; p -&gt; date = e; p -&gt; next = NULL; return OK; &#125; return ERROR;&#125; //释放p指向的结点Status FreeNode_L(Link &amp;p)&#123; free(p); p = NULL; return OK;&#125; //创建指定长度单链表Status CreateList_L(LinkList &amp;L,int n)&#123; L.head = L.tail = (Link)malloc(sizeof(struct LNode)); L.head -&gt; next = NULL; //建立一个带头节点的单链表 if(!L.head)&#123; printf(\"&gt;&gt;初始化失败！\"); return ERROR; &#125; Link q = L.head ; //p指向头节点 printf(\"&gt;&gt;输入链表的值：\"); while(n--)&#123; Link p = (Link)malloc(sizeof(struct LNode)); //申请一个新结点 scanf(\"%d\",&amp;p-&gt;date); //输入数据 q -&gt; next = p; //插入到表尾 q = p; L.len++ ; //长度+1 &#125; L.tail = q; L.tail-&gt;next = NULL; printf(\"&gt;&gt;初始化成功！\\n\"); return OK; &#125; //销毁线性表LStatus DestroyList_L(LinkList &amp;L)&#123; Link p; while(L.head != L.tail)&#123; //头结点开始 依次释放结点 p = L.head; L.head = L.head -&gt; next; FreeNode_L(p); &#125; L.head = NULL; L.tail = NULL; //防止野指针 L.len = 0; return OK; &#125;//清空线性表Status ClearList_L(LinkList &amp;L)&#123; if(L.len == 0) return OK; Link p,q; p = L.head -&gt; next; while(p)&#123; q = p -&gt; next; FreeNode_L(p); p = q; L.len--; &#125; L.head -&gt; next = L.tail; printf(\"&gt;&gt;清空成功!\\n\"); return OK;&#125;//在链表的第一个位置插入节点，h指向头结点Status InsFirst_L(Link h,Link s)&#123; s-&gt;next = h-&gt;next; h-&gt;next = s; return OK;&#125;//在删除链表中第一个节点并以p返回，h为头结点指针Status DelFirst_L(Link h,Link p)&#123; p = h-&gt;next; h-&gt;next = h-&gt;next-&gt;next; return OK;&#125;//将s所指的一串结点连接在线性表L的最后一个结点Status Append_L(LinkList &amp;L,Link s)&#123; if(L.head)&#123; L.tail -&gt; next = s; Link temp = L.head; while(temp -&gt; next) temp = temp -&gt; next; L.tail = temp; //L.tail指向最后一个结点temp-&gt;next==NULL return OK; &#125; return ERROR;&#125; //第i个元素存在时，将第i个元素赋值个e并返回OK 否则返回ERROR Status GetELem_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(i&lt;1) &#123; //输入值有误 printf(\"&gt;&gt;输入值有误!\"); return ERROR; &#125; int j; Link p = L.head -&gt; next; while( j &lt; i &amp;&amp; p)&#123; //j&lt;i且p不为空 找到第i个元素 p = p -&gt; next; j++; &#125; if( !p || j&gt;i )&#123; printf(\"第%d个元素不存在\",i); return ERROR; &#125; e = p -&gt; date; //e返回第i个元素的值 return OK; &#125; //在第i个元素之前插入元素eStatus InsBefore_L(LinkList &amp;L,int i,ElemType e) &#123; Link s; Link p = L.head; int j = 0; while( p &amp;&amp; j &lt; i-1)&#123; //找到第i-1个元素 并将p指向 p = p-&gt; next; j++; &#125; if( !p || j &gt; i-1 ) &#123; //输入值有误 printf(\"&gt;&gt;输入插入点有误！\"); return ERROR; &#125; s = (Link)malloc(sizeof(struct LNode)); //插入 s -&gt; date = e; s -&gt; next = p -&gt; next; p -&gt; next = s; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //更新长度 return OK; &#125;//向线性表末尾添加一个元素Status InsertRear_L(LinkList &amp;L, ElemType e)&#123; Link p = L.tail; //p指向表尾 Link q = (Link)malloc(sizeof(struct LNode)); //新建结点 q -&gt; date = e; q -&gt; next = p -&gt; next; //插入 p -&gt; next = q; p = p -&gt; next; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //长度+1 return OK;&#125; //向有序链表插入一个元素 使之依然有序Status InsertOrder_L(LinkList &amp;L,ElemType e)&#123; Link p = L.head -&gt; next; //p指向第一个结点 Link q = L.head; //q指向p的上一个结点 if( (p-&gt;date) &gt; (p-&gt;next-&gt;date) )&#123; //判断有序还是逆序 while(p &amp;&amp; p-&gt;date &gt; e)&#123; q = p; p = p-&gt;next; &#125; &#125;else&#123; while( p &amp;&amp; p-&gt;date &lt; e)&#123; q = p; p = p-&gt;next; &#125; &#125; //此时p指向插入点 q指向插入点的上一个结点 Link z = (Link)malloc(sizeof(struct LNode)); //新建结点 z -&gt; date = e; z -&gt; next = q -&gt; next; q -&gt; next = z; printf(\"&gt;&gt;插入成功！\\n\"); L.len++; //长度+1 return OK;&#125; //删除第i个元素 并用e返回其值Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; if(i &gt; L.len)&#123; printf(\"&gt;&gt;删除位置有误!\\n\"); return ERROR; &#125; int j = 0; Link q; Link p = L.head; while( p &amp;&amp; j &lt; i-1 )&#123; //寻找第i个节点 并使p指向其前驱 p = p -&gt; next; j++; &#125; if( !(p -&gt; next) &amp;&amp; j &gt; i-1)&#123; //结点位置错误 printf(\"&gt;&gt;删除位置有误!\"); return ERROR; &#125; q = p -&gt; next; //删除 p -&gt; next = q -&gt;next; e = q -&gt;date; free(q); printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK; &#125; //删除表尾元素Status DeleteRear_L(LinkList &amp;L,ElemType &amp;e)&#123; Link p = L.head ; while( (p-&gt;next) != L.tail) //p指向尾元素的前驱 p = p -&gt; next; e = L.tail -&gt; date; p -&gt; next = NULL; FreeNode_L(L.tail); L.tail = p; printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK;&#125; //删除给定值的第一个元素Status Delete_L(LinkList &amp;L,ElemType e)&#123; Link p = L.head -&gt; next; Link q = L.head; while(p)&#123; if(p-&gt;date == e) break; q = p; p = p -&gt; next; &#125; if(!p)&#123; printf(\"&gt;&gt;输入元素在线性表L中不存在！\\n\"); return ERROR; &#125; q -&gt; next = p -&gt; next; free(p); printf(\"&gt;&gt;删除成功！\\n\"); L.len--; return OK;&#125; //设置p所指向节点的值Status SetCurElem(Link &amp;p,ElemType e)&#123; p-&gt;date = e; return OK;&#125;//计算链表的长度int ListLength(LinkList L)&#123; return L.len;&#125;//p指向L的一个结点，返回p指向结点的前驱的位置 无前驱返回NULLPosition PriorPos_L(LinkList &amp;L,Link p)&#123; Link temp = L.head; while( temp -&gt; next != p) temp = temp -&gt; next; return temp;&#125; //p指向L的一个结点，返回p指向结点的后继的位置 无后继返回NULLPosition NextPos_L(LinkList &amp;L,Link p)&#123; return p -&gt; next;&#125; //查找链表中第i个元素并以p返回Status LocatePos_L(LinkList &amp;L,int i,Link &amp;p)&#123; int iCount = 0; if( i &gt; 0 &amp;&amp; i &lt;= L.len)&#123; p = L.head; while(iCount++ != i) p = p -&gt; next; return OK; &#125; return ERROR;&#125; //返回头结点位置Position GetHead_L(LinkList L)&#123; return L.head;&#125; //返回尾结点位置Position GetLast_L(LinkList L)&#123; return L.tail;&#125; //查找与e相等的节点并返回该节点Position LocateElem_L(LinkList &amp;L,ElemType e)&#123; Link temp = L.head -&gt; next; while( temp -&gt; date != e ) //元素不在线性表中的情况未考虑 temp = temp -&gt; next; return temp;&#125;//合并两个有序表Status MergeList_L(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)&#123; //已知La，Lb为非逆序 Link pa = La.head -&gt; next; Link pb = Lb.head -&gt; next; Link pc; Lc = La; //La做Lc的头结点 pc = pa; while(pa &amp;&amp; pb)&#123; if(pa -&gt; date &lt;= pb -&gt; date)&#123; pc -&gt; next = pa; pc = pa; pa = pa -&gt; next; &#125;else&#123; pc -&gt; next = pb; pc = pb; pb = pb -&gt; next; &#125; &#125; pc -&gt;next = pa ? pa :pb; //插入剩余段 free(Lb.head); printf(\"&gt;&gt;合并成功!\\n\"); return OK;&#125;//遍历单链表Status ListTraverse_L(LinkList &amp;L)&#123; Link p = L.head -&gt; next; int i = L.len; printf(\"&gt;&gt;当前单链表L = (\"); while(p)&#123; printf(\" %d\",p-&gt;date); p = p-&gt;next; &#125; printf(\" )\\n\"); return OK; &#125; //text void InitMainMenu()&#123; printf(\"\\n\\t\\t\\t\\t 单链表的基本操作\\n\"); printf(\"\\t\\t/*--------------------------------------------------*/\\n\"); printf(\"\\t\\t 1.创建单链表\\t\\t 2.销毁线性表\\n\"); printf(\"\\t\\t 3.清空单链表\\t\\t 4.删除一个元素\\n\"); printf(\"\\t\\t 5.插入一个元素\\t 6.合并两个顺序表\\n\"); printf(\"\\t\\t 7.查找元素的前驱\\t 8.输出L\\n\");&#125; void text()&#123; Link p,h,s; LinkList L; LinkList La,Lb,Lc; ElemType e; int pos; int select; InitMainMenu(); while(1)&#123; printf(\"\\n&gt;请选择你的操作:\"); scanf(\"%d\",&amp;select); switch(select)&#123; case 1: printf(\"&gt;&gt;输入你想创建的链表长度:\"); scanf(\"%d\",&amp;pos); //InitList_L(L); CreateList_L(L,pos); ListTraverse_L(L); break; case 2: DestroyList_L(L); break; case 3: ClearList_L(L); ListTraverse_L(L); break; case 4: printf(\"&gt;&gt;输入你想要的删除方式：1.指定位置删除 2.表尾删除 3.删除给定值的第一个元素 \"); int deleteSelect; scanf(\"%d\",&amp;deleteSelect); switch(deleteSelect)&#123; case 1: printf(\"&gt;&gt;请输入删除位置：\"); scanf(\"%d\",&amp;pos); if(ListDelete_L(L,pos,e)) printf(\"&gt;&gt;删除第%d个元素%d\\n\",pos,e); ListTraverse_L(L); break; case 2: DeleteRear_L(L,e); printf(\"&gt;&gt;删除表尾元素%d\\n\",e); ListTraverse_L(L); break; case 3: printf(\"&gt;&gt;请输入删除元素：\"); scanf(\"%d\",&amp;e); Delete_L(L,e); ListTraverse_L(L); break; &#125; break; case 5: printf(\"&gt;&gt;输入你想要的插入方式：1.指定位置插入 2.表尾插入 3.有序链表插入 \"); int insertSelect; scanf(\"%d\",&amp;insertSelect); switch(insertSelect)&#123; case 1: printf(\"&gt;&gt;请输入插入位置和插入元素：\"); scanf(\"%d %d\",&amp;pos,&amp;e); InsBefore_L(L,pos,e); ListTraverse_L(L); break; case 2: printf(\"&gt;&gt;请输入插入元素：\"); scanf(\"%d\",&amp;e); InsertRear_L(L,e); ListTraverse_L(L); break; case 3: printf(\"&gt;&gt;请输入插入元素：\"); scanf(\"%d\",&amp;e); InsertOrder_L(L,e); ListTraverse_L(L); break; &#125; break; case 6: printf(\"&gt;&gt;输入第一个链表长度:\"); scanf(\"%d\",&amp;pos); CreateList_L(La,pos); ListTraverse_L(La); printf(\"&gt;&gt;输入第二个链表长度:\"); scanf(\"%d\",&amp;pos); CreateList_L(Lb,pos); ListTraverse_L(Lb); MergeList_L(La,Lb,Lc); ListTraverse_L(Lc); break; case 7: printf(\"&gt;&gt;请输入查找方式：1.查找固定位置元素的前驱 2.查找固定元素的前驱 \"); Link k; int posSelect; scanf(\"%d\",&amp;posSelect); switch(posSelect)&#123; case 1: printf(\"&gt;&gt;&gt;请输入元素位置：\"); scanf(\"%d\",&amp;pos); if(LocatePos_L(L,pos,p))&#123; k = PriorPos_L(L,p); if(k == L.head) printf(\"&gt;&gt;&gt;第1个元素无直接前驱!\\n\"); else printf(\"&gt;&gt;&gt;第%d个元素的前驱为：%d\\n\",pos,k-&gt;date); &#125;else printf(\"&gt;&gt;&gt;输入元素位置错误!\\n\"); break; case 2: printf(\"&gt;&gt;&gt;请输入元素的值：\"); scanf(\"%d\",&amp;e); p = LocateElem_L(L,e); if(p != NULL)&#123; k = PriorPos_L(L,p); if(k == L.head) printf(\"&gt;&gt;&gt;元素%d为第1个元素无直接前驱!\\n\",e); else printf(\"&gt;&gt;&gt;元素%d的前驱为：%d\\n\",e,k-&gt;date); &#125;else printf(\"&gt;&gt;&gt;输入元素不在单链表L中!\\n\"); break; &#125; break; case 8: printf(\"&gt;&gt;首指针指向：%d 尾指针指向：%d 链表长度为：%d\",L.head-&gt;next-&gt;date,L.tail-&gt;date,L.len); break; &#125; &#125; &#125;int main() &#123; text(); return 0;&#125; StatcList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include&lt;stdio.h&gt;#define MAXSIZE 100#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef int ElemType;typedef struct&#123; ElemType data; int cur;&#125;component,SLinkList[MAXSIZE];//求链表长度int Length_SL(SLinkList S)&#123; int j = 0; int i = S[MAXSIZE-1].cur; while(i)&#123; j++; i = S[i].cur; &#125; return j; &#125; //动态分配函数int malloc_SL(SLinkList S)&#123; int i = S[0].cur; if(i == 0)&#123; printf(\"备用链表为空，无法分配！\"); return ERROR; &#125; S[0].cur = S[i].cur; return i; &#125;//freeStatus Free(SLinkList S, int k)&#123; //将位置为k的空闲结点释放 //即插入到备用链表第一个结点前 S[k].cur = S[0].cur; S[0].cur = k; return OK;&#125;//初始化Status InitList_SL(SLinkList S)&#123; int i; S[MAXSIZE-1].cur = 0; //链表头结点为空 for(i = 0 ;i &lt; MAXSIZE - 2 ; i++) S[i].cur = i+1; //备用链表 S[MAXSIZE-2].cur = 0; //链表最后一个元素为空 return OK;&#125; //销毁Status DestoryList_SL(SLinkList S)&#123; int i = S[MAXSIZE-1].cur; S[MAXSIZE-1].cur=0; //头结点指向空 int k = S[0].cur; //k记录备用链表第一个结点 S[0].cur = i; //S[0].cur 指向链表第一个元素 int j; while(i)&#123; //找到S最后一个结点 赋值给j j = i; i = S[i].cur; &#125; S[j].cur = k; //链接两个链表 return OK; &#125; //判空Status ListEmpty_SL(SLinkList S)&#123; if(S[MAXSIZE-1].cur == 0) return TRUE; else return FALSE; &#125; //取元素Status GetElem_SL(SLinkList S,int i,ElemType &amp;e)&#123; int j=1, k = S[MAXSIZE-1].cur; if (i&lt;1 || i &gt; Length_SL(S))&#123; //判断位置是否合理 printf(\"查找位置不合理！\"); return ERROR; &#125; while (k &amp;&amp; j&lt;i)&#123; //找到第i个位置 ++j; k = S[k].cur; &#125; e = S[k].data; return OK;&#125; //查找元素int LocateElem_SL(SLinkList S,ElemType e)&#123; int i = S[MAXSIZE-1].cur; int j = 0; while(i)&#123; j++; if(S[i].data == e) return j; else i = S[i].cur; &#125; if(!i)&#123; printf(\"查无此元素！\"); return ERROR; &#125; &#125; //找前驱 Status PriorElem_SL(SLinkList S, ElemType e, ElemType &amp;cur_e) &#123; int i = S[MAXSIZE-1].cur; int j ; while (j)&#123; j = S[i].cur; if (j &amp;&amp; S[j].data == e)&#123; cur_e = S[i].data; return OK; &#125; i = j; &#125; return ERROR; &#125; //找后继 Status NextElem_SL(SLinkList S, ElemType e, ElemType &amp;nex_e) &#123; int i = S[MAXSIZE-1].cur; int j; while (i)&#123; j = S[i].cur; if (j &amp;&amp; S[i].data == e)&#123; nex_e = S[j].data; return OK; &#125; i = j; &#125; return ERROR; &#125;//前插入Status Ins_SL(SLinkList S,int i,ElemType e)&#123; int s; int j = 1; int k = S[MAXSIZE-1].cur; if(i &lt; 1 || i &gt; Length_SL(S)+1)&#123; printf(\"插入位置不合理\"); return ERROR; &#125; while( k &amp;&amp; j &lt;i-1 )&#123; j++; k = S[k].cur; &#125; s = malloc_SL(S); S[s].data = e; S[s].cur = S[k].cur; S[k].cur = s; return OK; &#125; //删除 Status ListDelete(SLinkList S, int i, ElemType &amp;e) &#123; int k = S[MAXSIZE-1].cur; int j = 1, m; if (i&lt;1 || i&gt;Length_SL(S))&#123; //判断位置是否合理 printf(\"删除位置不合理！\"); return ERROR; &#125; while (k &amp;&amp; j&lt;i-1)&#123; //找到第i-1个位置 ++j; k = S[k].cur; &#125; m = S[k].cur; //m指向第i个位置 e = S[m].data; S[k].cur = S[m].cur; Free(S, m); //将空闲结点m释放到备用链表中 return OK; &#125;void TravelList(SLinkList S)&#123; int j = 0; int i = S[MAXSIZE-1].cur; while (i)&#123; j++; printf(\"第%d个结点为：%d\\n\", j, S[i].data); i = S[i].cur; &#125;&#125;int main()&#123; SLinkList S; ElemType e,cur_e,nex_e; int pos; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Est-C.coding.me/Est-C.coding.me/tags/数据结构/"}]}]}