<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>程序人生-Hello’s P2P | Est</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Est,Est's Blog" />
  
  <meta name="description" content="哈尔滨工业大学计算机系统大作业，作者：1170300629 时志敏">
<meta property="og:type" content="article">
<meta property="og:title" content="程序人生-Hello’s P2P">
<meta property="og:url" content="https://Est-C.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/index.html">
<meta property="og:site_name" content="Est">
<meta property="og:description" content="哈尔滨工业大学计算机系统大作业，作者：1170300629 时志敏">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/2-1.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/2-2.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-1.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-2.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-3.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-4.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-5.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-6.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-7.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-8.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-9.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-10.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-1.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-3-0.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-2.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-3.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-4.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-5.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-6.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-7.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-1.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-2.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-3.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-4.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-5.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-6.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-7.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-8.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/6-1.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/6-2-a.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/6-2-b.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/6-2-c.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/6-2-d.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-1.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-2.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-3.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-4.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-5.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-6.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-7.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-8.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-9.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-10.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-11.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-12.png">
<meta property="og:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-13.png">
<meta property="og:updated_time" content="2018-12-31T16:59:53.565Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序人生-Hello’s P2P">
<meta name="twitter:description" content="哈尔滨工业大学计算机系统大作业，作者：1170300629 时志敏">
<meta name="twitter:image" content="https://est-c.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/2-1.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/Est-C.coding.me/css/style.css">
  <script src="/Est-C.coding.me/js/pace.min.js"></script>
  

  
  

</head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/Est-C.coding.me/" class="left">
                    <span class="site-title">Est&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/Est-C.coding.me/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/Est-C.coding.me/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/Est-C.coding.me/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                    <a  ">
                        <i class="fa fa-tags"></i>
                        <span></span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/Est-C.coding.me/">
                    <img src="/Est-C.coding.me/images/logo.jpeg" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Est&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        もう少しだけでいい あと少しだけでいい
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Est" target="_blank" href="//eeest.xyz">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/Est-Z">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Weibo" target="_blank" ">
                            <i class="fa fa-weibo fa-2x"></i></a>
                    
                        <a title="Twitter" target="_blank" ">
                            <i class="fa fa-twitter fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-程序人生-Hello’s-P2P" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      程序人生-Hello’s P2P
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2018-12-30
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <p>哈尔滨工业大学计算机系统大作业，作者：1170300629 时志敏<br><a id="more"></a></p>
<p>摘  要<br>hello.c是我们每个程序员的初恋。但是它究竟是怎么过完它的一生的，你是否知道？恐怕很难说得清楚吧。本文对从hello.c的诞生，历经预处理、编译、汇编、链接生成可执行文件，再到shell解析命令、fork为其创建进程、execve为其加载、内核为其处理异常、存储管理为其读取数据、IO管理为其显示结果，最后被shell回收完美谢幕的整个过程每一步都进行了详细的说明分析，将整个hello的时候活灵活现地展示于大家面前。</p>
<p>关键词：预处理、编译、汇编、链接、存储管理、IO设备、进程管理、异常处理</p>
<h2 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h2><h3 id="1-1-Hello简介"><a href="#1-1-Hello简介" class="headerlink" title="1.1 Hello简介"></a>1.1 Hello简介</h3><p>首先我们利用一个IDE编写生成了hello.c，这样hello就诞生了，但现在只是我们知道要让它做什么，硬件并不知道，我们要将它转换成可执行程序。hello.c要经过预处理、编译、汇编、链接这样几个看起来很简洁其实很繁复的过程为一个可执行文件hello，这样hello就从一个program变成了process，完成了P2P的过程。之后我们在shell中输入对应的执行指令，shell调用fork为其创建进程，调用execve为其加载，hello拥有了自己的进程，然后存储管理系统为它读取数据、IO设备为它实现外部交互、内核为其处理种种异常，hello有条不紊的完成了它的所有指令，最后被shell结束，默默走完了它的一生，不留下一丝踪影，只有CS知道它来过。这就是hello从无到无的O2O过程。</p>
<h3 id="1-2-环境与工具"><a href="#1-2-环境与工具" class="headerlink" title="1.2 环境与工具"></a>1.2 环境与工具</h3><p>硬件环境：AMD FX-7500 Radeon R7,10 Computer Cores 4G+6G<br>软件环境：Ubuntu16.04.1 LTS<br>开发与调试工具：gedit，gcc，as，ld，edb，readelf</p>
<h3 id="1-3-中间结果"><a href="#1-3-中间结果" class="headerlink" title="1.3 中间结果"></a>1.3 中间结果</h3><p>文件名<br>内容</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">hello.i</td>
<td style="text-align:center">hello.c经过预处理之后生成的文件</td>
</tr>
<tr>
<td style="text-align:center">hello.s</td>
<td style="text-align:center">hello.i经过编译之后生成的汇编代码文件</td>
</tr>
<tr>
<td style="text-align:center">hello.o</td>
<td style="text-align:center">hello.s经过汇编之后生成的可重定位文件</td>
</tr>
<tr>
<td style="text-align:center">hello</td>
<td style="text-align:center">hello.o经过链接之后生成的可执行文件</td>
</tr>
<tr>
<td style="text-align:center">hello.elf</td>
<td style="text-align:center">hello.o的ELF格式</td>
</tr>
<tr>
<td style="text-align:center">helloout.elf</td>
<td style="text-align:center">hello的ELF格式</td>
</tr>
<tr>
<td style="text-align:center">helloout.asm</td>
<td style="text-align:center">hello反汇编生成的代码</td>
</tr>
<tr>
<td style="text-align:center">hello.asm</td>
<td style="text-align:center">hello.o反汇编生成的代码</td>
</tr>
</tbody>
</table>
<h3 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h3><p>介绍一些基本的东西，接下来我们就要解剖hello运行的整个过程了。</p>
<h2 id="第2章-预处理"><a href="#第2章-预处理" class="headerlink" title="第2章 预处理"></a>第2章 预处理</h2><h3 id="2-1-预处理的概念与作用"><a href="#2-1-预处理的概念与作用" class="headerlink" title="2.1 预处理的概念与作用"></a>2.1 预处理的概念与作用</h3><h4 id="2-1-1概念"><a href="#2-1-1概念" class="headerlink" title="2.1.1概念"></a>2.1.1概念</h4><p>顾名思义，预处理就是在程序编译之前的处理。主要有三方面的内容，包括：宏定义、文件包含、条件编译。<br>宏定义：将#define标识的变量和函数进行替换。<br>文件包含：将#include标识的头文件调用出来。头文件通常用.h作为扩展名。对头文件也要预处理，也就是说头文件的宏定义、文件包含、条件编译也要就行处理，这样层层嵌套不断扩大。所以我们预处理得到的文件大小可能是源文件大小的数倍。<br>条件编译：通过一些特定符号（例如：#ifdef、#else、#endif）来处理条件分支语句，使其部分程序段在条件满足时再编译。</p>
<h4 id="2-1-2作用"><a href="#2-1-2作用" class="headerlink" title="2.1.2作用"></a>2.1.2作用</h4><p>预处理其作为源文件进入编译环节之前的重要操作，最主要的作用无疑就是方便编译器更好的执行编译功能。</p>
<h3 id="2-2在Ubuntu下预处理的命令"><a href="#2-2在Ubuntu下预处理的命令" class="headerlink" title="2.2在Ubuntu下预处理的命令"></a>2.2在Ubuntu下预处理的命令</h3><p>命令：cpp hello.c &gt; hello.i<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/2-1.png" alt="hello.c的预处理指令执行"></p>
<center>图2-1 hello.c的预处理指令执行</center><br>### 2.3 Hello的预处理结果解析<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/2-2.png" alt="hello.i文件中的main函数"><br><center>图2-2 hello.i文件中的main函数</center>

<p>这便是我用gedit打开的hello.i文件，也就是预处理之后的文件。一番寻找之后我在文件的最后找到了我们源文件编写的hello.c。可以看到没什么太大的变化，但是#include标识的头文件引用不见了，#define标识的宏常量也不见了。之前我们在2.1部分已经较为详细的介绍了预处理具体要做什么，主要是三件事：宏定义处理、文件包含处理、条件编译处理。对应到这个hello.i可以发现，原来有的三个头文件stdio.h、unistd.h、stdlib.h被扩展成了三千多行的一大坨。里面的#define定义也都不见了，还出现了许多#ifdef、#else、#endif等来分割程序块，帮助进行条件编译。</p>
<h3 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h3><p>编译器为了让程序员可以更加方便地编写代码，做了很多妥协，自己承受了很多委屈。而预处理就是委屈的一些体现，在这里编译器做一些必要的还原工作，为下一步大刀阔斧的处理备好了材料。</p>
<h2 id="第3章-编译"><a href="#第3章-编译" class="headerlink" title="第3章 编译"></a>第3章 编译</h2><h3 id="3-1-编译的概念与作用"><a href="#3-1-编译的概念与作用" class="headerlink" title="3.1 编译的概念与作用"></a>3.1 编译的概念与作用</h3><h4 id="3-1-1概念"><a href="#3-1-1概念" class="headerlink" title="3.1.1概念"></a>3.1.1概念</h4><p>此处的编译主要是指狭义的编译，即编译器将hello.i转换成hello.s的过程。这个过程主要有五个步骤：<br>    （1）词法分析：词法分析的任务是对由字符组成的单词进行处理，从左至右逐个字符地对源程序进行扫描，产生一个个的单词符号，把作为字符串的源程序改造成为单词符号串的中间程序。执行词法分析的程序称为词法分析程序或扫描器。<br>（2）语法分析：编译程序的语法分析器以单词符号作为输入，分析单词符号串是否形成符合语法规则的语法单位，如表达式、赋值、循环等，最后看是否构成一个符合要求的程序，按该语言使用的语法规则分析检查每条语句是否有正确的逻辑结构，程序是最终的一个语法单位。编译程序的语法规则可用上下文无关文法来刻画。<br>（3）生成中间代码：中间代码是源程序的一种内部表示，或称中间语言。中间代码的作用是可使编译程序的结构在逻辑上更为简单明确，特别是可使目标代码的优化比较容易实现中间代码，即为中间语言程序，中间语言的复杂性介于源程序语言和机器语言之间。中间语言有多种形式，常见的有逆波兰记号、四元式、三元式和树。<br>（4）代码优化：代码优化是指对程序进行多种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。所谓等价，是指不改变程序的运行结果。所谓有效，主要指目标代码运行时间较短，以及占用的存储空间较小。这种变换称为优化。GCC编译器可以提供不同等级的优化。<br>（5）生成目标代码：目标代码生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。</p>
<h4 id="3-1-2作用"><a href="#3-1-2作用" class="headerlink" title="3.1.2作用"></a>3.1.2作用</h4><p>编译这阶段产生的.s文件也就是汇编代码，是高级语言转换成机器语言的一个缓冲。</p>
<h3 id="3-2-在Ubuntu下编译的命令"><a href="#3-2-在Ubuntu下编译的命令" class="headerlink" title="3.2 在Ubuntu下编译的命令"></a>3.2 在Ubuntu下编译的命令</h3><p>命令：gcc -S hello.i -o hello.s<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-1.png" alt="hello.i文件编译指令执行"></p>
<center>图3-1 hello.i文件编译指令执行</center>

<p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-2.png" alt="hello.i执行生成文件展示"></p>
<center>图3-2 hello.i执行生成文件展示</center>

<h3 id="3-3-Hello的编译结果解析"><a href="#3-3-Hello的编译结果解析" class="headerlink" title="3.3 Hello的编译结果解析"></a>3.3 Hello的编译结果解析</h3><h4 id="3-3-1汇编指令"><a href="#3-3-1汇编指令" class="headerlink" title="3.3.1汇编指令"></a>3.3.1汇编指令</h4><p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-3.png" alt="hello.s文件中一些汇编指令展示"></p>
<center>图3-3 hello.s文件中一些汇编指令展示</center>


<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.file</td>
<td style="text-align:center">源文件</td>
</tr>
<tr>
<td style="text-align:center">.globl</td>
<td style="text-align:center">全局变量</td>
</tr>
<tr>
<td style="text-align:center">.data</td>
<td style="text-align:center">数据段</td>
</tr>
<tr>
<td style="text-align:center">.type</td>
<td style="text-align:center">数据类型</td>
</tr>
<tr>
<td style="text-align:center">.size</td>
<td style="text-align:center">数据大小</td>
</tr>
<tr>
<td style="text-align:center">.long</td>
<td style="text-align:center">长整数类型</td>
</tr>
<tr>
<td style="text-align:center">.string</td>
<td style="text-align:center">字符串类型</td>
</tr>
<tr>
<td style="text-align:center">.align</td>
<td style="text-align:center">对齐</td>
</tr>
<tr>
<td style="text-align:center">.section .rodata</td>
<td style="text-align:center">只读数据</td>
</tr>
<tr>
<td style="text-align:center">.text</td>
<td style="text-align:center">代码段</td>
</tr>
</tbody>
</table>
<h4 id="3-3-2数据"><a href="#3-3-2数据" class="headerlink" title="3.3.2数据"></a>3.3.2数据</h4><p>（1）string型<br>在hello.s代码中共有两个字符串类型，均在.rodata只读数据节。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-4.png" alt="字符串数据展示"></p>
<center>图3-4 字符串数据展示</center>

<p>第一个字符串是“Usage：Hello 学号 姓名！\n”，此字符串在代码中作为printf函数的输出参数，根据图3-4可以发现字符串被编码成UTF-8格式，一个汉字在UTF-8编码中占三个字节。<br>第二个字符串是“Hello %s %s\n”，此此字符串在代码中也是作为printf函数的输出参数。</p>
<p>（2）int型<br>在hello.s中出现的int型变量总共有3个，全局变量sleepsecs、循环计数变量i和作为mian函数参数的变量argc。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-5.png" alt="hello.s数据段展示"></p>
<center>图3-5 hello.s数据段展示</center>

<p>第一个int型变量sleepsecs被声明为全局变量，并且是已经初始化的全局变量，所以被存储在.data段。在data段中表明了其大小为4个字节，类型为对象，数据类型为long，并且值为2（此处我也不太明白为什么int型被声明为long）。<br>第二个和第三个int型变量为局部变量，所以并不能在.data段找到。它们在程序需要的时候声明，存放于寄存器或者栈里面，程序运行结束也就消亡了，但我们仍然可以在.text段发现他们的一丝踪迹（见图3-6）。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-6.png" alt="局部变量i在hello.s中展示"></p>
<center>图3-6 局部变量i在hello.s中展示</center>

<p>（3）数组类型<br>程序中用到的数组只有一个：char *argv[]。这个数据也是局部变量，所以我们在.data段也找不到。同样的，它是存在于运行时栈和寄存器中的，而且也是昙花一现，我们只能在.text段中看出一点踪影。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-7.png" alt="指针型数组argv在hello.s中展示"></p>
<center>图3-7 指针型数组argv在hello.s中展示</center>

<p>（4）其他<br>程序中还有一些立即数，是直接被当做立即数编辑在hello.s中的。</p>
<h4 id="3-3-3赋值"><a href="#3-3-3赋值" class="headerlink" title="3.3.3赋值"></a>3.3.3赋值</h4><p>程序中的赋值操作共有两处：<br>第一处为 int sleepsecs = 2.5。这段赋值在代码段没有出现，因为sleepsecs是全局变量，并且声明即赋值，所以赋值隐式的表现在.data段（前面已经详细说过，可见3.3.2）。<br>第二处为i = 0。因为i是局部变量，所以我们在.text段能看到赋值过程。（这个前面也详细说过了，可以见图3-6）。</p>
<h4 id="3-3-4类型转换"><a href="#3-3-4类型转换" class="headerlink" title="3.3.4类型转换"></a>3.3.4类型转换</h4><p>程序中的类型转换只有一处：<br>int sleepsecs = 2.5。此处为隐式类型转换。sleepsecs本身被声明为int类型，但是赋值的时候却用了一个浮点数2.5。而浮点数默认是double型，明显类型不匹配。所以此处发生了隐式类型转换，将double转换成了int型，采用的是去尾法，所以sleepsecs的实际值为2。</p>
<h4 id="3-3-5算数操作"><a href="#3-3-5算数操作" class="headerlink" title="3.3.5算数操作"></a>3.3.5算数操作</h4><p>在hello.c中出现的算术操作有一处，就是循环变量i的自增运算。在汇编代码中的体现是：addl    $1,-4(%rbp)。其中%rbp-4是存放i的地址，-4（%rbp）就是i，然后add是加法操作，其指令模式是：add  src A，dst B。作用是把A和B相加，得到的值存在B中。因为i是int型 的，所以用l作为后缀，表明是四字节加法。$1是立即数，表示十进制的1。那么整句代码的意思就是，把i+1的值再放到i里面，也就实现了i的自增运算。</p>
<h4 id="3-3-6关系操作"><a href="#3-3-6关系操作" class="headerlink" title="3.3.6关系操作"></a>3.3.6关系操作</h4><p>在hello.c中出现的关系操作有两处：<br>（1）argc!=3。在汇编代码中的体现是cmpl        $3, -20(%rbp)。cmp执行的是比较运算。指令格式为：cmp    src A, dst B。作用效果是执行一个B-A的减法运算，将标志位更新，然后其他语句根据标志位来判断A和B的大小关系(比如其下一句为je    .L2，就是根据其设置的标志位来判断A和B的大小关系，如果相等就跳转至.L2)。然后同样的l的后缀表示的四字节的运算。总的来说cmp运算就是一个不赋值的减法，纯粹为了更新标志位。根据上面的讲述我们可以得出这句代码的意思为：将存放在%rbp-20地址中的数与3相减，设置标志位，然后结合下一句就是如果两者相等，就跳转执行.L2处的代码。<br>（2）i&lt;10。在汇编代码中的体现是cmpl $9, -4(%rbp)。cmp上面已经解释过了，此处就直接解释这句代码的意思。将存放在%rbp-4中的数与9进行相减运算，更新标志位。下一句为jle        .L4。就是如果-4（%rbp）&lt;=9,就跳转.L4的代码（此处.L4处的代码即为循环体的代码，符合hello.c所描述的程序行为）。</p>
<h4 id="3-3-7数组存取"><a href="#3-3-7数组存取" class="headerlink" title="3.3.7数组存取"></a>3.3.7数组存取</h4><p>在hello.c中出现了一个字符指针型数组，即char *argv[]。这个数组是作为main函数的参数存在的，是一个局部变量，所以我们只能在栈帧里面找到它。在这里我们给出main函数的部分栈帧结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">调用main函数的返回地址</td>
</tr>
<tr>
<td style="text-align:center">%rbp（栈帧顶部）(%rbp-0)</td>
</tr>
<tr>
<td style="text-align:center">(%rbp-8)</td>
</tr>
<tr>
<td style="text-align:center">(%rbp-16)</td>
</tr>
<tr>
<td style="text-align:center">argc(%rbp-20)</td>
</tr>
<tr>
<td style="text-align:center">(%rbp-24)</td>
</tr>
<tr>
<td style="text-align:center">argv(%rbp-32)</td>
</tr>
</tbody>
</table>
<p>(%rbp-32)处存放的就是字符指针型数组的首地址，通过首地址+0、+8、+16就可以一次访问到它的元素argv[0]、argv[1]、argv[2]。根据地址访问我们就能实际操作数组里面的数据了。具体汇编代码可见图3-7。</p>
<h4 id="3-3-8控制转移"><a href="#3-3-8控制转移" class="headerlink" title="3.3.8控制转移"></a>3.3.8控制转移</h4><p>汇编代码实现控制转移主要通过jx指令，下面列出了jx的相关操作：</p>
<table>
<thead>
<tr>
<th style="text-align:center">JX指令</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">jmp label</td>
<td style="text-align:center">无条件跳转</td>
</tr>
<tr>
<td style="text-align:center">jmp *Operand</td>
<td style="text-align:center">无条件间接跳转</td>
</tr>
<tr>
<td style="text-align:center">je label</td>
<td style="text-align:center">相等时跳转</td>
</tr>
<tr>
<td style="text-align:center">jne label</td>
<td style="text-align:center">不相等时跳转</td>
</tr>
<tr>
<td style="text-align:center">js label</td>
<td style="text-align:center">结果为负数时跳转</td>
</tr>
<tr>
<td style="text-align:center">jns label</td>
<td style="text-align:center">结果为非负数时跳转</td>
</tr>
<tr>
<td style="text-align:center">jg label</td>
<td style="text-align:center">大于时跳转（有符号数）</td>
</tr>
<tr>
<td style="text-align:center">jge label</td>
<td style="text-align:center">大于等于时跳转（有符号数）</td>
</tr>
<tr>
<td style="text-align:center">jl label</td>
<td style="text-align:center">小于时跳转（有符号数）</td>
</tr>
<tr>
<td style="text-align:center">jle label</td>
<td style="text-align:center">小于等于时跳转（有符号数）</td>
</tr>
<tr>
<td style="text-align:center">ja label</td>
<td style="text-align:center">大于时跳转（无符号数）</td>
</tr>
<tr>
<td style="text-align:center">jb label</td>
<td style="text-align:center">小于时跳转（无符号数）</td>
</tr>
</tbody>
</table>
<p>通常JX指令要结合cmp指令（设置标志位）或者test指令来实现控制转移。<br>程序中的控制转移共有两处：<br>第一个是单分支的if条件语句，转换为goto风格即为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="built_in">test</span>-expr</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">	goto next</span><br><span class="line"><span class="keyword">if</span>-statement</span><br></pre></td></tr></table></figure></p>
<p>在图3-8中我们可以看到它是如何根据跳转指令实现控制转移的，模式与上面所写的goto模式完全相同。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-8.png" alt="if分支语句的控制实现分析"></p>
<center>图3-8 if分支语句的控制实现分析</center>

<p>第二处是for循环语句，for循环的goto风格为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">	update-expr;</span><br><span class="line">	t = <span class="built_in">test</span>-expr;</span><br><span class="line">	<span class="keyword">if</span>(t)</span><br><span class="line">		goto loop;</span><br><span class="line">	<span class="keyword">else</span>-statement</span><br></pre></td></tr></table></figure></p>
<p>基本模式就是先执行循环体，然后循环变量自增，之后判断循环边界，如果满足就回跳，不满足就顺序向下跳出循环。具体实现可以看图3-9。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-9.png" alt="for循环语句控制实现分析"></p>
<center>图3-9 for循环语句控制实现分析</center>

<h4 id="3-3-9函数操作"><a href="#3-3-9函数操作" class="headerlink" title="3.3.9函数操作"></a>3.3.9函数操作</h4><p>函数操作主要表现在各个函数之间的调用，一个函数要调用另一个函数通常要实现两个块内容：数据传送和控制转移。函数调用的大致过程如下：首先是调用时要将参数（如果有参数的话）通过寄存器和栈准备好，然后通过call指令将控制转移给被调用函数。被调用函数执行完所有操作后要给调用函数已反馈。这个时候可分为数据传送和控制转移两部分。函数返回值默认放在%rax中，控制权通过ret指令返回给调用函数，至此一个函数的调用过程才完整结束。接下来详细说明一下数据传送的细节，说说函数是怎么传参的。<br>在64位系统中，共有六个寄存器用来存放参数，分别是%rdi、%rsi、%rdx、%rcx、%r8、%r9，分别对应于第1-6个参数。当函数参数大于七个的时候将被存放在栈中，由最后一个参数到第七个参数一次入栈。它们在栈中通过栈帧指针（可选）或者栈指针被调用。详细的栈帧结构看图3-10。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/3-10.png" alt="栈帧结构"></p>
<center>图3-10 栈帧结构</center>

<p>程序中设计的函数调用有以下几处：<br>（1）系统函数调用main函数<br>数据传送：第一个参数int argc被存放在%edi中，第二个参数char *argv[]被存放在%rsi中。<br>控制转移：hello.s代码中并没有实际体现，但是其确实是被系统函数call了的。<br>数据返回：将$0 存放在%eax中作为返回值。<br>控制返回：①通过ret；②通过call exit。<br>（2）main函数调用puts函数<br>数据传送：将字符串.LC0（首地址之类的信息）存放在%edi中作为第一个参数，也是唯一一个参数。<br>控制转移：call puts<br>数据返回：无<br>控制返回：通过ret<br>（3）main函数调用exit函数<br>数据传送：将$1送至%edi中作为唯一一个参数。<br>控制转移：call exit。<br>数据返回：无。<br>控制返回：exit是系统退出函数，不会再将控制流返回。<br>（4）main函数调用printf函数<br>数据传送：将第三个参数argv[2]传送至%rdx，将第二个参数argv[1]传送至%rsi，将第一个参数字符串.LC1（首地址）传送至%edi。<br>控制转移：call printf。<br>数据返回：无。<br>控制返回：通过ret。<br>（5）main函数调用sleep函数<br>数据传送：将参数sleepsecs传送至%edi作为唯一一个参数。<br>控制转移：call sleep。<br>数据返回：无。<br>控制返回：通过ret。<br>（6）main函数调用getchar函数<br>数据传送：无。<br>控制转移：call getchar。<br>数据返回：该代码中main函数并未接收被调用函数的返回值。<br>控制返回：通过ret。</p>
<h3 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h3><p>编译过程中，不管你原来是什么高级语言，通通要经过一场大手术，将你改造得面目全非（只有汇编程序员才能懂）。不为其他目的，就是为了能让机器更好地看清楚你想干什么，高级语言太高级，机器看不懂。虽然汇编也不是机器语言，当相较来说它离机器更进一步了。</p>
<h2 id="第4章-汇编"><a href="#第4章-汇编" class="headerlink" title="第4章 汇编"></a>第4章 汇编</h2><h3 id="4-1-汇编的概念与作用"><a href="#4-1-汇编的概念与作用" class="headerlink" title="4.1 汇编的概念与作用"></a>4.1 汇编的概念与作用</h3><h4 id="4-1-1概念"><a href="#4-1-1概念" class="headerlink" title="4.1.1概念"></a>4.1.1概念</h4><p>汇编就是汇编器（as）通过解析各种汇编指令，将汇编代码（.s文件）转换成可重定位的机器语言（.o文件）。</p>
<h4 id="4-1-2作用"><a href="#4-1-2作用" class="headerlink" title="4.1.2作用"></a>4.1.2作用</h4><p>将汇编代码转换成机器代码，p2p过程重要一环。</p>
<h3 id="4-2-在Ubuntu下汇编的命令"><a href="#4-2-在Ubuntu下汇编的命令" class="headerlink" title="4.2 在Ubuntu下汇编的命令"></a>4.2 在Ubuntu下汇编的命令</h3><p>指令：as hello.s -o hello.o<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-1.png" alt="对hello.s汇编"></p>
<center>图4-1 对hello.s汇编</center>

<h3 id="4-3-可重定位目标elf格式"><a href="#4-3-可重定位目标elf格式" class="headerlink" title="4.3 可重定位目标elf格式"></a>4.3 可重定位目标elf格式</h3><p>使用指令readelf -a hello.o &gt; hello.elf获得hello.o的ELF格式。典型的ELF文件具有如下表所示的格式。文件开始是ELF头，表明了一些基本信息，最后是节头部表，表明了不同节的位置和大小。夹在ELF头和节头部表之间的都是节。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-3-0.png" alt=""></p>
<h4 id="4-3-1ELF头"><a href="#4-3-1ELF头" class="headerlink" title="4.3.1ELF头"></a>4.3.1ELF头</h4><p>ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小（64字节）、目标文件的类型（可重定位）、机器类型（x86-64）、节部头表的文件偏移（1112字节）、以及节头部表中条目的大小（64字节）和数量（13）。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-2.png" alt="hello.o的ELF格式的ELF头"></p>
<center>图4-2 hello.o的ELF格式的ELF头</center>

<h4 id="4-3-2节头部表"><a href="#4-3-2节头部表" class="headerlink" title="4.3.2节头部表"></a>4.3.2节头部表</h4><p>节头部表如图4-3所示，表示了每个节的基本信息，包括名称、类型、地址、偏移量、大小、全体大小、权限等。就像一个目录一样，对链接器起着指引作用。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-3.png" alt="hello.o的ELF格式的节头部表"></p>
<center>图4-3 hello.o的ELF格式的节头部表</center>

<h4 id="4-3-3部分节展示"><a href="#4-3-3部分节展示" class="headerlink" title="4.3.3部分节展示"></a>4.3.3部分节展示</h4><p>（1）.rela.text节<br>这是一个重定位节，具体内容如图4-4所示。里面包含的是代码段的重定位条目。当链接器把这个目标文件与其他文件组合时需要修改这些位置。这8个条目分别对应.LC0（第一个字符串）、puts函数、exit函数、.LC1（第二个字符串）、printf函数、全局变量sleepsecs、sleep函数、getchar函数。包含了hello.c中所有的外部函数和全局变量。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-4.png" alt="hello.o的ELF格式的.rela.text节"></p>
<center>图4-4 hello.o的ELF格式的.rela.text节</center>

<p>（2）.symtab节（符号表）<br>这个节是一个符号表，具体内容如图4-5所示。它存放了程序中定义和引用的函数和全局变量的信息。其中value是距定义该目标的节的起始位置的偏移。size是该目标的大小（以字节为单位）。type表明目标类型，通常就OBJECT（数据）和FUNC（函数）两种。bind表明目标是本地的还是全局的。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-5.png" alt="hello.o的ELF格式的.symtab节"></p>
<center>图4-5 hello.o的ELF格式的.symtab节</center>

<h3 id="4-4-Hello-o的结果解析"><a href="#4-4-Hello-o的结果解析" class="headerlink" title="4.4 Hello.o的结果解析"></a>4.4 Hello.o的结果解析</h3><p>通过指令objdump -d -r hello.o &gt; hello.asm  得到反汇编代码如图4-6，其与hello.s中的汇编代码（图4-7）进行对比后，得到以下几点不同：<br>（1）在原汇编代码中的代码块标记（如.L3）在反汇编代码中都没有了，取而代之的是间接寻址。这也不难理解，翻译成机器语言后这个汇编代码中帮助识别的部分也就不见了，展现的是机器能识别的地址。<br>（2）函数调用时，原汇编代码用的是函数名称，而反汇编代码用的直接是函数地址。这个原因和上面的差不多，汇编代码还要让人看，而机器语言就是为了让机器看的，所以这点差别也是理应存在的。<br>（3）在反汇编代码中全局变量的访问也是通过代码，而原汇编代码是通过符号标识。<br>（4）在反汇编代码中同步出现了机器码。<br>总的来说，两者大体还是相同的。造成不同的原因也很显然，一个是被机器“嚼”过一遍的，一个是没被机器“嚼”过一遍的，自然“味道”就有些不同了。</p>
<p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-6.png" alt="反汇编代码部分展示"></p>
<center>图4-6 反汇编代码部分展示</center>

<p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/4-7.png" alt="原汇编代码部分展示"></p>
<center>图4-7 原汇编代码部分展示</center>

<h3 id="4-5-本章小结"><a href="#4-5-本章小结" class="headerlink" title="4.5 本章小结"></a>4.5 本章小结</h3><p>本阶段相当于是继承了上一阶段，“手术”进行到底的结果。经过编译和汇编的联合大手术，机器也算是能读懂我们想要做什么了。但是信息尚是支离破碎，需要链接器的进一步组织，机器才能准确把握我们程序员的意图。</p>
<h2 id="第5章-链接"><a href="#第5章-链接" class="headerlink" title="第5章 链接"></a>第5章 链接</h2><h3 id="5-1-链接的概念与作用"><a href="#5-1-链接的概念与作用" class="headerlink" title="5.1 链接的概念与作用"></a>5.1 链接的概念与作用</h3><h4 id="5-1-1概念"><a href="#5-1-1概念" class="headerlink" title="5.1.1概念"></a>5.1.1概念</h4><p>链接是将各种代码和数据片段收集起来并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接由链接器自动执行。</p>
<h4 id="5-1-2作用"><a href="#5-1-2作用" class="headerlink" title="5.1.2作用"></a>5.1.2作用</h4><p>将源程序所调用的所有外部函数组织起来，通过符号解析和重定位把可重定位文件转换成可执行文件，完成高级语言向机器语言转换的最后一步。</p>
<h3 id="5-2-在Ubuntu下链接的命令"><a href="#5-2-在Ubuntu下链接的命令" class="headerlink" title="5.2 在Ubuntu下链接的命令"></a>5.2 在Ubuntu下链接的命令</h3><p>通过链接命令ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o获得hello可执行文件，如图5-1。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-1.png" alt="hello.o链接产生可执行文件展示"></p>
<center>图5-1 hello.o链接产生可执行文件展示</center>


<h3 id="5-3-可执行目标文件hello的格式"><a href="#5-3-可执行目标文件hello的格式" class="headerlink" title="5.3 可执行目标文件hello的格式"></a>5.3 可执行目标文件hello的格式</h3><p>通过命令readelf -a hello &gt; helloout.elf生成hello的ELF格式文件helloout.elf。<br>可执行文件的ELF格式与可重定位文件的ELF格式大体相同，具体格式如下表。就格式来看我们可以发现相比于可重定位文件的ELF格式，可执行文件的ELF格式多了.init节和一个程序头表、少了重定位节。这样的格式也是为了让该文件可以更好地执行。</p>
<table>
<thead>
<tr>
<th style="text-align:center">ELF头</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">程序头表</td>
</tr>
<tr>
<td style="text-align:center">.init</td>
</tr>
<tr>
<td style="text-align:center">.text</td>
</tr>
<tr>
<td style="text-align:center">.rodata</td>
</tr>
<tr>
<td style="text-align:center">.data</td>
</tr>
<tr>
<td style="text-align:center">.bss</td>
</tr>
<tr>
<td style="text-align:center">.symtab</td>
</tr>
<tr>
<td style="text-align:center">.debug</td>
</tr>
<tr>
<td style="text-align:center">.strtab</td>
</tr>
<tr>
<td style="text-align:center">.line</td>
</tr>
</tbody>
</table>
<p>节头表<br>下面是节头表部分，这里有各个节的基本信息，具体情况如图5-2所示。与可重定位ELF格式一样，节头表表明了各个节的名称、类型、地址、偏移量等信息。该文件共有25个节</p>
<p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-2.png" alt="helloELF格式的节头表"></p>
<center>图5-2 helloELF格式的节头表</center><br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-3.png" alt="helloELF格式的程序头表展示"><br><center>图5-3 helloELF格式的程序头表展示</center>


<p>然后是程序头表。程序头表中记录了各个段的信息，具体情况如图5-3。其中offset是目标文件中的便偏移、virtaddr/physaddr为内存地址、align为对齐要求、filesiz为目标文件段大小、memsiz为内存中段大小、flags为运行时访问权限。</p>
<h3 id="5-4-hello的虚拟地址空间"><a href="#5-4-hello的虚拟地址空间" class="headerlink" title="5.4 hello的虚拟地址空间"></a>5.4 hello的虚拟地址空间</h3><p>通过使用edb加载hello，分别查看被加载的两大部分：数据段和代码段。它们在虚拟地址空间的对应地址为0x0000 0000 0060 0000~0x0000 0000 0060 1000和<br>0x0000 0000 0040 0000~0x0000 0000 0040 1000。查看dump可以发现每个节开始的地址与图5-2节头表所示地址完全相同，如图5-4所示。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-4.png" alt="使用edb查看几个典型段的虚拟地址"></p>
<center>图5-4 使用edb查看几个典型段的虚拟地址</center>

<h3 id="5-5-链接的重定位过程分析"><a href="#5-5-链接的重定位过程分析" class="headerlink" title="5.5 链接的重定位过程分析"></a>5.5 链接的重定位过程分析</h3><p>通过objdump -d -r hello &gt; helloout.asm指令生成可执行文件的反汇编代码。将其与可重定位生成的反汇编hello.asm代码相比较，我们大致可以看到重定位的过程。<br>当汇编器生成一个可重定位文件时，它并不知道数据和代码最终会被放在内存的什么位置，它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目（如图5-5），告诉链接器在将目标文件合并成可执行文件的时候如何修改这个引用。代码的重定位条目放在.rel.text（可回看图4-4）中，已初始化数据的重定位条目放在.rel.data。重定位条目的格式中重点有四个部分：偏移量（相距被引用节起始偏移量）、类型（主要有R_X86_64_PC32和R_X86_64_32两种）、符号名称（目标所在节）、加数（相较于目标所在节起始位置的引用偏移）。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-5.png" alt="hello.asm中的重定位信息"></p>
<center>图5-5 hello.asm中的重定位信息</center>


<p>下面我们详细说一下究竟如何根据重定位条目计算引用的地址。重定位条目根据类型分为两种相对引用（R_X86_64_PC32）和绝对引用（R_X86_64_32）。相对引用是根据距离运行时pc的地址进行引用，此时我们通常会将pc的值进行修改，进行控制转移，一般用于函数调用。绝对引用就是计算其绝对地址，不修改pc值，只进行数据访问。</p>
<h4 id="5-5-1相对地址的重定位"><a href="#5-5-1相对地址的重定位" class="headerlink" title="5.5.1相对地址的重定位"></a>5.5.1相对地址的重定位</h4><p>首先是相对地址（<em>refptr）的计算方法：符号所在节首地址 + 加数 + 符号被引用节首地址 + 偏移量。运行时，碰到相对引用重定位信息时，就将pc的值压入栈中，然后更新pc的值为pc+</em>refptr，就实现了控制转移。</p>
<h4 id="5-5-2绝对地址的重定位"><a href="#5-5-2绝对地址的重定位" class="headerlink" title="5.5.2绝对地址的重定位"></a>5.5.2绝对地址的重定位</h4><p>相较于基于相对地址的重定位，绝对地址的重定位就简单一些了。通过符号所在节首地址加上偏移量就可以定位到引用符号的地址了。<br>图5-6是helloout.asm中一些重定位结果，其中红框所圈的就是相对地址的重定位，绿框所圈的是绝对地址的重定位。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-6.png" alt="部分重定位结果展示"></p>
<center>图5-6 部分重定位结果展示</center>

<h3 id="5-6-hello的执行流程"><a href="#5-6-hello的执行流程" class="headerlink" title="5.6 hello的执行流程"></a>5.6 hello的执行流程</h3><p>下面列出了hello从开始到结束整个过程中依次调用的函数，以及它们的地址。<br>函数名|函数地址</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ld-2.23.so!_dl_start</td>
<td style="text-align:center">0x00007fc7843379b0</td>
</tr>
<tr>
<td style="text-align:center">ld-2.23.so!_dl_init</td>
<td style="text-align:center">0x00007fc784346740</td>
</tr>
<tr>
<td style="text-align:center">hello!_start</td>
<td style="text-align:center">0x00000000004004d0</td>
</tr>
<tr>
<td style="text-align:center">libc-2.23.so!__libc_start_main</td>
<td style="text-align:center">0x00007fc783f86740</td>
</tr>
<tr>
<td style="text-align:center">-libc-2.23.so!__cxa_atexit</td>
<td style="text-align:center">0x00007fc783fa0280</td>
</tr>
<tr>
<td style="text-align:center">-libc-2.23.so!__libc_csu_init</td>
<td style="text-align:center">0x0000000000400580</td>
</tr>
<tr>
<td style="text-align:center">hello!_init</td>
<td style="text-align:center">0x0000000000400430</td>
</tr>
<tr>
<td style="text-align:center">libc-2.23.so!_setjmp</td>
<td style="text-align:center">0x00007fc783f9b250</td>
</tr>
<tr>
<td style="text-align:center">-libc-2.23.so!_sigsetjmp</td>
<td style="text-align:center">0x00007fc783f9b1b0</td>
</tr>
<tr>
<td style="text-align:center">-libc-2.23.so!__sigjmp_save</td>
<td style="text-align:center">0x00007fc783f9b210</td>
</tr>
<tr>
<td style="text-align:center">hello!main</td>
<td style="text-align:center">0x0000000000400523</td>
</tr>
<tr>
<td style="text-align:center">hello!puts@plt</td>
<td style="text-align:center">0x0000000000400460</td>
</tr>
<tr>
<td style="text-align:center">hello!exit@plt</td>
<td style="text-align:center">0x00000000004004a0</td>
</tr>
<tr>
<td style="text-align:center">*hello!printf@plt</td>
<td style="text-align:center">0x0000000000400470</td>
</tr>
<tr>
<td style="text-align:center">*hello!sleep@plt</td>
<td style="text-align:center">0x00000000004004b0</td>
</tr>
<tr>
<td style="text-align:center">*hello!getchar@plt</td>
<td style="text-align:center">0x0000000000400490</td>
</tr>
<tr>
<td style="text-align:center">-ld-2.23.so!_dl_fixup</td>
<td style="text-align:center">0x00007fc7843459f0</td>
</tr>
<tr>
<td style="text-align:center">–ld-2.23.so!_dl_lookup_symbol_x</td>
<td style="text-align:center">0x00007fc7843409d0</td>
</tr>
<tr>
<td style="text-align:center">libc-2.23.so!_exit</td>
<td style="text-align:center">0x00007fc7843515b0</td>
</tr>
</tbody>
</table>
<h3 id="5-7-Hello的动态链接分析"><a href="#5-7-Hello的动态链接分析" class="headerlink" title="5.7 Hello的动态链接分析"></a>5.7 Hello的动态链接分析</h3><p>动态链接依赖于位置无关函数PIC。PIC函数的代码可以直接加载无需重定位。动态链接过程主要就是实现PIC的数据引用和PIC的函数调用。<br>PIC数据引用通过一个全局偏移量表（GOT），它位于数据段的开始，如图5-7所示。在GOT中，每个被目标代码所引用的全局数据目标（过程或全局变量）都有一个八字节条目。编译器会为每个条目都生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得他们包含正确的绝对地址。<br>PIC函数调用采用一个延迟绑定的策略，GNU编译器将过程地址的绑定推迟到第一次调用该过程时。延迟绑定是通过两个数据结构之间的交互实现的，这两个数据结构是：GOT和过程链接表（PLT）。如果一个目标模块调用定义在共享库中的任何函数，那么他就有自己的GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分。PLT是一个数组，其中每个条目是16字节代码（如图5-8）。</p>
<p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-7.png" alt="hello在dl_init运行前后的GOT对比"></p>
<center>图5-7 hello在dl_init运行前后的GOT对比</center>

<p>通过图5-7中在dl_init运行前后GOT的对比，我们可以看出来动态链接的过程。再结合图5-8我们就能看出函数调用的一些现象。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/5-8.png" alt="hello的PLT展示"></p>
<center>图5-8 hello的PLT展示</center>


<h3 id="5-8-本章小结"><a href="#5-8-本章小结" class="headerlink" title="5.8 本章小结"></a>5.8 本章小结</h3><p>链接的过程其实就像是在请帮手，程序要执行的工作太过丰富，大家的功能也比较专一，所以一项工作的完成就需要许多“同伴”来执行。而链接就是组织工作的过程，通过链接却工作虽然分配零碎但是却依然能井然有序的进行。<br>通过预处理、编译、汇编、链接的一系列操作，hello.c摇身一变成为了一个可执行程序，完成了从program到process的完美蜕变，接下来，它终于要投身机器的怀抱，存在于电流与硬件之上了。</p>
<h2 id="第6章-hello进程管理"><a href="#第6章-hello进程管理" class="headerlink" title="第6章 hello进程管理"></a>第6章 hello进程管理</h2><h3 id="6-1-进程的概念与作用"><a href="#6-1-进程的概念与作用" class="headerlink" title="6.1 进程的概念与作用"></a>6.1 进程的概念与作用</h3><h4 id="6-1-1概念"><a href="#6-1-1概念" class="headerlink" title="6.1.1概念"></a>6.1.1概念</h4><p>进程即一个执行中程序的实例。</p>
<h4 id="6-1-2作用"><a href="#6-1-2作用" class="headerlink" title="6.1.2作用"></a>6.1.2作用</h4><p>进程概念的抽象给我们一种假象，似乎我们的程序是系统当前唯一运行的程序一样。我们的程序像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一存在的对象。</p>
<h3 id="6-2-简述壳Shell-bash的作用与处理流程"><a href="#6-2-简述壳Shell-bash的作用与处理流程" class="headerlink" title="6.2 简述壳Shell-bash的作用与处理流程"></a>6.2 简述壳Shell-bash的作用与处理流程</h3><p>Shell字面理解就是个“壳”，是操作系统（内核）与用户之间的桥梁，充当命令解释器的作用，将用户输入的命令翻译给系统执行。<br>处理流程如下：（1）读取用户由键盘输入的命令行。<br>（2）分析命令，以命令名作为文件名，并将其它参数改造为系统调用execve( )内部处理所要求的形式。<br>（3）终端进程调用fork( )建立一个子进程。<br>（4）终端进程本身调用wait()来等待子进程完成（如果是后台命令，则不等待）。当子进程运行时调用execve()，子进程根据文件名到目录中查找有关文件，调入内存，执行这个程序。<br>（5）如果命令末尾有&amp;,则终端进程不用执行系统调用wait()，立即发提示符，让用户入下一条命令；否则终端进程会一直等待，当子进程完成工作后，向父进程报告，此时中断进程醒来，作必要的判别工作后，终端发出命令提示符，重复上述处理过程。</p>
<h3 id="6-3-Hello的fork进程创建过程"><a href="#6-3-Hello的fork进程创建过程" class="headerlink" title="6.3 Hello的fork进程创建过程"></a>6.3 Hello的fork进程创建过程</h3><p>在终端中输入./hello 1170300629 shizhimin，命令输入完成后就都是shell的工作了。首先，shell会解析命令，准备好加载函数execve的各个参数。然后在当前进程下利用fork函数创建一个子进程，这是父进程的一个复制。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，这就意味着，当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程与子进程之间最大的区别在于它们拥有不同的PID。到此为止，hello的进程就创建完毕了。</p>
<h3 id="6-4-Hello的execve过程"><a href="#6-4-Hello的execve过程" class="headerlink" title="6.4 Hello的execve过程"></a>6.4 Hello的execve过程</h3><p>上面说到hello的进程已经创建好。在创建好的进程下，子进程利用之前准备好的参数调用execve函数。这个函数会删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的堆和栈段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件的内容。最后，execve跳转到_start地址，它最终调用hello的main函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，这时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。</p>
<h3 id="6-5-Hello的进程执行"><a href="#6-5-Hello的进程执行" class="headerlink" title="6.5 Hello的进程执行"></a>6.5 Hello的进程执行</h3><p>自从fork为hello创建新的进程之后，在没有任何异常的情况下，hello都是老老实实的一条一条地执行着它代码段中的指令。当遇到任何异常时候，hello都会陷入内核模式，交由内核处理异常，内核处理完毕后，或许会将控制流返回给hello，或者不会，这依赖于异常的类型。整个异常处理的过程涉及模式切换、上下文切换、信号收发等。下面我们详细介绍一下hello执行sleep时的进程调用情况。<br>首先hello运行到sleep函数处，sleep是一个系统函数，通过一条称为syscall的陷阱指令来提供的。通过这条指令，sleep显式的请求让进程hello休眠2秒钟。系统调用以后，进入内核模式，内核进行上下文切换，保存当前进程的上下文，恢复某个先前被抢占的进程被保存的上下文，最后将控制传递给这个新恢复的进程。完成上下文切换后，又进入用户模式，执行其他进程。当2秒钟到达后，定时器会产生一个中断信号，当前进程（其他进程）检测到这个信号后，进行异常处理，陷入内核模式，内核模式处理异常，再次进行上下文切换，将控制返回给hello。至此，一个sleep结束，之后的sleep不断重复这样的过程。过程图解见图6-1。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/6-1.png" alt="hello调用sleep时的进程执行情况"></p>
<center>图6-1 hello调用sleep时的进程执行情况</center>


<h3 id="6-6-hello的异常与信号处理"><a href="#6-6-hello的异常与信号处理" class="headerlink" title="6.6 hello的异常与信号处理"></a>6.6 hello的异常与信号处理</h3><p>在这里我手动模拟了四种情况，下面分别是四种情况的分析。<br>（1）正常结束。如图6-2（a），是正常执行hello程序的结果，当程序执行完成之后，我们通过ps命令可以看到hello的进程已经消失，说明hello确实结束了。<br>（2）键入ctrl-z。如图6-2（b），是在程序输出4条Hello 1170300629 szm之后按下ctrl-z的结果，当按下ctrl-z之后，shell父进程收到SIGSTP信号，信号处理函数的逻辑是打印屏幕回显、将hello进程挂起，通过ps命令我们可以看出hello进程没有被回收，此时它的后台job号是1，调用fg 1将其调到前台，此时shell程序首先打印hello的命令行命令，hello继续运行打印剩下的6条Hello 1170300629 szm，之后输入字串，程序结束。这时我们再输入ps命令可以看到hello进程确实是结束了。<br>（3）键入ctrl-c。如图6-2（c），是在程序输出5条Hello 1170300629 szm之后按下ctrl-c的结果，当按下ctrl-c之后，shell父进程收到SIGINT信号，信号处理函数的逻辑是结束hello，并回收hello进程。通过ps命令可以看到hello的进程已经消失，说明hello已经结束了。<br>（4）中途乱按。如图6-2（d），是在程序运行中途乱按的结果，可以发现，乱按只是将屏幕的输入缓存到stdin，当getchar的时候读出一个’\n’结尾的字串（作为一次输入），其他字串会当做shell命令行输入。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/6-2-a.png" alt="hello正常结束"></p>
<center>图6-2（a） hello正常结束</center>

<p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/6-2-b.png" alt="hello执行过程中键入Ctrl+Z"></p>
<center>图6-2（b） hello执行过程中键入Ctrl+Z</center>

<p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/6-2-c.png" alt="hello执行过程中键入Ctrl+C"></p>
<center>图6-2（c） hello执行过程中键入Ctrl+C</center>

<p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/6-2-d.png" alt="hello执行过程中乱按"></p>
<center>图6-2（d） hello执行过程中乱按</center><br>### 6.7本章小结<br>这本章中，介绍了hello投身进程洪流之后发生的具体情况。从shell为其fork，为其execve，hello正式成为一个进程，到内核通过各种异常密切关注其运行情况，让它顺利运行，不捅娄子。hello到现在总算是可以出结果了，这一路艰辛不易，恐怕只有它自己和CPU知道吧。<br><br>## 第7章 hello的存储管理<br>### 7.1 hello的存储器地址空间<br>#### 7.1.1物理地址<br>用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。虽然我们可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。<br>#### 7.1.3虚拟地址<br>虚拟地址就是依赖于虚拟内存的地址。虚拟内存是对整个内存的抽像描述。它是相对于物理内存来讲的，可以直接理解成“不直实的”，“假的”内存，例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000 - 1那个地址元素。之所以是这样，是因为现代操作系统都提供了一种内存管理的抽像，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。<br>#### 7.1.4线性地址<br>跟逻辑地址类似，它也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件页式内存的转换前地址。<br>#### 7.1.2逻辑地址<br>Intel为了兼容，将远古时代的段式内存管理方式保留了下来。逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。<br>### 7.2 Intel逻辑地址到线性地址的变换-段式管理<br>一个逻辑地址由两部份组成，段标识符: 段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号，后面3位包含一些硬件细节，如图7-1。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-1.png" alt="段选择符示例"><br><center>图7-1 段选择符示例</center>


<p>索引号可以直接理解成数组下标，它对应的数组就是“段描述符”。段描述符具体地描述了一个段，很多个段描述符，就组了一个数组，叫“段描述符表”。通过段标识符的前13位，我们可以直接在段描述符表中找到一个具体的段描述符，这个描述符就描述了一个段，具体描述了什么内容，我们可以参考图7-2。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-2.png" alt="段描述符结构介绍"></p>
<center>图7-2 段描述符结构介绍</center>

<p>每个段描述符由8个字节组成，其内容较为复杂，我们这里只关注其Base字段，它描述了一个段的开始位置的线性地址。Intel设计的本意是，一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。那究竟什么时候该用GDT，什么时候该用LDT呢？这是由段选择符中的T1字段表示的，T1=0表示用GDT，T1=1表示用LDT。GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。如图7-3。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-3.png" alt="逻辑地址向线性地址转换示意图"></p>
<center>图7-3 逻辑地址向线性地址转换示意图</center>

<p>现在我们简单讲一下转换步骤。首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]，然后，看段选择符的T1是0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。接着，拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。最后，把Base + offset，就是要转换的线性地址了。</p>
<h3 id="7-3-Hello的线性地址到物理地址的变换-页式管理"><a href="#7-3-Hello的线性地址到物理地址的变换-页式管理" class="headerlink" title="7.3 Hello的线性地址到物理地址的变换-页式管理"></a>7.3 Hello的线性地址到物理地址的变换-页式管理</h3><p>我们这里首先简单说一下线性地址（虚拟地址）到物理地址的转换原理，之后会在下一节（7.4）详细阐述基于TLB和四级页表的变换。虚拟内存系统将物理内存分割为物理页，虚拟地址的表示范围往往大于物理地址的表示范围，但是它们均以相同大小的页为基础单元。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-4.png" alt="虚拟地址转换物理地址过程"></p>
<center>图7-4 虚拟地址转换物理地址过程</center>

<p>具体转换过程如图7-4。两者之间通过页表进行转换。虚拟内存的每一个页都在页表中有对应的条目，如果该虚拟页有对应的物理页，那我们就称它有效，将页表有效为设置为1，如果没有就设置为0。也就是说页表中有效位为1的虚拟页，在内存中一定可以找到它所映射的物理页，并且页表的后几位就存放着物理页的页号。根据页表大小（P=2p字节），我们把虚拟地址和物理地址均划分为两部分，低p位和高位。对应的物理页和虚拟页低p位完全相同。所以我们只要根据虚拟地址找到物理地址的高位就行了，而这个高位地址就存放在页表中，页表中的对应寻找依赖于虚拟地址的高位，如图所示。所以我们这就根据虚拟地址得到了对应的物理地址。</p>
<h3 id="7-4-TLB与四级页表支持下的VA到PA的变换"><a href="#7-4-TLB与四级页表支持下的VA到PA的变换" class="headerlink" title="7.4 TLB与四级页表支持下的VA到PA的变换"></a>7.4 TLB与四级页表支持下的VA到PA的变换</h3><p>我们以Intel Core i7为例，我们介绍一下TLB和四级页表支持下的虚拟地址转换物理地址，具体流程如图7-5。<br>Intel Core i7满足以下前提：虚拟地址为48位，页大小为212字节；物理地址52位；TLB为16组，每组四个条目；每级页表存放9位VPN；CR3控制寄存器指向第一级页表的起始位置。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-5.png" alt="TLB和四级页表支持下的虚拟地址向物理地址转换"></p>
<center>图7-5 TLB和四级页表支持下的虚拟地址向物理地址转换</center>


<p>具体转换过程为：首先得到虚拟地址，取其高36位为VPN，再将VPN分割为低4位（TLB索引）和高32位（TLB标记），根据TLB索引和TLB标记在TLB中查找，如果找到且标志位为1，即为命中，取出其中的40位PPN，与之前虚拟地址的低12位组成物理地址，转换结束。如果不幸运，TLB中并没有找到，那么我们就得根据36位的VPN在四级页表中分级查找，找到对应的PTE（VPN对应的页表条目），查看其标志位，如果为0，那么就是缺页，需要在磁盘中找到对应页；如果为1，我们可以找到PPN，进而组成物理地址。另外，还要将这个PTE放到TLB当中。</p>
<h3 id="7-5-三级Cache支持下的物理内存访问"><a href="#7-5-三级Cache支持下的物理内存访问" class="headerlink" title="7.5 三级Cache支持下的物理内存访问"></a>7.5 三级Cache支持下的物理内存访问</h3><p>这里我们着重讨论Cache1的物理访问原理，Cache2和Cache3相同，在最后我们简单介绍一下。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-6.png" alt="物理地址访存展示"></p>
<center>图7-6 物理地址访存展示</center>

<p>为了解释方便，在这里我们假设Cache1是64组，每组有8行。物理地址有52位。具体情况如图7-6。首先我们先将52位的物理地址解析为低6位的位偏移、中间6位的组索引、高40位的组标记。然后通过组索引我们找到对应的组，再通过组标记在这个组中查看能不能找到，如果找到并且标志位为 1，那么就是缓存命中，我们可以通过块偏移在这个块中找到对应的物理字节；如果找不到或者标志位为0，那么就是缓存不命中，就要执行驱逐或者替换策略，从Cache2中寻找对应的物理地址来更新缓存。Cache2的命中过程与Cache1基本相似，只不过Cache2比Cache1更大。如果Cache2也找不到，就类推到更大的存储级别中去找。存储级别如图7-7。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-7.png" alt="存储器层次结构"></p>
<center>图7-7 存储器层次结构</center>

<h3 id="7-6-hello进程fork时的内存映射"><a href="#7-6-hello进程fork时的内存映射" class="headerlink" title="7.6 hello进程fork时的内存映射"></a>7.6 hello进程fork时的内存映射</h3><p>当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。</p>
<h3 id="7-7-hello进程execve时的内存映射"><a href="#7-7-hello进程execve时的内存映射" class="headerlink" title="7.7 hello进程execve时的内存映射"></a>7.7 hello进程execve时的内存映射</h3><p>execve函数在当前进程中加载并运行包含在可执行文件hello中的程序，用hello程序有效的替代了当前程序。其中，execve进行内存映射的具体步骤为：<br>（1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。<br>（2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域椰丝球请求二进制零的，初始长度为零。图7-8概括了私有区域的不同映射。<br>（3）映射共享区域。将hello的共享对象映射到用户虚拟地址空间的共享区域内。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-8.png" alt="execve是如何映射用户地址空间的区域的"></p>
<center>图7-8 execve是如何映射用户地址空间的区域的</center>

<h3 id="7-8-缺页故障与缺页中断处理"><a href="#7-8-缺页故障与缺页中断处理" class="headerlink" title="7.8 缺页故障与缺页中断处理"></a>7.8 缺页故障与缺页中断处理</h3><p>   缺页是系统异常的一种，异常的通用处理流程如图7-9，这里我们的缺页异常应该return to I_current。具体过程为：首先程序进行内存访问发生页表不命中的时候，硬件会返回一个缺页信号告诉程序发生了缺页异常。程序接收到这个信号以后，将控制权交由内核处理，内核进行异常处理（具体就是驱逐或者替换，引入有效缓存），异常处理成功后，内核会将控制权重新返回给当前指令，让其在执行一遍。而此时缓存已经发生替换，指令就可以顺利执行了。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-9.png" alt="异常处理示意图"></p>
<center>图7-9 异常处理示意图</center>

<h3 id="7-9动态存储分配管理"><a href="#7-9动态存储分配管理" class="headerlink" title="7.9动态存储分配管理"></a>7.9动态存储分配管理</h3><p>当hello程序运行到printf时，会调用malloc获得虚拟内存。malloc就是一个动态内存分配器。动态内存分配器维护着一个进程的虚拟内存区域，称为堆；假设堆是一个请求二进制零的区域，他紧接在未初始化的 数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。<br>分配器将堆视为一组不同大小的块(blocks)的集合来维护，每个块要么是已分配的，要么是空闲的。已分配的块显式的保留为供应用程序使用。空闲块可以用来分配。一个已分配的块保持已分配的状态，直到它被释放这种释放要不是应用程序显式的执行，要么是内存分配器自身隐式的执行。根据谁来释放已分配的块，动态分配器分为两种风格，一种是显式动态分配器（需要应用显式释放已分配的内存，比如C代码中的free），一种是隐式动态分配器（分配器自已检测不会被使用的已分配块将其释放）。</p>
<h4 id="7-9-1空闲块的组织方式"><a href="#7-9-1空闲块的组织方式" class="headerlink" title="7.9.1空闲块的组织方式"></a>7.9.1空闲块的组织方式</h4><p>如何将空闲块组织起来，以便于分配器分配、合并、释放等操作是分配器设计的一个核心问题。这里我们介绍一下隐式空闲链表。空闲块的组织形式依赖于空闲块是如何定义的，所以我们先从空闲块的结构看起。<br>通过图7-10的堆块结构我们就可以构造出如图7-11的隐式空闲链表。通过每个块头部的块大小和标志位，我们就可以通过遍历堆中所有的块寻找合适的空闲块进行分配。为了方便合并，我们可以在当前块模式中加入一个脚部，它是头部的复制，如图7-12。这样我们就可以获得双向的隐式空闲链表，如图7-13。<br><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-10.png" alt="一个简单的堆块的格式"></p>
<center>图7-10 一个简单的堆块的格式</center>

<p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-11.png" alt="隐式空闲链表"></p>
<center>图7-11 隐式空闲链表</center>

<p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-12.png" alt="带边界标记的块模式"></p>
<center>图7-12 带边界标记的块模式</center>

<p><img src="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/7-13.png" alt="双向隐式空闲链表"></p>
<center>图7-13 双向隐式空闲链表</center>

<h4 id="7-9-2分配空闲块"><a href="#7-9-2分配空闲块" class="headerlink" title="7.9.2分配空闲块"></a>7.9.2分配空闲块</h4><p>分配空闲块主要有三种策略：首次适配、下一次适配和最佳适配。首次适配从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配和首次适配很相似，只不过不是从链表的起始处开始每次搜索，而是从上一次查询结束的地方开始。最佳适配检查每个空闲块，选择适合所需请求大小的最小空闲块。</p>
<h4 id="7-9-3分割空闲块"><a href="#7-9-3分割空闲块" class="headerlink" title="7.9.3分割空闲块"></a>7.9.3分割空闲块</h4><p>当分配器找到一个匹配的空闲块，它会选择给程序分配整个空闲块还是只分配其中一部分。假如只分配一部分的话就会将空闲块分割。</p>
<h4 id="7-9-4获得额外的堆内存"><a href="#7-9-4获得额外的堆内存" class="headerlink" title="7.9.4获得额外的堆内存"></a>7.9.4获得额外的堆内存</h4><p>如果分配器不能为请求块找到合适的空闲块并且最大程度地合并也不行的话，分配器就会通过sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化为一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。</p>
<h4 id="7-9-5合并相邻的空闲块"><a href="#7-9-5合并相邻的空闲块" class="headerlink" title="7.9.5合并相邻的空闲块"></a>7.9.5合并相邻的空闲块</h4><p>当一个已分配的额内存块被释放时，可能有其他空闲块与这个新释放的空闲块相邻。那么我们就要将其合并成为更大的空闲块，以满足以后较大的块请求。这里讲一下带边界标记的合并。相较于图7-10的块模式，我们无法快速合并当前块和前一块。所以我们改进其模式为图7-12的块模式，这个模式中我们加入了脚部，它是头部的复制。因为前一块的脚部与当前块的头部相邻，所以我们就可以访问到前一块了。</p>
<h3 id="7-10本章小结"><a href="#7-10本章小结" class="headerlink" title="7.10本章小结"></a>7.10本章小结</h3><p>在本章中，我们详细讨论了一下hello是如何存在的。包括它的主体在哪里，怎么被读，怎么被写。还有后来进程过程中，如何被内核所“指导”、“监督”、“辅助”。内核在竭尽所能的满足hello的一切需要，可以说是“既当爹又当妈”。</p>
<h2 id="第8章-hello的IO管理"><a href="#第8章-hello的IO管理" class="headerlink" title="第8章 hello的IO管理"></a>第8章 hello的IO管理</h2><h3 id="8-1-Linux的IO设备管理方法"><a href="#8-1-Linux的IO设备管理方法" class="headerlink" title="8.1 Linux的IO设备管理方法"></a>8.1 Linux的IO设备管理方法</h3><p>设备的模型化：所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为Unix I/O。</p>
<h3 id="8-2-简述Unix-IO接口及其函数"><a href="#8-2-简述Unix-IO接口及其函数" class="headerlink" title="8.2 简述Unix IO接口及其函数"></a>8.2 简述Unix IO接口及其函数</h3><h4 id="8-2-1Unix-I-O接口统一操作"><a href="#8-2-1Unix-I-O接口统一操作" class="headerlink" title="8.2.1Unix I/O接口统一操作"></a>8.2.1Unix I/O接口统一操作</h4><p>（1）打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。<br>（2）Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。<br>（3）改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。<br>（4）读写文件：一个读操作就是从文件复制n&gt;0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k&gt;=m时，触发EOF。类似一个写操作就是从内存中复制n&gt;0个字节到一个文件，从当前文件位置k开始，然后更新k。<br>（5）关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。</p>
<h4 id="8-2-2-Unix-I-O函数"><a href="#8-2-2-Unix-I-O函数" class="headerlink" title="8.2.2 Unix I/O函数"></a>8.2.2 Unix I/O函数</h4><p>int open(char<em> filename,int flags,mode_t mode) ，进程通过调用open函数来打开一个存在的文件或是创建一个新文件的。open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。<br>int close(fd)，fd是需要关闭的文件的描述符，close返回操作结果。<br>ssize_t read(int fd,void </em>buf,size_t n)，read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF，否则返回值表示的是实际传送的字节数量。<br>ssize_t wirte(int fd,const void *buf,size_t n)，write函数从内存位置buf复制至多n个字节到描述符为fd的当前文件。</p>
<h3 id="8-3-printf的实现分析"><a href="#8-3-printf的实现分析" class="headerlink" title="8.3 printf的实现分析"></a>8.3 printf的实现分析</h3><p>我们首先查看一下printf的代码 ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int <span class="built_in">printf</span>(const char *fmt,…)</span><br><span class="line">&#123;</span><br><span class="line">	int i；</span><br><span class="line">	char buf[265];</span><br><span class="line">	va_list arg = (va_list)((char*)(&amp;fmt)+4);</span><br><span class="line">	i = vsprintf(buf,fmt,arg);</span><br><span class="line">	write(buf,i);</span><br><span class="line">	<span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们来看这一句va_list arg = (va_list)((char<em>)(&amp;fmt) + 4)；va_list的定义： typedef char </em>va_list ，这说明它是一个字符指针。其中的： (char*)(&amp;fmt) + 4) 表示的是…中的第一个参数。下面我们来看看下一句：i = vsprintf(buf, fmt, arg); 让我们来看看vsprintf(buf, fmt, arg)是什么函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int vsprintf(char *buf, const char *fmt, va_list args) </span><br><span class="line">   &#123; </span><br><span class="line">    char* p; </span><br><span class="line">    char tmp[256]; </span><br><span class="line">    va_list p_next_arg = args; </span><br><span class="line">    <span class="keyword">for</span> (p=buf;*fmt;fmt++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (*fmt != <span class="string">'%'</span>) &#123; </span><br><span class="line">    *p++ = *fmt; </span><br><span class="line">    <span class="built_in">continue</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    fmt++; </span><br><span class="line">    switch (*fmt) &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'x'</span>: </span><br><span class="line">    itoa(tmp, *((int*)p_next_arg)); </span><br><span class="line">    strcpy(p, tmp); </span><br><span class="line">    p_next_arg += 4; </span><br><span class="line">    p += strlen(tmp); </span><br><span class="line">    <span class="built_in">break</span>; </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'s'</span>: </span><br><span class="line">    <span class="built_in">break</span>; </span><br><span class="line">    default: </span><br><span class="line">    <span class="built_in">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">return</span> (p - buf); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们先不看它的具体内容。我们继续分析printf，它接受一个格式化的命令，并把指定的匹配的参数格式化输出。通过看vsprintf我们可以发现，它返回要打印出来的字符串的长度。接下来是write(buf, i);的实现就有点复杂了，我们先看看write。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> write: </span><br><span class="line">mov eax, _NR_write</span><br><span class="line">mov ebx, [esp + 4]</span><br><span class="line">mov ecx, [esp + 8] </span><br><span class="line">int INT_VECTOR_SYS_CALL</span><br></pre></td></tr></table></figure></p>
<p>这里是给几个寄存器传递了几个参数，然后一个int结束。这里的int INT_VECTOR_SYS_CALL 是通过系统来调用sys_call这个函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sys_call: </span><br><span class="line">     call save </span><br><span class="line">     push dword [p_proc_ready] </span><br><span class="line">     sti </span><br><span class="line">     push ecx </span><br><span class="line">     push ebx </span><br><span class="line">     call [sys_call_table + eax * 4] </span><br><span class="line">     add esp, 4 * 3 </span><br><span class="line">     mov [esi + EAXREG - P_STACKBASE], eax </span><br><span class="line">     cli </span><br><span class="line">     ret</span><br></pre></td></tr></table></figure></p>
<p>sys_call将字符串中的字节“Hello 1170300629 szm”从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。于是我们的打印字符串“Hello 1170300629 szm”就显示在了屏幕上。</p>
<h3 id="8-4-getchar的实现分析"><a href="#8-4-getchar的实现分析" class="headerlink" title="8.4 getchar的实现分析"></a>8.4 getchar的实现分析</h3><p>异步异常-键盘中断的处理：用户按键之后，键盘接口会得到按键扫描码，同时产生一个中断信号，之后当前程序陷入内核模式，处理该中断。具体就是接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。然后程序继续执行到getchar之后，getchar调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。</p>
<h3 id="8-5本章小结"><a href="#8-5本章小结" class="headerlink" title="8.5本章小结"></a>8.5本章小结</h3><p>本章我们看了一看hello是如何与用户进行交互的。熟悉了Linux的IO设备管理方法、Unix IO接口及其函数，分析了printf函数和getchar函数。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>hello，它悄悄地来了，然后悄悄地走了，挥一挥衣袖，不留下一丝痕迹。但它的点滴，CS都一一记录了下来：</p>
<ol>
<li>编写hello.c。程序员通过IDE编写构造出hello的最初形态；</li>
<li>预处理hello.c。预处理器将hello.c中调用的外部代码块合并到源代码中形成hello.i。</li>
<li>编译hello.i。编译器把hello.i编译成hello.s。</li>
<li>汇编hello.s。汇编器as将hello.s汇编成为可从定位文件hello.o。</li>
<li>链接hello.o。链接器ld将hello.o和其调用的外部函数通过符号解析和重定位生成可执行文件hello。</li>
<li>运行hello。在shell中输入./1170300629 szm执行hello。</li>
<li>创建进程。shell通过fork函数为hello创建新的进程。</li>
<li>加载hello。shell解析命令./1170300629 szm后，将其作为参数调用execve加载hello。</li>
<li>执行hello。hello在自己的进程中逐条执行它的指令，内核关注其执行状态，随时处理异常情况。</li>
<li>访问内存。内存管理系统将代码中的段地址转换为虚拟地址，再通过TLB和四级页表将虚拟地址转换为物理地址，再根据物理地址通过三级缓存找到对应数据。</li>
<li>申请动态内存。动态内存分配器为hello分配动态内存。</li>
<li>结束程序。CPU执行完hello的最后一条指令后，shell父进程回收hello进程。</li>
</ol>
<p>附件:</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">hello.i</td>
<td style="text-align:center">hello.c经过预处理之后生成的文件</td>
</tr>
<tr>
<td style="text-align:center">hello.s</td>
<td style="text-align:center">hello.i经过编译之后生成的汇编代码文件</td>
</tr>
<tr>
<td style="text-align:center">hello.o</td>
<td style="text-align:center">hello.s经过汇编之后生成的可重定位文件</td>
</tr>
<tr>
<td style="text-align:center">hello</td>
<td style="text-align:center">hello.o经过链接之后生成的可执行文件</td>
</tr>
<tr>
<td style="text-align:center">hello.elf</td>
<td style="text-align:center">hello.o的ELF格式</td>
</tr>
<tr>
<td style="text-align:center">helloout.elf</td>
<td style="text-align:center">hello的ELF格式</td>
</tr>
<tr>
<td style="text-align:center">helloout.asm</td>
<td style="text-align:center">hello反汇编生成的代码</td>
</tr>
<tr>
<td style="text-align:center">hello.asm</td>
<td style="text-align:center">hello.o反汇编生成的代码</td>
</tr>
</tbody>
</table>
<p>参考文献<br>[1]  Randal E.Bryant, David R.O’Hallaron著,龚奕利，贺莲译.深入理解计算机系统（第3版）[M].北京：机械工业出版社，2016.7（2018.4重印）<br>[2]  printf函数的深入剖析：<a href="https://www.cnblogs.com/pianist/p/3315801.html" target="_blank" rel="noopener">https://www.cnblogs.com/pianist/p/3315801.html</a><br>[3] 逻辑地址、物理地址、虚拟地址、线性地址：<a href="https://www.cnblogs.com/zengkefu/p/5452792.html" target="_blank" rel="noopener">https://www.cnblogs.com/zengkefu/p/5452792.html</a></p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2019年01月01日 00:59</p>
        <p>原始链接： <a class="post-url" href="/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/" title="程序人生-Hello’s P2P">https://Est-C.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/</a></p>
        <footer>
            <a href="https://Est-C.coding.me/Est-C.coding.me">
                <img src="/Est-C.coding.me/images/logo.jpeg" alt="Est">
                Est
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/Est-C.coding.me/false /images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/Est-C.coding.me/false /images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/Est-C.coding.me/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/Est-C.coding.me/false /images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/Est-C.coding.me/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://Est-C.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/&title=《程序人生-Hello’s P2P》 — Est&pic=https://Est-C.coding.me/Est-C.coding.meimages/logo.jpeg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://Est-C.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/&title=《程序人生-Hello’s P2P》 — Est&source=哈尔滨工业大学计算机系统大作业，作者：1170300629 时志敏" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://Est-C.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《程序人生-Hello’s P2P》 — Est&url=https://Est-C.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/&via=https://Est-C.coding.me/Est-C.coding.me" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://Est-C.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://Est-C.coding.me/Est-C.coding.me/2018/12/30/程序人生-Hello’s-P2P/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第1章-概述"><span class="post-toc-text">第1章 概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-Hello简介"><span class="post-toc-text">1.1 Hello简介</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-环境与工具"><span class="post-toc-text">1.2 环境与工具</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-中间结果"><span class="post-toc-text">1.3 中间结果</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-4-本章小结"><span class="post-toc-text">1.4 本章小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第2章-预处理"><span class="post-toc-text">第2章 预处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-预处理的概念与作用"><span class="post-toc-text">2.1 预处理的概念与作用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-1概念"><span class="post-toc-text">2.1.1概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-2作用"><span class="post-toc-text">2.1.2作用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2在Ubuntu下预处理的命令"><span class="post-toc-text">2.2在Ubuntu下预处理的命令</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-本章小结"><span class="post-toc-text">2.4 本章小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第3章-编译"><span class="post-toc-text">第3章 编译</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-编译的概念与作用"><span class="post-toc-text">3.1 编译的概念与作用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-1概念"><span class="post-toc-text">3.1.1概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-2作用"><span class="post-toc-text">3.1.2作用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-在Ubuntu下编译的命令"><span class="post-toc-text">3.2 在Ubuntu下编译的命令</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-Hello的编译结果解析"><span class="post-toc-text">3.3 Hello的编译结果解析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-1汇编指令"><span class="post-toc-text">3.3.1汇编指令</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-2数据"><span class="post-toc-text">3.3.2数据</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-3赋值"><span class="post-toc-text">3.3.3赋值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-4类型转换"><span class="post-toc-text">3.3.4类型转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-5算数操作"><span class="post-toc-text">3.3.5算数操作</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-6关系操作"><span class="post-toc-text">3.3.6关系操作</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-7数组存取"><span class="post-toc-text">3.3.7数组存取</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-8控制转移"><span class="post-toc-text">3.3.8控制转移</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-9函数操作"><span class="post-toc-text">3.3.9函数操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-本章小结"><span class="post-toc-text">3.4 本章小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第4章-汇编"><span class="post-toc-text">第4章 汇编</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1-汇编的概念与作用"><span class="post-toc-text">4.1 汇编的概念与作用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-1-1概念"><span class="post-toc-text">4.1.1概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-1-2作用"><span class="post-toc-text">4.1.2作用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-在Ubuntu下汇编的命令"><span class="post-toc-text">4.2 在Ubuntu下汇编的命令</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3-可重定位目标elf格式"><span class="post-toc-text">4.3 可重定位目标elf格式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-3-1ELF头"><span class="post-toc-text">4.3.1ELF头</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-3-2节头部表"><span class="post-toc-text">4.3.2节头部表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-3-3部分节展示"><span class="post-toc-text">4.3.3部分节展示</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-4-Hello-o的结果解析"><span class="post-toc-text">4.4 Hello.o的结果解析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-5-本章小结"><span class="post-toc-text">4.5 本章小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第5章-链接"><span class="post-toc-text">第5章 链接</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-1-链接的概念与作用"><span class="post-toc-text">5.1 链接的概念与作用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-1-1概念"><span class="post-toc-text">5.1.1概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-1-2作用"><span class="post-toc-text">5.1.2作用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-在Ubuntu下链接的命令"><span class="post-toc-text">5.2 在Ubuntu下链接的命令</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3-可执行目标文件hello的格式"><span class="post-toc-text">5.3 可执行目标文件hello的格式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-4-hello的虚拟地址空间"><span class="post-toc-text">5.4 hello的虚拟地址空间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-5-链接的重定位过程分析"><span class="post-toc-text">5.5 链接的重定位过程分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-5-1相对地址的重定位"><span class="post-toc-text">5.5.1相对地址的重定位</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-5-2绝对地址的重定位"><span class="post-toc-text">5.5.2绝对地址的重定位</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-6-hello的执行流程"><span class="post-toc-text">5.6 hello的执行流程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-7-Hello的动态链接分析"><span class="post-toc-text">5.7 Hello的动态链接分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-8-本章小结"><span class="post-toc-text">5.8 本章小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第6章-hello进程管理"><span class="post-toc-text">第6章 hello进程管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-1-进程的概念与作用"><span class="post-toc-text">6.1 进程的概念与作用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-1-1概念"><span class="post-toc-text">6.1.1概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-1-2作用"><span class="post-toc-text">6.1.2作用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-简述壳Shell-bash的作用与处理流程"><span class="post-toc-text">6.2 简述壳Shell-bash的作用与处理流程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-Hello的fork进程创建过程"><span class="post-toc-text">6.3 Hello的fork进程创建过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-4-Hello的execve过程"><span class="post-toc-text">6.4 Hello的execve过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-5-Hello的进程执行"><span class="post-toc-text">6.5 Hello的进程执行</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-6-hello的异常与信号处理"><span class="post-toc-text">6.6 hello的异常与信号处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-3-Hello的线性地址到物理地址的变换-页式管理"><span class="post-toc-text">7.3 Hello的线性地址到物理地址的变换-页式管理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-4-TLB与四级页表支持下的VA到PA的变换"><span class="post-toc-text">7.4 TLB与四级页表支持下的VA到PA的变换</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-5-三级Cache支持下的物理内存访问"><span class="post-toc-text">7.5 三级Cache支持下的物理内存访问</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-6-hello进程fork时的内存映射"><span class="post-toc-text">7.6 hello进程fork时的内存映射</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-7-hello进程execve时的内存映射"><span class="post-toc-text">7.7 hello进程execve时的内存映射</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-8-缺页故障与缺页中断处理"><span class="post-toc-text">7.8 缺页故障与缺页中断处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-9动态存储分配管理"><span class="post-toc-text">7.9动态存储分配管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-9-1空闲块的组织方式"><span class="post-toc-text">7.9.1空闲块的组织方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-9-2分配空闲块"><span class="post-toc-text">7.9.2分配空闲块</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-9-3分割空闲块"><span class="post-toc-text">7.9.3分割空闲块</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-9-4获得额外的堆内存"><span class="post-toc-text">7.9.4获得额外的堆内存</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-9-5合并相邻的空闲块"><span class="post-toc-text">7.9.5合并相邻的空闲块</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-10本章小结"><span class="post-toc-text">7.10本章小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第8章-hello的IO管理"><span class="post-toc-text">第8章 hello的IO管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-1-Linux的IO设备管理方法"><span class="post-toc-text">8.1 Linux的IO设备管理方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-2-简述Unix-IO接口及其函数"><span class="post-toc-text">8.2 简述Unix IO接口及其函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-2-1Unix-I-O接口统一操作"><span class="post-toc-text">8.2.1Unix I/O接口统一操作</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-2-2-Unix-I-O函数"><span class="post-toc-text">8.2.2 Unix I/O函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-3-printf的实现分析"><span class="post-toc-text">8.3 printf的实现分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-4-getchar的实现分析"><span class="post-toc-text">8.4 getchar的实现分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-5本章小结"><span class="post-toc-text">8.5本章小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结论"><span class="post-toc-text">结论</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
  
    <a href="/Est-C.coding.me/2018/11/27/BiTree/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">BiTree</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    



  
  <div id="lv-container" data-id="city" data-uid="MTAyMC80MDUxMy8xNzA0MA==">
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>

  



</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
     <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
     <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2019 Est<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://Est-C.coding.me/Est-C.coding.me",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/Est-C.coding.me/tags/C源码/" style="font-size: 10px;">C源码</a> <a href="/Est-C.coding.me/tags/数据结构/" style="font-size: 20px;">数据结构</a> <a href="/Est-C.coding.me/tags/算法/" style="font-size: 10px;">算法</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/Est-C.coding.me/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/Est-C.coding.me/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/Est-C.coding.me/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
            <li>
                <a  ">
                    <i class="fa fa-tags"></i><span></span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/Est-C.coding.me/tags/C源码/" style="font-size: 10px;">C源码</a> <a href="/Est-C.coding.me/tags/数据结构/" style="font-size: 20px;">数据结构</a> <a href="/Est-C.coding.me/tags/算法/" style="font-size: 10px;">算法</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/Est-C.coding.me/js/search.js"></script>
<script src="/Est-C.coding.me/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/Est-C.coding.me/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/Est-C.coding.me/js/animate.js"></script>


  <script src="/Est-C.coding.me/js/pop-img.js"></script>
  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
<script src="/Est-C.coding.me/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"live2d-widget-model-shizuku"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body>
</html>